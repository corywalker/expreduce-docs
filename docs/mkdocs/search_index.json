{
    "docs": [
        {
            "location": "/", 
            "text": "Expreduce documentation", 
            "title": "Home"
        }, 
        {
            "location": "/#expreduce-documentation", 
            "text": "", 
            "title": "Expreduce documentation"
        }, 
        {
            "location": "/builtin/combinatorics/", 
            "text": "combinatorics documentation\n\n\nIntegerPartitions\n\n\nPermutations\n\n\nMultinomial", 
            "title": "combinatorics"
        }, 
        {
            "location": "/builtin/combinatorics/#combinatorics-documentation", 
            "text": "IntegerPartitions  Permutations  Multinomial", 
            "title": "combinatorics documentation"
        }, 
        {
            "location": "/builtin/combinatorics/integerpartitions/", 
            "text": "IntegerPartitions\n\n\nIntegerPartitions[n]\n lists the possible ways to partition \nn\n into smaller integers.\n\n\nIntegerPartitions[n, k]\n lists the possible ways to partition \nn\n into smaller integers, using up to \nk\n elements.\n\n\nAttributes[IntegerPartitions] := {Protected}\n\n\nSimple examples\n\n\nFind the partitions of 4:\n\n\nIn\n[\n1\n]\n:=\n \nIntegerPartitions\n[\n4\n]\n\n\nOut\n[\n1\n]\n=\n \n{{\n4\n},\n \n{\n3\n,\n \n1\n},\n \n{\n2\n,\n \n2\n},\n \n{\n2\n,\n \n1\n,\n \n1\n},\n \n{\n1\n,\n \n1\n,\n \n1\n,\n \n1\n}}\n\n\n\n\n\n\nFind the partitions of 10, using a maximum of k = 2 integers:\n\n\nIn\n[\n2\n]\n:=\n \nIntegerPartitions\n[\n10\n,\n \n2\n]\n\n\nOut\n[\n2\n]\n=\n \n{{\n10\n},\n \n{\n9\n,\n \n1\n},\n \n{\n8\n,\n \n2\n},\n \n{\n7\n,\n \n3\n},\n \n{\n6\n,\n \n4\n},\n \n{\n5\n,\n \n5\n}}\n\n\n\n\n\n\nFurther examples\n\n\nThe partitions of zero is a nested empty List:\n\n\nIn\n[\n1\n]\n:=\n \nIntegerPartitions\n[\n0\n]\n\n\nOut\n[\n1\n]\n=\n \n{{}}", 
            "title": "IntegerPartitions "
        }, 
        {
            "location": "/builtin/combinatorics/integerpartitions/#integerpartitions", 
            "text": "IntegerPartitions[n]  lists the possible ways to partition  n  into smaller integers.  IntegerPartitions[n, k]  lists the possible ways to partition  n  into smaller integers, using up to  k  elements.  Attributes[IntegerPartitions] := {Protected}", 
            "title": "IntegerPartitions"
        }, 
        {
            "location": "/builtin/combinatorics/integerpartitions/#simple-examples", 
            "text": "Find the partitions of 4:  In [ 1 ] :=   IntegerPartitions [ 4 ]  Out [ 1 ] =   {{ 4 },   { 3 ,   1 },   { 2 ,   2 },   { 2 ,   1 ,   1 },   { 1 ,   1 ,   1 ,   1 }}   Find the partitions of 10, using a maximum of k = 2 integers:  In [ 2 ] :=   IntegerPartitions [ 10 ,   2 ]  Out [ 2 ] =   {{ 10 },   { 9 ,   1 },   { 8 ,   2 },   { 7 ,   3 },   { 6 ,   4 },   { 5 ,   5 }}", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/combinatorics/integerpartitions/#further-examples", 
            "text": "The partitions of zero is a nested empty List:  In [ 1 ] :=   IntegerPartitions [ 0 ]  Out [ 1 ] =   {{}}", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/combinatorics/permutations/", 
            "text": "Permutations\n\n\nPermutations[list]\n lists the possible permutations for a given list.\n\n\nAttributes[Permutations] := {Protected}\n\n\nSimple examples\n\n\nFind the permutations of \n{1, 2, 3}\n:\n\n\nIn\n[\n1\n]\n:=\n \nPermutations\n[\nRange\n[\n3\n]]\n\n\nOut\n[\n1\n]\n=\n \n{{\n1\n,\n \n2\n,\n \n3\n},\n \n{\n1\n,\n \n3\n,\n \n2\n},\n \n{\n2\n,\n \n1\n,\n \n3\n},\n \n{\n2\n,\n \n3\n,\n \n1\n},\n \n{\n3\n,\n \n1\n,\n \n2\n},\n \n{\n3\n,\n \n2\n,\n \n1\n}}\n\n\n\n\n\n\nPermutations\n ignores duplicates:\n\n\nIn\n[\n2\n]\n:=\n \nPermutations\n[{\n1\n,\n \n2\n,\n \n2\n}]\n\n\nOut\n[\n2\n]\n=\n \n{{\n1\n,\n \n2\n,\n \n2\n},\n \n{\n2\n,\n \n1\n,\n \n2\n},\n \n{\n2\n,\n \n2\n,\n \n1\n}}", 
            "title": "Permutations "
        }, 
        {
            "location": "/builtin/combinatorics/permutations/#permutations", 
            "text": "Permutations[list]  lists the possible permutations for a given list.  Attributes[Permutations] := {Protected}", 
            "title": "Permutations"
        }, 
        {
            "location": "/builtin/combinatorics/permutations/#simple-examples", 
            "text": "Find the permutations of  {1, 2, 3} :  In [ 1 ] :=   Permutations [ Range [ 3 ]]  Out [ 1 ] =   {{ 1 ,   2 ,   3 },   { 1 ,   3 ,   2 },   { 2 ,   1 ,   3 },   { 2 ,   3 ,   1 },   { 3 ,   1 ,   2 },   { 3 ,   2 ,   1 }}   Permutations  ignores duplicates:  In [ 2 ] :=   Permutations [{ 1 ,   2 ,   2 }]  Out [ 2 ] =   {{ 1 ,   2 ,   2 },   { 2 ,   1 ,   2 },   { 2 ,   2 ,   1 }}", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/combinatorics/multinomial/", 
            "text": "Multinomial\n\n\nMultinomial[n1, n2, ...]\n gives the multinomial coefficient for the given term.\n\n\nAttributes[Multinomial] := {Listable, NumericFunction, Orderless, Protected, ReadProtected}\n\n\nSimple examples\n\n\nFind the multinomial coefficient for the 1, 3, 1 term:\n\n\nIn\n[\n1\n]\n:=\n \nMultinomial\n[\n1\n,\n \n3\n,\n \n1\n]\n\n\nOut\n[\n1\n]\n=\n \n20\n\n\n\n\n\n\nMultinomial\n handles symbolic arguments:\n\n\nIn\n[\n2\n]\n:=\n \nMultinomial\n[\n1\n,\nk\n,\n1\n]\n\n\nOut\n[\n2\n]\n=\n \nFactorial\n[\nk\n+\n2\n]\n \n/\n \nFactorial\n[\nk\n]\n\n\n\n\n\n\nRules\n\n\nMultinomial\n[\nseq___\n]\n \n:=\n \nFactorial\n[\nApply\n[\nPlus\n,\n \n{\nseq\n}]]\n \n/\n \nApply\n[\nTimes\n,\n \nMap\n[\nFactorial\n,\n \n{\nseq\n}]]", 
            "title": "Multinomial "
        }, 
        {
            "location": "/builtin/combinatorics/multinomial/#multinomial", 
            "text": "Multinomial[n1, n2, ...]  gives the multinomial coefficient for the given term.  Attributes[Multinomial] := {Listable, NumericFunction, Orderless, Protected, ReadProtected}", 
            "title": "Multinomial"
        }, 
        {
            "location": "/builtin/combinatorics/multinomial/#simple-examples", 
            "text": "Find the multinomial coefficient for the 1, 3, 1 term:  In [ 1 ] :=   Multinomial [ 1 ,   3 ,   1 ]  Out [ 1 ] =   20   Multinomial  handles symbolic arguments:  In [ 2 ] :=   Multinomial [ 1 , k , 1 ]  Out [ 2 ] =   Factorial [ k + 2 ]   /   Factorial [ k ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/combinatorics/multinomial/#rules", 
            "text": "Multinomial [ seq___ ]   :=   Factorial [ Apply [ Plus ,   { seq }]]   /   Apply [ Times ,   Map [ Factorial ,   { seq }]]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/calculus/", 
            "text": "calculus documentation\n\n\nD\n\n\nIntegrate", 
            "title": "calculus"
        }, 
        {
            "location": "/builtin/calculus/#calculus-documentation", 
            "text": "D  Integrate", 
            "title": "calculus documentation"
        }, 
        {
            "location": "/builtin/calculus/d/", 
            "text": "D\n\n\nD[f, x]\n finds the partial derivative of \nf\n with respect to \nx\n.\n\n\nAttributes[D] := {Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nD\n[\n2\n/\n3\n*\nx\n^\n(\n3\n/\n2\n)\n \n+\n \n2\n/\n5\n*\nx\n^\n(\n5\n/\n2\n),\n \nx\n]\n\n\nOut\n[\n1\n]\n=\n \nSqrt\n[\nx\n]\n \n+\n \nx\n^\n(\n3\n/\n2\n)\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nD\n[\nLog\n[\n5\n \nx\n^\n2\n],\n \nx\n]\n\n\nOut\n[\n2\n]\n=\n \n2\n/\nx\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nD\n[\nCos\n[\nLog\n[\nx\n]],\n \nx\n]\n\n\nOut\n[\n3\n]\n=\n \n-\n(\nSin\n[\nLog\n[\nx\n]]\n/\nx\n)\n\n\n\n\n\n\nRules\n\n\nD\n[\nx_\n,\nx_\n]\n \n:=\n \n1\n\n\nD\n[\na_\n,\nx_\n]\n \n:=\n \n0\n\n\nD\n[\na_\n+\nb__\n,\nx_\n]\n \n:=\n \nD\n[\na\n,\nx\n]\n+\nD\n[\nPlus\n[\nb\n],\nx\n]\n\n\nD\n[\na_\n \nb__\n,\nx_\n]\n \n:=\n \nD\n[\na\n,\nx\n]\n \nb\n+\na\n \nD\n[\nTimes\n[\nb\n],\nx\n]\n\n\nD\n[\na_\n^\n(\nb_\n),\n \nx_\n]\n \n:=\n \na\n^\nb\n*\n(\nD\n[\nb\n,\nx\n]\n \nLog\n[\na\n]\n+\nD\n[\na\n,\nx\n]\n/\na\n*\nb\n)\n\n\nD\n[\nLog\n[\na_\n],\n \nx_\n]\n \n:=\n \nD\n[\na\n,\n \nx\n]\n/\na\n\n\nD\n[\nSin\n[\na_\n],\n \nx_\n]\n \n:=\n \nD\n[\na\n,\nx\n]\n \nCos\n[\na\n]\n\n\nD\n[\nCos\n[\na_\n],\n \nx_\n]\n \n:=\n \n-\nD\n[\na\n,\nx\n]\n \nSin\n[\na\n]", 
            "title": "D "
        }, 
        {
            "location": "/builtin/calculus/d/#d", 
            "text": "D[f, x]  finds the partial derivative of  f  with respect to  x .  Attributes[D] := {Protected, ReadProtected}", 
            "title": "D"
        }, 
        {
            "location": "/builtin/calculus/d/#simple-examples", 
            "text": "In [ 1 ] :=   D [ 2 / 3 * x ^ ( 3 / 2 )   +   2 / 5 * x ^ ( 5 / 2 ),   x ]  Out [ 1 ] =   Sqrt [ x ]   +   x ^ ( 3 / 2 )   In [ 2 ] :=   D [ Log [ 5   x ^ 2 ],   x ]  Out [ 2 ] =   2 / x   In [ 3 ] :=   D [ Cos [ Log [ x ]],   x ]  Out [ 3 ] =   - ( Sin [ Log [ x ]] / x )", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/calculus/d/#rules", 
            "text": "D [ x_ , x_ ]   :=   1  D [ a_ , x_ ]   :=   0  D [ a_ + b__ , x_ ]   :=   D [ a , x ] + D [ Plus [ b ], x ]  D [ a_   b__ , x_ ]   :=   D [ a , x ]   b + a   D [ Times [ b ], x ]  D [ a_ ^ ( b_ ),   x_ ]   :=   a ^ b * ( D [ b , x ]   Log [ a ] + D [ a , x ] / a * b )  D [ Log [ a_ ],   x_ ]   :=   D [ a ,   x ] / a  D [ Sin [ a_ ],   x_ ]   :=   D [ a , x ]   Cos [ a ]  D [ Cos [ a_ ],   x_ ]   :=   - D [ a , x ]   Sin [ a ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/calculus/integrate/", 
            "text": "Integrate\n\n\nIntegrate[f, x]\n finds the indefinite integral of \nf\n with respect to \nx\n.\n\n\n\n\nUnder development\n\n\nThis function is under development, and as such will be incomplete and inaccurate.\n\n\n\n\nAttributes[Integrate] := {Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nIntegrate\n[\nx\n^\n(\n2\n/\n3\n)\n \n+\n \n3\n \nx\n \n+\n \n2\n,\n \nx\n]\n\n\nOut\n[\n1\n]\n=\n \n2\n \nx\n \n+\n \n(\n3\n \nx\n^\n(\n5\n/\n3\n))\n/\n5\n \n+\n \n(\n3\n \nx\n^\n2\n)\n/\n2\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nIntegrate\n[\nIntegrate\n[\nSin\n[\nx\n]\n \n+\n \nLog\n[\nx\n],\n \nx\n],\n \nx\n]\n\n\nOut\n[\n2\n]\n=\n \n-\n((\n3\n \nx\n^\n2\n)\n/\n4\n)\n \n+\n \n(\n1\n/\n2\n)\n \n(\nx\n^\n2\n)\n \nLog\n[\nx\n]\n \n-\n \nSin\n[\nx\n]\n\n\n\n\n\n\nRules\n\n\nIntegrate\n[\na_Integer\n,\nx_Symbol\n]\n \n:=\n \na\n*\nx\n\n\nIntegrate\n[\na_Integer\n*\nb_\n,\nx_Symbol\n]\n \n:=\n \na\n*\nIntegrate\n[\nb\n,\nx\n]\n\n\nIntegrate\n[\na_\n+\nb__\n,\nx_Symbol\n]\n \n:=\n \nIntegrate\n[\na\n,\nx\n]\n+\nIntegrate\n[\nPlus\n[\nb\n],\nx\n]\n\n\nIntegrate\n[\nx_Symbol\n,\nx_Symbol\n]\n \n:=\n \nx\n^\n2\n/\n2\n\n\nIntegrate\n[\nx_Symbol\n^\nn_Integer\n,\n \nx_Symbol\n]\n \n:=\n \nx\n^\n(\nn\n+\n1\n)\n/\n(\nn\n+\n1\n)\n\n\nIntegrate\n[\nx_Symbol\n^\nn_Rational\n,\n \nx_Symbol\n]\n \n:=\n \nx\n^\n(\nn\n+\n1\n)\n/\n(\nn\n+\n1\n)\n\n\nIntegrate\n[\n1\n/\nx_Symbol\n,\nx_Symbol\n]\n \n:=\n \nLog\n[\nAbs\n[\nx\n]]\n\n\nIntegrate\n[\nLog\n[\nx_Symbol\n],\nx_Symbol\n]\n \n:=\n \n-\nx\n \n+\n \nx\n \nLog\n[\nx\n]\n\n\nIntegrate\n[\nx_Symbol\n*\nLog\n[\nx_Symbol\n],\nx_Symbol\n]\n \n:=\n \n-\n((\nx\n^\n2\n)\n/\n4\n)\n \n+\n \n(\n1\n/\n2\n)\n*\n(\nx\n^\n2\n)\n*\nLog\n[\nx\n]\n\n\nIntegrate\n[\nSin\n[\nx_Symbol\n],\nx_Symbol\n]\n \n:=\n \n-\nCos\n[\nx\n]\n\n\nIntegrate\n[\nCos\n[\nx_Symbol\n],\nx_Symbol\n]\n \n:=\n \nSin\n[\nx\n]\n\n\nIntegrate\n[\nTan\n[\nx_Symbol\n],\nx_Symbol\n]\n \n:=\n \n-\nLog\n[\nCos\n[\nx\n]]", 
            "title": "Integrate "
        }, 
        {
            "location": "/builtin/calculus/integrate/#integrate", 
            "text": "Integrate[f, x]  finds the indefinite integral of  f  with respect to  x .   Under development  This function is under development, and as such will be incomplete and inaccurate.   Attributes[Integrate] := {Protected, ReadProtected}", 
            "title": "Integrate"
        }, 
        {
            "location": "/builtin/calculus/integrate/#simple-examples", 
            "text": "In [ 1 ] :=   Integrate [ x ^ ( 2 / 3 )   +   3   x   +   2 ,   x ]  Out [ 1 ] =   2   x   +   ( 3   x ^ ( 5 / 3 )) / 5   +   ( 3   x ^ 2 ) / 2   In [ 2 ] :=   Integrate [ Integrate [ Sin [ x ]   +   Log [ x ],   x ],   x ]  Out [ 2 ] =   - (( 3   x ^ 2 ) / 4 )   +   ( 1 / 2 )   ( x ^ 2 )   Log [ x ]   -   Sin [ x ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/calculus/integrate/#rules", 
            "text": "Integrate [ a_Integer , x_Symbol ]   :=   a * x  Integrate [ a_Integer * b_ , x_Symbol ]   :=   a * Integrate [ b , x ]  Integrate [ a_ + b__ , x_Symbol ]   :=   Integrate [ a , x ] + Integrate [ Plus [ b ], x ]  Integrate [ x_Symbol , x_Symbol ]   :=   x ^ 2 / 2  Integrate [ x_Symbol ^ n_Integer ,   x_Symbol ]   :=   x ^ ( n + 1 ) / ( n + 1 )  Integrate [ x_Symbol ^ n_Rational ,   x_Symbol ]   :=   x ^ ( n + 1 ) / ( n + 1 )  Integrate [ 1 / x_Symbol , x_Symbol ]   :=   Log [ Abs [ x ]]  Integrate [ Log [ x_Symbol ], x_Symbol ]   :=   - x   +   x   Log [ x ]  Integrate [ x_Symbol * Log [ x_Symbol ], x_Symbol ]   :=   - (( x ^ 2 ) / 4 )   +   ( 1 / 2 ) * ( x ^ 2 ) * Log [ x ]  Integrate [ Sin [ x_Symbol ], x_Symbol ]   :=   - Cos [ x ]  Integrate [ Cos [ x_Symbol ], x_Symbol ]   :=   Sin [ x ]  Integrate [ Tan [ x_Symbol ], x_Symbol ]   :=   - Log [ Cos [ x ]]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/comparison/", 
            "text": "comparison documentation\n\n\nEqual\n\n\nUnequal\n\n\nSameQ\n\n\nMatchQ", 
            "title": "comparison"
        }, 
        {
            "location": "/builtin/comparison/#comparison-documentation", 
            "text": "Equal  Unequal  SameQ  MatchQ", 
            "title": "comparison documentation"
        }, 
        {
            "location": "/builtin/comparison/equal/", 
            "text": "Equal\n\n\nlhs == rhs\n evaluates to True or False if equality or inequality is known.\n\n\nAttributes[Equal] := {Protected}\n\n\nSimple examples\n\n\nExpressions known to be equal will evaluate to True:\n\n\nIn\n[\n1\n]\n:=\n \n9\n*\nx\n==\nx\n*\n9\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nSometimes expressions may or may not be equal, or Expreduce does not know how to test for equality. In these cases, the statement will remain unevaluated:\n\n\nIn\n[\n2\n]\n:=\n \n9\n*\nx\n==\nx\n*\n10\n\n\nOut\n[\n2\n]\n=\n \n((\n9\n \n*\n \nx\n))\n \n==\n \n((\n10\n \n*\n \nx\n))\n\n\n\n\n\n\nEqual considers Integers and Reals that are close enough to be equal:\n\n\nIn\n[\n3\n]\n:=\n \ntmp\n=\n5\n\n\nOut\n[\n3\n]\n=\n \n5\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \ntmp\n==\n5\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \ntmp\n==\n5.\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \ntmp\n==\n5.00000\n\n\nOut\n[\n6\n]\n=\n \nTrue\n\n\n\n\n\n\nEqual can test for Rational equality:\n\n\nIn\n[\n7\n]\n:=\n \n4\n/\n3\n==\n3\n/\n2\n\n\nOut\n[\n7\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \n4\n/\n3\n==\n8\n/\n6\n\n\nOut\n[\n8\n]\n=\n \nTrue\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nIf\n[\nxx\n \n==\n \n2\n,\n \nyy\n,\n \nzz\n]\n \n==\n \nIf\n[\nxx\n \n==\n \n2\n,\n \nyy\n,\n \nzz\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nEqual does not match patterns:\n\n\nIn\n[\n2\n]\n:=\n \n{\n1\n,\n \n2\n,\n \n3\n}\n \n==\n \n_List\n\n\nOut\n[\n2\n]\n=\n \n{\n1\n,\n \n2\n,\n \n3\n}\n \n==\n \n_List\n\n\n\n\n\n\nThis functionality is reserved for MatchQ:\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n_List\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue", 
            "title": "Equal "
        }, 
        {
            "location": "/builtin/comparison/equal/#equal", 
            "text": "lhs == rhs  evaluates to True or False if equality or inequality is known.  Attributes[Equal] := {Protected}", 
            "title": "Equal"
        }, 
        {
            "location": "/builtin/comparison/equal/#simple-examples", 
            "text": "Expressions known to be equal will evaluate to True:  In [ 1 ] :=   9 * x == x * 9  Out [ 1 ] =   True   Sometimes expressions may or may not be equal, or Expreduce does not know how to test for equality. In these cases, the statement will remain unevaluated:  In [ 2 ] :=   9 * x == x * 10  Out [ 2 ] =   (( 9   *   x ))   ==   (( 10   *   x ))   Equal considers Integers and Reals that are close enough to be equal:  In [ 3 ] :=   tmp = 5  Out [ 3 ] =   5   In [ 4 ] :=   tmp == 5  Out [ 4 ] =   True   In [ 5 ] :=   tmp == 5.  Out [ 5 ] =   True   In [ 6 ] :=   tmp == 5.00000  Out [ 6 ] =   True   Equal can test for Rational equality:  In [ 7 ] :=   4 / 3 == 3 / 2  Out [ 7 ] =   False   In [ 8 ] :=   4 / 3 == 8 / 6  Out [ 8 ] =   True", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/comparison/equal/#further-examples", 
            "text": "In [ 1 ] :=   If [ xx   ==   2 ,   yy ,   zz ]   ==   If [ xx   ==   2 ,   yy ,   zz ]  Out [ 1 ] =   True   Equal does not match patterns:  In [ 2 ] :=   { 1 ,   2 ,   3 }   ==   _List  Out [ 2 ] =   { 1 ,   2 ,   3 }   ==   _List   This functionality is reserved for MatchQ:  In [ 3 ] :=   MatchQ [{ 1 ,   2 ,   3 },   _List ]  Out [ 3 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/comparison/unequal/", 
            "text": "Unequal\n\n\nlhs != rhs\n evaluates to True if inequality is known or False if equality is known.\n\n\nAttributes[Unequal] := {Protected}\n\n\nSimple examples\n\n\nExpressions known to be unequal will evaluate to True:\n\n\nIn\n[\n1\n]\n:=\n \n9\n \n!=\n \n8\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nSometimes expressions may or may not be unequal, or Expreduce does not know how to test for inequality. In these cases, the statement will remain unevaluated:\n\n\nIn\n[\n2\n]\n:=\n \n9\n*\nx\n \n!=\n \nx\n*\n10\n\n\nOut\n[\n2\n]\n=\n \n((\n9\n \n*\n \nx\n))\n \n!=\n \n((\n10\n \n*\n \nx\n))\n\n\n\n\n\n\nUnequal considers Integers and Reals that are close enough to be equal:\n\n\nIn\n[\n3\n]\n:=\n \ntmp\n=\n5\n\n\nOut\n[\n3\n]\n=\n \n5\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \ntmp\n \n!=\n \n5\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \ntmp\n \n!=\n \n5.\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \ntmp\n \n!=\n \n5.00000\n\n\nOut\n[\n6\n]\n=\n \nFalse\n\n\n\n\n\n\nUnequal can test for Rational inequality:\n\n\nIn\n[\n7\n]\n:=\n \n4\n/\n3\n \n!=\n \n3\n/\n2\n\n\nOut\n[\n7\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \n4\n/\n3\n \n!=\n \n8\n/\n6\n\n\nOut\n[\n8\n]\n=\n \nFalse", 
            "title": "Unequal "
        }, 
        {
            "location": "/builtin/comparison/unequal/#unequal", 
            "text": "lhs != rhs  evaluates to True if inequality is known or False if equality is known.  Attributes[Unequal] := {Protected}", 
            "title": "Unequal"
        }, 
        {
            "location": "/builtin/comparison/unequal/#simple-examples", 
            "text": "Expressions known to be unequal will evaluate to True:  In [ 1 ] :=   9   !=   8  Out [ 1 ] =   True   Sometimes expressions may or may not be unequal, or Expreduce does not know how to test for inequality. In these cases, the statement will remain unevaluated:  In [ 2 ] :=   9 * x   !=   x * 10  Out [ 2 ] =   (( 9   *   x ))   !=   (( 10   *   x ))   Unequal considers Integers and Reals that are close enough to be equal:  In [ 3 ] :=   tmp = 5  Out [ 3 ] =   5   In [ 4 ] :=   tmp   !=   5  Out [ 4 ] =   False   In [ 5 ] :=   tmp   !=   5.  Out [ 5 ] =   False   In [ 6 ] :=   tmp   !=   5.00000  Out [ 6 ] =   False   Unequal can test for Rational inequality:  In [ 7 ] :=   4 / 3   !=   3 / 2  Out [ 7 ] =   True   In [ 8 ] :=   4 / 3   !=   8 / 6  Out [ 8 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/comparison/sameq/", 
            "text": "SameQ\n\n\nlhs === rhs\n evaluates to True if \nlhs\n and \nrhs\n are identical after evaluation, False otherwise.\n\n\nAttributes[SameQ] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \na\n===\na\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \n5\n \n===\n \n5\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nUnlike Equal, SameQ does not forgive differences between Integers and Reals:\n\n\nIn\n[\n3\n]\n:=\n \n5\n \n===\n \n5.\n\n\nOut\n[\n3\n]\n=\n \nFalse\n\n\n\n\n\n\nSameQ considers the arguments of all expressions and subexpressions:\n\n\nIn\n[\n4\n]\n:=\n \nfoo\n[\nx\n \n==\n \n2\n,\n \ny\n,\n \nx\n]\n \n===\n \nfoo\n[\nx\n \n==\n \n2\n,\n \ny\n,\n \nx\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nfoo\n[\nx\n \n==\n \n2\n,\n \ny\n,\n \nx\n]\n \n===\n \nfoo\n[\nx\n \n==\n \n2.\n,\n \ny\n,\n \nx\n]\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nFurther examples\n\n\nSameQ does not match patterns:\n\n\nIn\n[\n1\n]\n:=\n \n{\n1\n,\n \n2\n,\n \n3\n}\n \n===\n \n_List\n\n\nOut\n[\n1\n]\n=\n \nFalse\n\n\n\n\n\n\nThis functionality is reserved for MatchQ:\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n_List\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue", 
            "title": "SameQ "
        }, 
        {
            "location": "/builtin/comparison/sameq/#sameq", 
            "text": "lhs === rhs  evaluates to True if  lhs  and  rhs  are identical after evaluation, False otherwise.  Attributes[SameQ] := {Protected}", 
            "title": "SameQ"
        }, 
        {
            "location": "/builtin/comparison/sameq/#simple-examples", 
            "text": "In [ 1 ] :=   a === a  Out [ 1 ] =   True   In [ 2 ] :=   5   ===   5  Out [ 2 ] =   True   Unlike Equal, SameQ does not forgive differences between Integers and Reals:  In [ 3 ] :=   5   ===   5.  Out [ 3 ] =   False   SameQ considers the arguments of all expressions and subexpressions:  In [ 4 ] :=   foo [ x   ==   2 ,   y ,   x ]   ===   foo [ x   ==   2 ,   y ,   x ]  Out [ 4 ] =   True   In [ 5 ] :=   foo [ x   ==   2 ,   y ,   x ]   ===   foo [ x   ==   2. ,   y ,   x ]  Out [ 5 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/comparison/sameq/#further-examples", 
            "text": "SameQ does not match patterns:  In [ 1 ] :=   { 1 ,   2 ,   3 }   ===   _List  Out [ 1 ] =   False   This functionality is reserved for MatchQ:  In [ 2 ] :=   MatchQ [{ 1 ,   2 ,   3 },   _List ]  Out [ 2 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/comparison/matchq/", 
            "text": "MatchQ\n\n\nMatchQ[expr, form]\n returns True if \nexpr\n matches \nform\n, False otherwise.\n\n\nAttributes[MatchQ] := {Protected}\n\n\nSimple examples\n\n\nA \nBlank[]\n expression matches everything:\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\n2\n*\nx\n,\n \n_\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nAlthough a more specific pattern would have matched as well:\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\n2\n*\nx\n,\n \nc1_Integer\n*\na_Symbol\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nSince \nTimes\n is \nOrderless\n, this would work as well:\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\nx\n*\n2\n,\n \nc1_Integer\n*\na_Symbol\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nAs would the \nFullForm\n:\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\nTimes\n[\nx\n,\n \n2\n],\n \nc1_Integer\n*\na_Symbol\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nNamed patterns must match the same expression, or the match will fail:\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n,\n \nx_Symbol\n \n+\n \nx_Symbol\n]\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[{\n2\n^\na\n,\n \na\n},\n \n{\n2\n^\nx_Symbol\n,\n \nx_Symbol\n}]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[{\n2\n^\na\n,\n \nb\n},\n \n{\n2\n^\nx_Symbol\n,\n \nx_Symbol\n}]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nBlank\n sequences allow for the matching of multiple objects. \nBlankSequence\n (__) matches one or more parts of the expression:\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[{\na\n,\n \nb\n},\n \n{\na\n,\n \n__\n}]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[{\na\n},\n \n{\na\n,\n \n__\n}]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nBlankNullSequence\n (___) allows for zero or more matches:\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[{\na\n},\n \n{\na\n,\n \n___\n}]\n\n\nOut\n[\n5\n]\n=\n \nTrue", 
            "title": "MatchQ "
        }, 
        {
            "location": "/builtin/comparison/matchq/#matchq", 
            "text": "MatchQ[expr, form]  returns True if  expr  matches  form , False otherwise.  Attributes[MatchQ] := {Protected}", 
            "title": "MatchQ"
        }, 
        {
            "location": "/builtin/comparison/matchq/#simple-examples", 
            "text": "A  Blank[]  expression matches everything:  In [ 1 ] :=   MatchQ [ 2 * x ,   _ ]  Out [ 1 ] =   True   Although a more specific pattern would have matched as well:  In [ 2 ] :=   MatchQ [ 2 * x ,   c1_Integer * a_Symbol ]  Out [ 2 ] =   True   Since  Times  is  Orderless , this would work as well:  In [ 3 ] :=   MatchQ [ x * 2 ,   c1_Integer * a_Symbol ]  Out [ 3 ] =   True   As would the  FullForm :  In [ 4 ] :=   MatchQ [ Times [ x ,   2 ],   c1_Integer * a_Symbol ]  Out [ 4 ] =   True   Named patterns must match the same expression, or the match will fail:  In [ 5 ] :=   MatchQ [ a   +   b ,   x_Symbol   +   x_Symbol ]  Out [ 5 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/comparison/matchq/#further-examples", 
            "text": "In [ 1 ] :=   MatchQ [{ 2 ^ a ,   a },   { 2 ^ x_Symbol ,   x_Symbol }]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [{ 2 ^ a ,   b },   { 2 ^ x_Symbol ,   x_Symbol }]  Out [ 2 ] =   False   Blank  sequences allow for the matching of multiple objects.  BlankSequence  (__) matches one or more parts of the expression:  In [ 3 ] :=   MatchQ [{ a ,   b },   { a ,   __ }]  Out [ 3 ] =   True   In [ 4 ] :=   MatchQ [{ a },   { a ,   __ }]  Out [ 4 ] =   False   BlankNullSequence  (___) allows for zero or more matches:  In [ 5 ] :=   MatchQ [{ a },   { a ,   ___ }]  Out [ 5 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/constants/", 
            "text": "constants documentation\n\n\nRational\n\n\nNumberQ\n\n\nString\n\n\nReal\n\n\nInteger", 
            "title": "constants"
        }, 
        {
            "location": "/builtin/constants/#constants-documentation", 
            "text": "Rational  NumberQ  String  Real  Integer", 
            "title": "constants documentation"
        }, 
        {
            "location": "/builtin/constants/rational/", 
            "text": "Rational\n\n\nRational\n is the head for the atomic rational type.\n\n\nAttributes[Rational] := {Protected}\n\n\nSimple examples\n\n\nRationals are created from \nTimes\n when a rational form is encountered:\n\n\nIn\n[\n1\n]\n:=\n \nTimes\n[\n5\n,\n \n6\n^-\n1\n]\n \n//\n \nHead\n\n\nOut\n[\n1\n]\n=\n \nRational\n\n\n\n\n\n\nWhich is equivalent to typing them in directly:\n\n\nIn\n[\n2\n]\n:=\n \n5\n/\n6\n \n//\n \nHead\n\n\nOut\n[\n2\n]\n=\n \nRational\n\n\n\n\n\n\nOr being even more explicit:\n\n\nIn\n[\n3\n]\n:=\n \nRational\n[\n5\n,\n \n6\n]\n \n//\n \nHead\n\n\nOut\n[\n3\n]\n=\n \nRational\n\n\n\n\n\n\nRationals simplify on evaluation:\n\n\nIn\n[\n4\n]\n:=\n \nRational\n[\n10\n,\n \n6\n]\n\n\nOut\n[\n4\n]\n=\n \n5\n/\n3\n\n\n\n\n\n\nWhich might include evaluating to an Integer:\n\n\nIn\n[\n5\n]\n:=\n \nRational\n[\n-\n100\n,\n \n10\n]\n \n//\n \nHead\n\n\nOut\n[\n5\n]\n=\n \nInteger\n\n\n\n\n\n\nRationals of non-Integer types are not allowed:\n\n\nIn\n[\n6\n]\n:=\n \nRational\n[\n0\n,\n \nn\n]\n\n\nOut\n[\n6\n]\n=\n \nRational\n[\n0\n,\n \nn\n]\n\n\n\n\n\n\nFurther examples\n\n\nUndefined rationals are handled accordingly:\n\n\nIn\n[\n1\n]\n:=\n \nRational\n[\n0\n,\n \n0\n]\n\n\nOut\n[\n1\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nRational\n[\n1\n,\n \n0\n]\n\n\nOut\n[\n2\n]\n=\n \nComplexInfinity\n\n\n\n\n\n\nRational numbers have some special handling for pattern matching:\n\n\nIn\n[\n3\n]\n:=\n \ntest\n \n=\n \nRational\n[\n2\n,\n \n3\n]\n\n\nOut\n[\n3\n]\n=\n \n2\n/\n3\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\ntest\n,\n \n2\n/\n3\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\ntest\n,\n \nRational\n[\na_Integer\n,\n \nb_Integer\n]]\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \n2\n/\n3\n \n/.\n \nRational\n[\na_Integer\n,\n \nb_Integer\n]\n \n-\n \n{\na\n,\n \nb\n}\n\n\nOut\n[\n6\n]\n=\n \n{\n2\n,\n \n3\n}\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \n2\n/\n3\n \n/.\n \na_Integer\n/\nb_Integer\n \n-\n \n{\na\n,\n \nb\n}\n\n\nOut\n[\n7\n]\n=\n \n2\n/\n3", 
            "title": "Rational "
        }, 
        {
            "location": "/builtin/constants/rational/#rational", 
            "text": "Rational  is the head for the atomic rational type.  Attributes[Rational] := {Protected}", 
            "title": "Rational"
        }, 
        {
            "location": "/builtin/constants/rational/#simple-examples", 
            "text": "Rationals are created from  Times  when a rational form is encountered:  In [ 1 ] :=   Times [ 5 ,   6 ^- 1 ]   //   Head  Out [ 1 ] =   Rational   Which is equivalent to typing them in directly:  In [ 2 ] :=   5 / 6   //   Head  Out [ 2 ] =   Rational   Or being even more explicit:  In [ 3 ] :=   Rational [ 5 ,   6 ]   //   Head  Out [ 3 ] =   Rational   Rationals simplify on evaluation:  In [ 4 ] :=   Rational [ 10 ,   6 ]  Out [ 4 ] =   5 / 3   Which might include evaluating to an Integer:  In [ 5 ] :=   Rational [ - 100 ,   10 ]   //   Head  Out [ 5 ] =   Integer   Rationals of non-Integer types are not allowed:  In [ 6 ] :=   Rational [ 0 ,   n ]  Out [ 6 ] =   Rational [ 0 ,   n ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/constants/rational/#further-examples", 
            "text": "Undefined rationals are handled accordingly:  In [ 1 ] :=   Rational [ 0 ,   0 ]  Out [ 1 ] =   Indeterminate   In [ 2 ] :=   Rational [ 1 ,   0 ]  Out [ 2 ] =   ComplexInfinity   Rational numbers have some special handling for pattern matching:  In [ 3 ] :=   test   =   Rational [ 2 ,   3 ]  Out [ 3 ] =   2 / 3   In [ 4 ] :=   MatchQ [ test ,   2 / 3 ]  Out [ 4 ] =   True   In [ 5 ] :=   MatchQ [ test ,   Rational [ a_Integer ,   b_Integer ]]  Out [ 5 ] =   True   In [ 6 ] :=   2 / 3   /.   Rational [ a_Integer ,   b_Integer ]   -   { a ,   b }  Out [ 6 ] =   { 2 ,   3 }   In [ 7 ] :=   2 / 3   /.   a_Integer / b_Integer   -   { a ,   b }  Out [ 7 ] =   2 / 3", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/constants/numberq/", 
            "text": "NumberQ\n\n\nNumberQ[expr]\n returns True if \nexpr\n is numeric, otherwise False.\n\n\nAttributes[NumberQ] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nNumberQ\n[\n2\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nNumberQ\n[\n2.2\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nNumberQ\n[\nRational\n[\n5\n,\n \n2\n]]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nNumberQ\n[\nInfinity\n]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nNumberQ\n[\nSqrt\n[\n2\n]]\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nNumberQ\n[\nrandomvar\n]\n\n\nOut\n[\n6\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nNumberQ\n[\nhello\n]\n\n\nOut\n[\n7\n]\n=\n \nFalse", 
            "title": "NumberQ "
        }, 
        {
            "location": "/builtin/constants/numberq/#numberq", 
            "text": "NumberQ[expr]  returns True if  expr  is numeric, otherwise False.  Attributes[NumberQ] := {Protected}", 
            "title": "NumberQ"
        }, 
        {
            "location": "/builtin/constants/numberq/#simple-examples", 
            "text": "In [ 1 ] :=   NumberQ [ 2 ]  Out [ 1 ] =   True   In [ 2 ] :=   NumberQ [ 2.2 ]  Out [ 2 ] =   True   In [ 3 ] :=   NumberQ [ Rational [ 5 ,   2 ]]  Out [ 3 ] =   True   In [ 4 ] :=   NumberQ [ Infinity ]  Out [ 4 ] =   False   In [ 5 ] :=   NumberQ [ Sqrt [ 2 ]]  Out [ 5 ] =   False   In [ 6 ] :=   NumberQ [ randomvar ]  Out [ 6 ] =   False   In [ 7 ] :=   NumberQ [ hello ]  Out [ 7 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/constants/string/", 
            "text": "String\n\n\nString\n is the head for the atomic string type.\n\n\nAttributes[String] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHello\n\n\nOut\n[\n1\n]\n=\n \nHello\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nHello\n \n==\n \nHello\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nHello\n \n==\n \nHello world\n\n\nOut\n[\n3\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nHead\n[\nHello\n]\n\n\nOut\n[\n4\n]\n=\n \nString", 
            "title": "String "
        }, 
        {
            "location": "/builtin/constants/string/#string", 
            "text": "String  is the head for the atomic string type.  Attributes[String] := {Protected}", 
            "title": "String"
        }, 
        {
            "location": "/builtin/constants/string/#simple-examples", 
            "text": "In [ 1 ] :=   Hello  Out [ 1 ] =   Hello   In [ 2 ] :=   Hello   ==   Hello  Out [ 2 ] =   True   In [ 3 ] :=   Hello   ==   Hello world  Out [ 3 ] =   False   In [ 4 ] :=   Head [ Hello ]  Out [ 4 ] =   String", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/constants/real/", 
            "text": "Real\n\n\nReal\n is the head for the atomic floating point type.\n\n\nAttributes[Real] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHead\n[\n1.53\n]\n\n\nOut\n[\n1\n]\n=\n \nReal\n\n\n\n\n\n\nOne can force Real interperetation on an Integer by appending a decimal point:\n\n\nIn\n[\n2\n]\n:=\n \nHead\n[\n1.\n]\n\n\nOut\n[\n2\n]\n=\n \nReal\n\n\n\n\n\n\nReal numbers are backed by arbitrary-precision floating points:\n\n\nIn\n[\n3\n]\n:=\n \n10.\n^\n5000\n \n/\n \n10.\n^\n4999\n\n\nOut\n[\n3\n]\n=\n \n10.\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\n1.53\n,\n \n_Real\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue", 
            "title": "Real "
        }, 
        {
            "location": "/builtin/constants/real/#real", 
            "text": "Real  is the head for the atomic floating point type.  Attributes[Real] := {Protected}", 
            "title": "Real"
        }, 
        {
            "location": "/builtin/constants/real/#simple-examples", 
            "text": "In [ 1 ] :=   Head [ 1.53 ]  Out [ 1 ] =   Real   One can force Real interperetation on an Integer by appending a decimal point:  In [ 2 ] :=   Head [ 1. ]  Out [ 2 ] =   Real   Real numbers are backed by arbitrary-precision floating points:  In [ 3 ] :=   10. ^ 5000   /   10. ^ 4999  Out [ 3 ] =   10.", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/constants/real/#further-examples", 
            "text": "In [ 1 ] :=   MatchQ [ 1.53 ,   _Real ]  Out [ 1 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/constants/integer/", 
            "text": "Integer\n\n\nInteger\n is the head for the atomic integer type.\n\n\nAttributes[Integer] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHead\n[\n153\n]\n\n\nOut\n[\n1\n]\n=\n \nInteger\n\n\n\n\n\n\nInteger numbers are backed by arbitrary-precision data structures:\n\n\nIn\n[\n2\n]\n:=\n \nFactorial\n[\n40\n]\n\n\nOut\n[\n2\n]\n=\n \n815915283247897734345611269596115894272000000000\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\n153\n,\n \n_Integer\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue", 
            "title": "Integer "
        }, 
        {
            "location": "/builtin/constants/integer/#integer", 
            "text": "Integer  is the head for the atomic integer type.  Attributes[Integer] := {Protected}", 
            "title": "Integer"
        }, 
        {
            "location": "/builtin/constants/integer/#simple-examples", 
            "text": "In [ 1 ] :=   Head [ 153 ]  Out [ 1 ] =   Integer   Integer numbers are backed by arbitrary-precision data structures:  In [ 2 ] :=   Factorial [ 40 ]  Out [ 2 ] =   815915283247897734345611269596115894272000000000", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/constants/integer/#further-examples", 
            "text": "In [ 1 ] :=   MatchQ [ 153 ,   _Integer ]  Out [ 1 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/expression/", 
            "text": "expression documentation\n\n\nApply\n\n\nSequence\n\n\nEvaluate\n\n\nFunction\n\n\nSlot\n\n\nHold", 
            "title": "expression"
        }, 
        {
            "location": "/builtin/expression/#expression-documentation", 
            "text": "Apply  Sequence  Evaluate  Function  Slot  Hold", 
            "title": "expression documentation"
        }, 
        {
            "location": "/builtin/expression/apply/", 
            "text": "Apply\n\n\nApply[f, e]\n (\nf@@e\n) replaces the head of expression \ne\n with \nf\n.\n\n\nAttributes[Apply] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nApply\n[\nbar\n,\n \nfoo\n[\nsyma\n,\n \nsymb\n]]\n\n\nOut\n[\n1\n]\n=\n \nbar\n[\nsyma\n,\n \nsymb\n]\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nbar\n@@\nfoo\n[\nsyma\n,\n \nsymb\n]\n\n\nOut\n[\n2\n]\n=\n \nbar\n[\nsyma\n,\n \nsymb\n]\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nList\n@@\n(\nsyma\n \n+\n \nsymb\n)\n\n\nOut\n[\n3\n]\n=\n \n{\nsyma\n,\n \nsymb\n}\n\n\n\n\n\n\nApply\n is useful in performing aggregations on \nList\ns:\n\n\nIn\n[\n4\n]\n:=\n \nTimes\n \n@@\n \n{\n2\n,\n \n6\n}\n\n\nOut\n[\n4\n]\n=\n \n12\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nTimes\n \n@@\n \n{\na\n,\n \nb\n}\n\n\nOut\n[\n5\n]\n=\n \na\n \nb\n\n\n\n\n\n\nFurther examples\n\n\nApply\n has no effect on atoms:\n\n\nIn\n[\n1\n]\n:=\n \nfoo\n \n@@\n \n1\n\n\nOut\n[\n1\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nfoo\n \n@@\n \nbar\n\n\nOut\n[\n2\n]\n=\n \nbar", 
            "title": "Apply "
        }, 
        {
            "location": "/builtin/expression/apply/#apply", 
            "text": "Apply[f, e]  ( f@@e ) replaces the head of expression  e  with  f .  Attributes[Apply] := {Protected}", 
            "title": "Apply"
        }, 
        {
            "location": "/builtin/expression/apply/#simple-examples", 
            "text": "In [ 1 ] :=   Apply [ bar ,   foo [ syma ,   symb ]]  Out [ 1 ] =   bar [ syma ,   symb ]   In [ 2 ] :=   bar @@ foo [ syma ,   symb ]  Out [ 2 ] =   bar [ syma ,   symb ]   In [ 3 ] :=   List @@ ( syma   +   symb )  Out [ 3 ] =   { syma ,   symb }   Apply  is useful in performing aggregations on  List s:  In [ 4 ] :=   Times   @@   { 2 ,   6 }  Out [ 4 ] =   12   In [ 5 ] :=   Times   @@   { a ,   b }  Out [ 5 ] =   a   b", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/expression/apply/#further-examples", 
            "text": "Apply  has no effect on atoms:  In [ 1 ] :=   foo   @@   1  Out [ 1 ] =   1   In [ 2 ] :=   foo   @@   bar  Out [ 2 ] =   bar", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/expression/sequence/", 
            "text": "Sequence\n\n\nSequence[e1, e2, ...]\n holds a list of expressions to be automatically inserted into another function.\n\n\nAttributes[Sequence] := {Protected}\n\n\nSimple examples\n\n\nSequence arguments are automatically inserted into the parent functions:\n\n\nIn\n[\n1\n]\n:=\n \nfoo\n[\na\n,\n \nSequence\n[\n2\n,\n \n3\n]]\n\n\nOut\n[\n1\n]\n=\n \nfoo\n[\na\n,\n \n2\n,\n \n3\n]\n\n\n\n\n\n\nOutside of the context of functions, Sequence objects do not merge:\n\n\nIn\n[\n2\n]\n:=\n \nSequence\n[\n2\n,\n \n3\n]\n\n\nOut\n[\n2\n]\n=\n \nSequence\n[\n2\n,\n \n3\n]\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nSequence\n[\n2\n,\n \n3\n]\n \n+\n \nSequence\n[\n5\n,\n \n4\n]\n\n\nOut\n[\n3\n]\n=\n \n14\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nSequence\n[\n2\n,\n \n3\n]\n*\nSequence\n[\n5\n,\n \n4\n]\n\n\nOut\n[\n4\n]\n=\n \n120\n\n\n\n\n\n\nFurther examples\n\n\nEmpty \nSequence[]\n objects effectively disappear:\n\n\nIn\n[\n1\n]\n:=\n \nfoo\n[\nSequence\n[]]\n\n\nOut\n[\n1\n]\n=\n \nfoo\n[]", 
            "title": "Sequence "
        }, 
        {
            "location": "/builtin/expression/sequence/#sequence", 
            "text": "Sequence[e1, e2, ...]  holds a list of expressions to be automatically inserted into another function.  Attributes[Sequence] := {Protected}", 
            "title": "Sequence"
        }, 
        {
            "location": "/builtin/expression/sequence/#simple-examples", 
            "text": "Sequence arguments are automatically inserted into the parent functions:  In [ 1 ] :=   foo [ a ,   Sequence [ 2 ,   3 ]]  Out [ 1 ] =   foo [ a ,   2 ,   3 ]   Outside of the context of functions, Sequence objects do not merge:  In [ 2 ] :=   Sequence [ 2 ,   3 ]  Out [ 2 ] =   Sequence [ 2 ,   3 ]   In [ 3 ] :=   Sequence [ 2 ,   3 ]   +   Sequence [ 5 ,   4 ]  Out [ 3 ] =   14   In [ 4 ] :=   Sequence [ 2 ,   3 ] * Sequence [ 5 ,   4 ]  Out [ 4 ] =   120", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/expression/sequence/#further-examples", 
            "text": "Empty  Sequence[]  objects effectively disappear:  In [ 1 ] :=   foo [ Sequence []]  Out [ 1 ] =   foo []", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/expression/evaluate/", 
            "text": "Evaluate\n\n\nEvaluate[expr]\n evaluates to an evaluated form of \nexpr\n, even when under hold conditions.\n\n\nAttributes[Evaluate] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHold\n[\nEvaluate\n[\n1\n \n+\n \n3\n],\n \n2\n \n+\n \n1\n]\n\n\nOut\n[\n1\n]\n=\n \nHold\n[\n4\n,\n \n(\n2\n \n+\n \n1\n)]\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nHold\n[\nfoo\n[\nEvaluate\n[\n1\n \n+\n \n1\n]]]\n\n\nOut\n[\n2\n]\n=\n \nHold\n[\nfoo\n[\nEvaluate\n[(\n1\n \n+\n \n1\n)]]]\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nHold\n[\nEvaluate\n[\n1\n \n+\n \n3\n,\n \n5\n \n+\n \n2\n],\n \n2\n \n+\n \n1\n]\n\n\nOut\n[\n3\n]\n=\n \nHold\n[\n4\n,\n \n7\n,\n \n(\n2\n \n+\n \n1\n)]\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nHold\n[\nSequence\n[\n1\n \n+\n \n3\n,\n \n5\n \n+\n \n2\n],\n \n2\n \n+\n \n1\n]\n\n\nOut\n[\n4\n]\n=\n \nHold\n[(\n1\n \n+\n \n3\n),\n \n(\n5\n \n+\n \n2\n),\n \n(\n2\n \n+\n \n1\n)]", 
            "title": "Evaluate "
        }, 
        {
            "location": "/builtin/expression/evaluate/#evaluate", 
            "text": "Evaluate[expr]  evaluates to an evaluated form of  expr , even when under hold conditions.  Attributes[Evaluate] := {Protected}", 
            "title": "Evaluate"
        }, 
        {
            "location": "/builtin/expression/evaluate/#simple-examples", 
            "text": "In [ 1 ] :=   Hold [ Evaluate [ 1   +   3 ],   2   +   1 ]  Out [ 1 ] =   Hold [ 4 ,   ( 2   +   1 )]   In [ 2 ] :=   Hold [ foo [ Evaluate [ 1   +   1 ]]]  Out [ 2 ] =   Hold [ foo [ Evaluate [( 1   +   1 )]]]   In [ 3 ] :=   Hold [ Evaluate [ 1   +   3 ,   5   +   2 ],   2   +   1 ]  Out [ 3 ] =   Hold [ 4 ,   7 ,   ( 2   +   1 )]   In [ 4 ] :=   Hold [ Sequence [ 1   +   3 ,   5   +   2 ],   2   +   1 ]  Out [ 4 ] =   Hold [( 1   +   3 ),   ( 5   +   2 ),   ( 2   +   1 )]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/expression/function/", 
            "text": "Function\n\n\nFunction[inner]\n defines a pure function where \ninner\n is evaluated with \nSlot\n parameters.\n\n\nFunction[x, inner]\n defines a pure function where \ninner\n is evaluated a single parameter \nx\n.\n\n\nAttributes[Function] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nFunction\n[\n1\n \n+\n \n#\n][\nx\n]\n\n\nOut\n[\n1\n]\n=\n \n1\n \n+\n \nx\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nFunction\n[\n1\n \n+\n \n#\n \n+\n \n2\n#2\n][\nx\n,\n \ny\n]\n\n\nOut\n[\n2\n]\n=\n \n1\n \n+\n \nx\n \n+\n \n2\ny\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nFunction\n[\nx\n,\n \nx\n^\n2\n][\na\n]\n\n\nOut\n[\n3\n]\n=\n \na\n^\n2\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nFunction\n[\nx\n,\n \nx\n^\n2\n][\na\n,\n \nb\n]\n\n\nOut\n[\n4\n]\n=\n \na\n^\n2\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nFunction\n[\nx\n,\n \nx\n^\n2\n][\nx\n]\n\n\nOut\n[\n5\n]\n=\n \nx\n^\n2\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nFunction\n[\nx\n,\n \nx\n^\n2\n][\n-\n2\n]\n\n\nOut\n[\n6\n]\n=\n \n4", 
            "title": "Function "
        }, 
        {
            "location": "/builtin/expression/function/#function", 
            "text": "Function[inner]  defines a pure function where  inner  is evaluated with  Slot  parameters.  Function[x, inner]  defines a pure function where  inner  is evaluated a single parameter  x .  Attributes[Function] := {HoldAll, Protected}", 
            "title": "Function"
        }, 
        {
            "location": "/builtin/expression/function/#simple-examples", 
            "text": "In [ 1 ] :=   Function [ 1   +   # ][ x ]  Out [ 1 ] =   1   +   x   In [ 2 ] :=   Function [ 1   +   #   +   2 #2 ][ x ,   y ]  Out [ 2 ] =   1   +   x   +   2 y   In [ 3 ] :=   Function [ x ,   x ^ 2 ][ a ]  Out [ 3 ] =   a ^ 2   In [ 4 ] :=   Function [ x ,   x ^ 2 ][ a ,   b ]  Out [ 4 ] =   a ^ 2   In [ 5 ] :=   Function [ x ,   x ^ 2 ][ x ]  Out [ 5 ] =   x ^ 2   In [ 6 ] :=   Function [ x ,   x ^ 2 ][ - 2 ]  Out [ 6 ] =   4", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/expression/slot/", 
            "text": "Slot\n\n\n#\n serves as a pure function's first parameter.\n\n\n#n\n serves as a pure function's \nn\n'th parameter.\n\n\nAttributes[Slot] := {NHoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nFunction\n[\n1\n \n+\n \n#\n][\nx\n]\n\n\nOut\n[\n1\n]\n=\n \n1\n \n+\n \nx\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nFunction\n[\n1\n \n+\n \n#\n \n+\n \n2\n#2\n][\nx\n,\n \ny\n]\n\n\nOut\n[\n2\n]\n=\n \n1\n \n+\n \nx\n \n+\n \n2\ny\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \n#\n \n===\n \nSlot\n[\n1\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \n#2\n \n===\n \nSlot\n[\n2\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue", 
            "title": "Slot "
        }, 
        {
            "location": "/builtin/expression/slot/#slot", 
            "text": "#  serves as a pure function's first parameter.  #n  serves as a pure function's  n 'th parameter.  Attributes[Slot] := {NHoldAll, Protected}", 
            "title": "Slot"
        }, 
        {
            "location": "/builtin/expression/slot/#simple-examples", 
            "text": "In [ 1 ] :=   Function [ 1   +   # ][ x ]  Out [ 1 ] =   1   +   x   In [ 2 ] :=   Function [ 1   +   #   +   2 #2 ][ x ,   y ]  Out [ 2 ] =   1   +   x   +   2 y   In [ 3 ] :=   #   ===   Slot [ 1 ]  Out [ 3 ] =   True   In [ 4 ] :=   #2   ===   Slot [ 2 ]  Out [ 4 ] =   True", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/expression/hold/", 
            "text": "Hold\n\n\nHold[expr]\n prevents automatic evaluation of \nexpr\n.\n\n\nAttributes[Hold] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHold\n[\nPower\n[\n5\n,\n \n3\n]]\n\n\nOut\n[\n1\n]\n=\n \nHold\n[\n5\n^\n3\n]\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nHold\n[\nPower\n[\n5.\n,\n \n3.\n]]\n\n\nOut\n[\n2\n]\n=\n \nHold\n[\n5.\n^\n3.\n]", 
            "title": "Hold "
        }, 
        {
            "location": "/builtin/expression/hold/#hold", 
            "text": "Hold[expr]  prevents automatic evaluation of  expr .  Attributes[Hold] := {HoldAll, Protected}", 
            "title": "Hold"
        }, 
        {
            "location": "/builtin/expression/hold/#simple-examples", 
            "text": "In [ 1 ] :=   Hold [ Power [ 5 ,   3 ]]  Out [ 1 ] =   Hold [ 5 ^ 3 ]   In [ 2 ] :=   Hold [ Power [ 5. ,   3. ]]  Out [ 2 ] =   Hold [ 5. ^ 3. ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/flowcontrol/", 
            "text": "flowcontrol documentation\n\n\nIf\n\n\nWhile", 
            "title": "flowcontrol"
        }, 
        {
            "location": "/builtin/flowcontrol/#flowcontrol-documentation", 
            "text": "If  While", 
            "title": "flowcontrol documentation"
        }, 
        {
            "location": "/builtin/flowcontrol/if/", 
            "text": "If\n\n\nIf[cond, iftrue, iffalse]\n returns \niftrue\n if \ncond\n is True, and \niffalse\n if \ncond\n is False.\n\n\nAttributes[If] := {HoldRest, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nx\n=\n9\n\n\nOut\n[\n1\n]\n=\n \n9\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nIf\n[\nx\n+\n3\n==\n12\n,\n \nx\n*\n2\n,\n \nx\n+\n3\n]\n\n\nOut\n[\n2\n]\n=\n \n18\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nIf\n[\nx\n+\n3\n==\n11\n,\n \nx\n*\n2\n,\n \nx\n+\n3\n]\n\n\nOut\n[\n3\n]\n=\n \n12\n\n\n\n\n\n\nFurther examples\n\n\nUndefined conditions leave the statement unevaluated.\n\n\nIn\n[\n1\n]\n:=\n \nIf\n[\nundefined\n,\n \na\n,\n \nb\n]\n\n\nOut\n[\n1\n]\n=\n \nIf\n[\nundefined\n,\n \na\n,\n \nb\n]", 
            "title": "If "
        }, 
        {
            "location": "/builtin/flowcontrol/if/#if", 
            "text": "If[cond, iftrue, iffalse]  returns  iftrue  if  cond  is True, and  iffalse  if  cond  is False.  Attributes[If] := {HoldRest, Protected}", 
            "title": "If"
        }, 
        {
            "location": "/builtin/flowcontrol/if/#simple-examples", 
            "text": "In [ 1 ] :=   x = 9  Out [ 1 ] =   9   In [ 2 ] :=   If [ x + 3 == 12 ,   x * 2 ,   x + 3 ]  Out [ 2 ] =   18   In [ 3 ] :=   If [ x + 3 == 11 ,   x * 2 ,   x + 3 ]  Out [ 3 ] =   12", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/flowcontrol/if/#further-examples", 
            "text": "Undefined conditions leave the statement unevaluated.  In [ 1 ] :=   If [ undefined ,   a ,   b ]  Out [ 1 ] =   If [ undefined ,   a ,   b ]", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/flowcontrol/while/", 
            "text": "While\n\n\nWhile[cond, body]\n evaluates \ncond\n, and if it returns True, evaluates \nbody\n. This happens repeatedly.\n\n\nAttributes[While] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \na\n=\n1\n\n\nOut\n[\n1\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nWhile\n[\na\n \n!=\n \n5\n,\n \na\n \n=\n \na\n \n+\n \n1\n]\n\n\nOut\n[\n2\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \na\n\n\nOut\n[\n3\n]\n=\n \n5", 
            "title": "While "
        }, 
        {
            "location": "/builtin/flowcontrol/while/#while", 
            "text": "While[cond, body]  evaluates  cond , and if it returns True, evaluates  body . This happens repeatedly.  Attributes[While] := {HoldAll, Protected}", 
            "title": "While"
        }, 
        {
            "location": "/builtin/flowcontrol/while/#simple-examples", 
            "text": "In [ 1 ] :=   a = 1  Out [ 1 ] =   1   In [ 2 ] :=   While [ a   !=   5 ,   a   =   a   +   1 ]  Out [ 2 ] =   Null   In [ 3 ] :=   a  Out [ 3 ] =   5", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/", 
            "text": "list documentation\n\n\nList\n\n\nTotal\n\n\nMean\n\n\nDepth\n\n\nLength\n\n\nTable\n\n\nSum\n\n\nProduct\n\n\nMemberQ\n\n\nMap\n\n\nArray\n\n\nCases\n\n\nPadRight\n\n\nPadLeft\n\n\nRange", 
            "title": "list"
        }, 
        {
            "location": "/builtin/list/#list-documentation", 
            "text": "List  Total  Mean  Depth  Length  Table  Sum  Product  MemberQ  Map  Array  Cases  PadRight  PadLeft  Range", 
            "title": "list documentation"
        }, 
        {
            "location": "/builtin/list/list/", 
            "text": "List\n\n\n{e1, e2, ...}\n groups expressions together.\n\n\nAttributes[List] := {Locked, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nList\n[\n1\n,\n2\n,\na\n]\n\n\nOut\n[\n1\n]\n=\n \n{\n1\n,\n \n2\n,\n \na\n}", 
            "title": "List "
        }, 
        {
            "location": "/builtin/list/list/#list", 
            "text": "{e1, e2, ...}  groups expressions together.  Attributes[List] := {Locked, Protected}", 
            "title": "List"
        }, 
        {
            "location": "/builtin/list/list/#simple-examples", 
            "text": "In [ 1 ] :=   List [ 1 , 2 , a ]  Out [ 1 ] =   { 1 ,   2 ,   a }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/total/", 
            "text": "Total\n\n\nTotal[list]\n sums all the values in \nlist\n.\n\n\nAttributes[Total] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nTotal\n[{\n1\n,\n2\n,\n3\n,\n4\n}]\n\n\nOut\n[\n1\n]\n=\n \n10\n\n\n\n\n\n\nFurther examples\n\n\nThe total of an empty list is zero:\n\n\nIn\n[\n1\n]\n:=\n \nTotal\n[{}]\n\n\nOut\n[\n1\n]\n=\n \n0\n\n\n\n\n\n\nRules\n\n\nTotal\n[\nl__List\n]\n \n:=\n \nApply\n[\nPlus\n,\n \nl\n]", 
            "title": "Total "
        }, 
        {
            "location": "/builtin/list/total/#total", 
            "text": "Total[list]  sums all the values in  list .  Attributes[Total] := {Protected}", 
            "title": "Total"
        }, 
        {
            "location": "/builtin/list/total/#simple-examples", 
            "text": "In [ 1 ] :=   Total [{ 1 , 2 , 3 , 4 }]  Out [ 1 ] =   10", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/total/#further-examples", 
            "text": "The total of an empty list is zero:  In [ 1 ] :=   Total [{}]  Out [ 1 ] =   0", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/list/total/#rules", 
            "text": "Total [ l__List ]   :=   Apply [ Plus ,   l ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/list/mean/", 
            "text": "Mean\n\n\nMean[list]\n calculates the statistical mean of \nlist\n.\n\n\nAttributes[Mean] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMean\n[{\n5\n,\n6\n}]\n\n\nOut\n[\n1\n]\n=\n \n11\n/\n2\n\n\n\n\n\n\nRules\n\n\nMean\n[\nl__List\n]\n \n:=\n \nTotal\n[\nl\n]\n/\nLength\n[\nl\n]", 
            "title": "Mean "
        }, 
        {
            "location": "/builtin/list/mean/#mean", 
            "text": "Mean[list]  calculates the statistical mean of  list .  Attributes[Mean] := {Protected}", 
            "title": "Mean"
        }, 
        {
            "location": "/builtin/list/mean/#simple-examples", 
            "text": "In [ 1 ] :=   Mean [{ 5 , 6 }]  Out [ 1 ] =   11 / 2", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/mean/#rules", 
            "text": "Mean [ l__List ]   :=   Total [ l ] / Length [ l ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/list/depth/", 
            "text": "Depth\n\n\nDepth[expr]\n returns the depth of \nexpr\n.\n\n\nAttributes[Depth] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nDepth\n[\nfoo\n]\n\n\nOut\n[\n1\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nDepth\n[{\nfoo\n}]\n\n\nOut\n[\n2\n]\n=\n \n2\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nDepth\n[\nbar\n[\nfoo\n,\n \nbar\n]]\n\n\nOut\n[\n3\n]\n=\n \n2\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nDepth\n[\nfoo\n[\nfoo\n[]]]\n\n\nOut\n[\n4\n]\n=\n \n3\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nDepth\n[\n3\n]\n\n\nOut\n[\n5\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nDepth\n[\n3.5\n]\n\n\nOut\n[\n6\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nDepth\n[\n3\n/\n5\n]\n\n\nOut\n[\n7\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nDepth\n[\nfoo\n[{{{}}}][]]\n\n\nOut\n[\n8\n]\n=\n \n2", 
            "title": "Depth "
        }, 
        {
            "location": "/builtin/list/depth/#depth", 
            "text": "Depth[expr]  returns the depth of  expr .  Attributes[Depth] := {Protected}", 
            "title": "Depth"
        }, 
        {
            "location": "/builtin/list/depth/#simple-examples", 
            "text": "In [ 1 ] :=   Depth [ foo ]  Out [ 1 ] =   1   In [ 2 ] :=   Depth [{ foo }]  Out [ 2 ] =   2   In [ 3 ] :=   Depth [ bar [ foo ,   bar ]]  Out [ 3 ] =   2   In [ 4 ] :=   Depth [ foo [ foo []]]  Out [ 4 ] =   3   In [ 5 ] :=   Depth [ 3 ]  Out [ 5 ] =   1   In [ 6 ] :=   Depth [ 3.5 ]  Out [ 6 ] =   1   In [ 7 ] :=   Depth [ 3 / 5 ]  Out [ 7 ] =   1   In [ 8 ] :=   Depth [ foo [{{{}}}][]]  Out [ 8 ] =   2", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/length/", 
            "text": "Length\n\n\nLength[expr]\n returns the length of \nexpr\n.\n\n\nAttributes[Length] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nLength\n[{\n1\n,\n2\n,\n3\n,\n4\n}]\n\n\nOut\n[\n1\n]\n=\n \n4\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nLength\n[{}]\n\n\nOut\n[\n2\n]\n=\n \n0\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nLength\n[{\n5\n}]\n\n\nOut\n[\n3\n]\n=\n \n1\n\n\n\n\n\n\nFurther examples\n\n\nexpr\n need not have a \nList\n head:\n\n\nIn\n[\n1\n]\n:=\n \nLength\n[\nfoo\n[\n1\n,\n \n2\n]]\n\n\nOut\n[\n1\n]\n=\n \n2", 
            "title": "Length "
        }, 
        {
            "location": "/builtin/list/length/#length", 
            "text": "Length[expr]  returns the length of  expr .  Attributes[Length] := {Protected}", 
            "title": "Length"
        }, 
        {
            "location": "/builtin/list/length/#simple-examples", 
            "text": "In [ 1 ] :=   Length [{ 1 , 2 , 3 , 4 }]  Out [ 1 ] =   4   In [ 2 ] :=   Length [{}]  Out [ 2 ] =   0   In [ 3 ] :=   Length [{ 5 }]  Out [ 3 ] =   1", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/length/#further-examples", 
            "text": "expr  need not have a  List  head:  In [ 1 ] :=   Length [ foo [ 1 ,   2 ]]  Out [ 1 ] =   2", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/list/table/", 
            "text": "Table\n\n\nTable[expr, n]\n returns a list with \nn\n copies of \nexpr\n.\n\n\nTable[expr, {sym, n}]\n returns a list with \nexpr\n evaluated with \nsym\n = 1 to \nn\n.\n\n\nTable[expr, {sym, m, n}]\n returns a list with \nexpr\n evaluated with \nsym\n = \nm\n to \nn\n.\n\n\nAttributes[Table] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nTable\n[\na\n,\n \n5\n]\n\n\nOut\n[\n1\n]\n=\n \n{\na\n,\n \na\n,\n \na\n,\n \na\n,\n \na\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nTable\n[\ni\n,\n \n{\ni\n,\n \n5\n,\n \n10\n}]\n\n\nOut\n[\n2\n]\n=\n \n{\n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n}\n\n\n\n\n\n\nCreate a list of the first 10 squares:\n\n\nIn\n[\n3\n]\n:=\n \nTable\n[\nn\n^\n2\n,\n \n{\nn\n,\n \n1\n,\n \n10\n}]\n\n\nOut\n[\n3\n]\n=\n \n{\n1\n,\n \n4\n,\n \n9\n,\n \n16\n,\n \n25\n,\n \n36\n,\n \n49\n,\n \n64\n,\n \n81\n,\n \n100\n}\n\n\n\n\n\n\nIteration definitions do not have side effects:\n\n\nIn\n[\n4\n]\n:=\n \ni\n\n\nOut\n[\n4\n]\n=\n \ni\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \ni\n \n=\n \n22\n\n\nOut\n[\n5\n]\n=\n \n22\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nTable\n[\ni\n,\n \n{\ni\n,\n \n5\n,\n \n10\n}]\n\n\nOut\n[\n6\n]\n=\n \n{\n5\n,\n \n6\n,\n \n7\n,\n \n8\n,\n \n9\n,\n \n10\n}\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \ni\n\n\nOut\n[\n7\n]\n=\n \n22\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nTable\n[\nx\n[\n99\n],\n \n{\nx\n[\n_\n],\n \n0\n,\n \n2\n}]\n\n\nOut\n[\n1\n]\n=\n \n{\n0\n,\n1\n,\n2\n}\n\n\n\n\n\n\nRules\n\n\nTable\n[\na_\n,\n \nb_Integer\n]\n \n:=\n \nTable\n[\na\n,\n \n{\nUniqueDefined`i\n,\n \n1\n,\n \nb\n}]", 
            "title": "Table "
        }, 
        {
            "location": "/builtin/list/table/#table", 
            "text": "Table[expr, n]  returns a list with  n  copies of  expr .  Table[expr, {sym, n}]  returns a list with  expr  evaluated with  sym  = 1 to  n .  Table[expr, {sym, m, n}]  returns a list with  expr  evaluated with  sym  =  m  to  n .  Attributes[Table] := {HoldAll, Protected}", 
            "title": "Table"
        }, 
        {
            "location": "/builtin/list/table/#simple-examples", 
            "text": "In [ 1 ] :=   Table [ a ,   5 ]  Out [ 1 ] =   { a ,   a ,   a ,   a ,   a }   In [ 2 ] :=   Table [ i ,   { i ,   5 ,   10 }]  Out [ 2 ] =   { 5 ,   6 ,   7 ,   8 ,   9 ,   10 }   Create a list of the first 10 squares:  In [ 3 ] :=   Table [ n ^ 2 ,   { n ,   1 ,   10 }]  Out [ 3 ] =   { 1 ,   4 ,   9 ,   16 ,   25 ,   36 ,   49 ,   64 ,   81 ,   100 }   Iteration definitions do not have side effects:  In [ 4 ] :=   i  Out [ 4 ] =   i   In [ 5 ] :=   i   =   22  Out [ 5 ] =   22   In [ 6 ] :=   Table [ i ,   { i ,   5 ,   10 }]  Out [ 6 ] =   { 5 ,   6 ,   7 ,   8 ,   9 ,   10 }   In [ 7 ] :=   i  Out [ 7 ] =   22", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/table/#further-examples", 
            "text": "In [ 1 ] :=   Table [ x [ 99 ],   { x [ _ ],   0 ,   2 }]  Out [ 1 ] =   { 0 , 1 , 2 }", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/list/table/#rules", 
            "text": "Table [ a_ ,   b_Integer ]   :=   Table [ a ,   { UniqueDefined`i ,   1 ,   b }]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/list/sum/", 
            "text": "Sum\n\n\nSum[expr, n]\n returns the sum of \nn\n copies of \nexpr\n.\n\n\nSum[expr, {sym, n}]\n returns the sum of \nexpr\n evaluated with \nsym\n = 1 to \nn\n.\n\n\nSum[expr, {sym, m, n}]\n returns the sum of \nexpr\n evaluated with \nsym\n = \nm\n to \nn\n.\n\n\nAttributes[Sum] := {HoldAll, Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n5\n,\n \n10\n}]\n\n\nOut\n[\n1\n]\n=\n \n45\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n1\n,\n \n10\n}]\n\n\nOut\n[\n2\n]\n=\n \n55\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n0\n,\n \n10\n}]\n\n\nOut\n[\n3\n]\n=\n \n55\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n1\n,\n \n30000\n}]\n\n\nOut\n[\n4\n]\n=\n \n450015000\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n0\n,\n \n30000\n}]\n\n\nOut\n[\n5\n]\n=\n \n450015000\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n0\n,\n \nn\n}]\n\n\nOut\n[\n6\n]\n=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nSum\n[\ni\n,\n \n{\ni\n,\n \n1\n,\n \nn\n}]\n\n\nOut\n[\n7\n]\n=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nSum\n[\na\n \n+\n \nb\n,\n \n{\na\n,\n \n0\n,\n \n2\n},\n \n{\nb\n,\n \n0\n,\n \n3\n}]\n\n\nOut\n[\n8\n]\n=\n \n30\n\n\n\n\n\n\nRules\n\n\nSum\n[\ni_Symbol\n,\n \n{\ni_Symbol\n,\n \n0\n,\n \nn_Integer\n}]\n \n:=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\nSum\n[\ni_Symbol\n,\n \n{\ni_Symbol\n,\n \n1\n,\n \nn_Integer\n}]\n \n:=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\nSum\n[\ni_Symbol\n,\n \n{\ni_Symbol\n,\n \nn_Integer\n}]\n \n:=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\nSum\n[\ni_Symbol\n,\n \n{\ni_Symbol\n,\n \n0\n,\n \nn_Symbol\n}]\n \n:=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)\n\n\nSum\n[\ni_Symbol\n,\n \n{\ni_Symbol\n,\n \n1\n,\n \nn_Symbol\n}]\n \n:=\n \n1\n/\n2\n*\nn\n*\n(\n1\n \n+\n \nn\n)", 
            "title": "Sum "
        }, 
        {
            "location": "/builtin/list/sum/#sum", 
            "text": "Sum[expr, n]  returns the sum of  n  copies of  expr .  Sum[expr, {sym, n}]  returns the sum of  expr  evaluated with  sym  = 1 to  n .  Sum[expr, {sym, m, n}]  returns the sum of  expr  evaluated with  sym  =  m  to  n .  Attributes[Sum] := {HoldAll, Protected, ReadProtected}", 
            "title": "Sum"
        }, 
        {
            "location": "/builtin/list/sum/#simple-examples", 
            "text": "In [ 1 ] :=   Sum [ i ,   { i ,   5 ,   10 }]  Out [ 1 ] =   45   In [ 2 ] :=   Sum [ i ,   { i ,   1 ,   10 }]  Out [ 2 ] =   55   In [ 3 ] :=   Sum [ i ,   { i ,   0 ,   10 }]  Out [ 3 ] =   55   In [ 4 ] :=   Sum [ i ,   { i ,   1 ,   30000 }]  Out [ 4 ] =   450015000   In [ 5 ] :=   Sum [ i ,   { i ,   0 ,   30000 }]  Out [ 5 ] =   450015000   In [ 6 ] :=   Sum [ i ,   { i ,   0 ,   n }]  Out [ 6 ] =   1 / 2 * n * ( 1   +   n )   In [ 7 ] :=   Sum [ i ,   { i ,   1 ,   n }]  Out [ 7 ] =   1 / 2 * n * ( 1   +   n )   In [ 8 ] :=   Sum [ a   +   b ,   { a ,   0 ,   2 },   { b ,   0 ,   3 }]  Out [ 8 ] =   30", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/sum/#rules", 
            "text": "Sum [ i_Symbol ,   { i_Symbol ,   0 ,   n_Integer }]   :=   1 / 2 * n * ( 1   +   n )  Sum [ i_Symbol ,   { i_Symbol ,   1 ,   n_Integer }]   :=   1 / 2 * n * ( 1   +   n )  Sum [ i_Symbol ,   { i_Symbol ,   n_Integer }]   :=   1 / 2 * n * ( 1   +   n )  Sum [ i_Symbol ,   { i_Symbol ,   0 ,   n_Symbol }]   :=   1 / 2 * n * ( 1   +   n )  Sum [ i_Symbol ,   { i_Symbol ,   1 ,   n_Symbol }]   :=   1 / 2 * n * ( 1   +   n )", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/list/product/", 
            "text": "Product\n\n\nProduct[expr, n]\n returns the product of \nn\n copies of \nexpr\n.\n\n\nProduct[expr, {sym, n}]\n returns the product of \nexpr\n evaluated with \nsym\n = 1 to \nn\n.\n\n\nProduct[expr, {sym, m, n}]\n returns the product of \nexpr\n evaluated with \nsym\n = \nm\n to \nn\n.\n\n\nAttributes[Product] := {HoldAll, Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nProduct\n[\na\n,\n \n{\na\n,\n \n1\n,\n \n5\n}]\n\n\nOut\n[\n1\n]\n=\n \n120\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nProduct\n[\nf\n[\na\n],\n \n{\na\n,\n \n1\n,\n \n5\n}]\n\n\nOut\n[\n2\n]\n=\n \nf\n[\n1\n]\n \n*\n \nf\n[\n2\n]\n \n*\n \nf\n[\n3\n]\n \n*\n \nf\n[\n4\n]\n \n*\n \nf\n[\n5\n]\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nProduct\n[\na\n^\n2\n,\n \n{\na\n,\n \n4\n}]\n\n\nOut\n[\n3\n]\n=\n \n576\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nProduct\n[\na\n \n+\n \nb\n,\n \n{\na\n,\n \n1\n,\n \n2\n},\n \n{\nb\n,\n \n1\n,\n \n3\n}]\n\n\nOut\n[\n4\n]\n=\n \n1440", 
            "title": "Product "
        }, 
        {
            "location": "/builtin/list/product/#product", 
            "text": "Product[expr, n]  returns the product of  n  copies of  expr .  Product[expr, {sym, n}]  returns the product of  expr  evaluated with  sym  = 1 to  n .  Product[expr, {sym, m, n}]  returns the product of  expr  evaluated with  sym  =  m  to  n .  Attributes[Product] := {HoldAll, Protected, ReadProtected}", 
            "title": "Product"
        }, 
        {
            "location": "/builtin/list/product/#simple-examples", 
            "text": "In [ 1 ] :=   Product [ a ,   { a ,   1 ,   5 }]  Out [ 1 ] =   120   In [ 2 ] :=   Product [ f [ a ],   { a ,   1 ,   5 }]  Out [ 2 ] =   f [ 1 ]   *   f [ 2 ]   *   f [ 3 ]   *   f [ 4 ]   *   f [ 5 ]   In [ 3 ] :=   Product [ a ^ 2 ,   { a ,   4 }]  Out [ 3 ] =   576   In [ 4 ] :=   Product [ a   +   b ,   { a ,   1 ,   2 },   { b ,   1 ,   3 }]  Out [ 4 ] =   1440", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/memberq/", 
            "text": "MemberQ\n\n\nMemberQ[expr, pat]\n returns True if any of the elements in \nexpr\n match \npat\n, otherwise returns False.\n\n\nAttributes[MemberQ] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n0\n]\n\n\nOut\n[\n1\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n1\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n{\n1\n}]\n\n\nOut\n[\n3\n]\n=\n \nFalse\n\n\n\n\n\n\nMemberQ\n works with patterns:\n\n\nIn\n[\n4\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n_Integer\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n_\n]\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \n_Real\n]\n\n\nOut\n[\n6\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nMemberQ\n[{\n1\n,\n \n2\n,\n \n3\n},\n \ntestmatch_Integer\n]\n\n\nOut\n[\n7\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \ntestmatch\n\n\nOut\n[\n8\n]\n=\n \ntestmatch\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \nMemberQ\n[\na\n,\n \na\n]\n\n\nOut\n[\n9\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n10\n]\n:=\n \nMemberQ\n[\na\n,\n \n_\n]\n\n\nOut\n[\n10\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n11\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \nc\n]\n\n\nOut\n[\n11\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n12\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \na\n]\n\n\nOut\n[\n12\n]\n=\n \nTrue\n\n\n\n\n\n\nFurther examples\n\n\nMemberQ\n works with BlankSequences:\n\n\nIn\n[\n1\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n___\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n__\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n__Integer\n]\n\n\nOut\n[\n3\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n___Integer\n]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n___Symbol\n]\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n},\n \n__Symbol\n]\n\n\nOut\n[\n6\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n,\n \n1\n},\n \n__Symbol\n]\n\n\nOut\n[\n7\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nMemberQ\n[{\na\n,\n \nb\n,\n \n1\n},\n \n__Integer\n]\n\n\nOut\n[\n8\n]\n=\n \nTrue\n\n\n\n\n\n\nexpr\n need not be a List:\n\n\nIn\n[\n9\n]\n:=\n \nMemberQ\n[\nbar\n[\na\n,\n \nb\n,\n \nc\n],\n \na\n]\n\n\nOut\n[\n9\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n10\n]\n:=\n \nMemberQ\n[\nbar\n[\na\n,\n \nb\n,\n \nc\n],\n \nbar\n]\n\n\nOut\n[\n10\n]\n=\n \nFalse", 
            "title": "MemberQ "
        }, 
        {
            "location": "/builtin/list/memberq/#memberq", 
            "text": "MemberQ[expr, pat]  returns True if any of the elements in  expr  match  pat , otherwise returns False.  Attributes[MemberQ] := {Protected}", 
            "title": "MemberQ"
        }, 
        {
            "location": "/builtin/list/memberq/#simple-examples", 
            "text": "In [ 1 ] :=   MemberQ [{ 1 ,   2 ,   3 },   0 ]  Out [ 1 ] =   False   In [ 2 ] :=   MemberQ [{ 1 ,   2 ,   3 },   1 ]  Out [ 2 ] =   True   In [ 3 ] :=   MemberQ [{ 1 ,   2 ,   3 },   { 1 }]  Out [ 3 ] =   False   MemberQ  works with patterns:  In [ 4 ] :=   MemberQ [{ 1 ,   2 ,   3 },   _Integer ]  Out [ 4 ] =   True   In [ 5 ] :=   MemberQ [{ 1 ,   2 ,   3 },   _ ]  Out [ 5 ] =   True   In [ 6 ] :=   MemberQ [{ 1 ,   2 ,   3 },   _Real ]  Out [ 6 ] =   False   In [ 7 ] :=   MemberQ [{ 1 ,   2 ,   3 },   testmatch_Integer ]  Out [ 7 ] =   True   In [ 8 ] :=   testmatch  Out [ 8 ] =   testmatch   In [ 9 ] :=   MemberQ [ a ,   a ]  Out [ 9 ] =   False   In [ 10 ] :=   MemberQ [ a ,   _ ]  Out [ 10 ] =   False   In [ 11 ] :=   MemberQ [{ a ,   b },   c ]  Out [ 11 ] =   False   In [ 12 ] :=   MemberQ [{ a ,   b },   a ]  Out [ 12 ] =   True", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/memberq/#further-examples", 
            "text": "MemberQ  works with BlankSequences:  In [ 1 ] :=   MemberQ [{ a ,   b },   ___ ]  Out [ 1 ] =   True   In [ 2 ] :=   MemberQ [{ a ,   b },   __ ]  Out [ 2 ] =   True   In [ 3 ] :=   MemberQ [{ a ,   b },   __Integer ]  Out [ 3 ] =   False   In [ 4 ] :=   MemberQ [{ a ,   b },   ___Integer ]  Out [ 4 ] =   False   In [ 5 ] :=   MemberQ [{ a ,   b },   ___Symbol ]  Out [ 5 ] =   True   In [ 6 ] :=   MemberQ [{ a ,   b },   __Symbol ]  Out [ 6 ] =   True   In [ 7 ] :=   MemberQ [{ a ,   b ,   1 },   __Symbol ]  Out [ 7 ] =   True   In [ 8 ] :=   MemberQ [{ a ,   b ,   1 },   __Integer ]  Out [ 8 ] =   True   expr  need not be a List:  In [ 9 ] :=   MemberQ [ bar [ a ,   b ,   c ],   a ]  Out [ 9 ] =   True   In [ 10 ] :=   MemberQ [ bar [ a ,   b ,   c ],   bar ]  Out [ 10 ] =   False", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/list/map/", 
            "text": "Map\n\n\nMap[f, expr]\n returns a new expression with the same head as \nexpr\n, but with \nf\n mapped to each of the arguments.\n\n\nAttributes[Map] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMap\n[\nfoo\n,\n \n{\na\n,\n \nb\n,\n \nc\n}]\n\n\nOut\n[\n1\n]\n=\n \n{\nfoo\n[\na\n],\n \nfoo\n[\nb\n],\n \nfoo\n[\nc\n]}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nfoo\n \n/@\n \n{\na\n,\n \nb\n,\n \nc\n}\n\n\nOut\n[\n2\n]\n=\n \n{\nfoo\n[\na\n],\n \nfoo\n[\nb\n],\n \nfoo\n[\nc\n]}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nTimes\n \n/@\n \n{\n2\n,\n \n4\n,\n \n9\n}\n\n\nOut\n[\n3\n]\n=\n \n{\n2\n,\n \n4\n,\n \n9\n}\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMap\n[\nfoo\n,\n \n{{\na\n,\n \nb\n},\n \nc\n}]\n\n\nOut\n[\n4\n]\n=\n \n{\nfoo\n[{\na\n,\n \nb\n}],\n \nfoo\n[\nc\n]}\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMap\n[\nfoo\n]\n\n\nOut\n[\n5\n]\n=\n \nMap\n[\nfoo\n]\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nMap\n[\nfoo\n,\n \nfoo\n]\n\n\nOut\n[\n6\n]\n=\n \nfoo\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nMap\n[\nfoo\n,\n \nfoo\n,\n \nfoo\n]\n\n\nOut\n[\n7\n]\n=\n \nMap\n[\nfoo\n,\n \nfoo\n,\n \nfoo\n]\n\n\n\n\n\n\nPure functions are useful with \nMap\n:\n\n\nIn\n[\n8\n]\n:=\n \nFunction\n[\nx\n,\n \nx\n^\n2\n]\n \n/@\n \n{\n2\n,\n4\n}\n\n\nOut\n[\n8\n]\n=\n \n{\n4\n,\n16\n}\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \nFunction\n[\n#\n^\n2\n]\n \n/@\n \n{\n2\n,\n4\n}\n\n\nOut\n[\n9\n]\n=\n \n{\n4\n,\n16\n}", 
            "title": "Map "
        }, 
        {
            "location": "/builtin/list/map/#map", 
            "text": "Map[f, expr]  returns a new expression with the same head as  expr , but with  f  mapped to each of the arguments.  Attributes[Map] := {Protected}", 
            "title": "Map"
        }, 
        {
            "location": "/builtin/list/map/#simple-examples", 
            "text": "In [ 1 ] :=   Map [ foo ,   { a ,   b ,   c }]  Out [ 1 ] =   { foo [ a ],   foo [ b ],   foo [ c ]}   In [ 2 ] :=   foo   /@   { a ,   b ,   c }  Out [ 2 ] =   { foo [ a ],   foo [ b ],   foo [ c ]}   In [ 3 ] :=   Times   /@   { 2 ,   4 ,   9 }  Out [ 3 ] =   { 2 ,   4 ,   9 }   In [ 4 ] :=   Map [ foo ,   {{ a ,   b },   c }]  Out [ 4 ] =   { foo [{ a ,   b }],   foo [ c ]}   In [ 5 ] :=   Map [ foo ]  Out [ 5 ] =   Map [ foo ]   In [ 6 ] :=   Map [ foo ,   foo ]  Out [ 6 ] =   foo   In [ 7 ] :=   Map [ foo ,   foo ,   foo ]  Out [ 7 ] =   Map [ foo ,   foo ,   foo ]   Pure functions are useful with  Map :  In [ 8 ] :=   Function [ x ,   x ^ 2 ]   /@   { 2 , 4 }  Out [ 8 ] =   { 4 , 16 }   In [ 9 ] :=   Function [ # ^ 2 ]   /@   { 2 , 4 }  Out [ 9 ] =   { 4 , 16 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/array/", 
            "text": "Array\n\n\nArray[f, n]\n creates a list of \nf[i]\n, with \ni\n = 1 to \nn\n.\n\n\nAttributes[Array] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nArray\n[\nf\n,\n \n3\n]\n\n\nOut\n[\n1\n]\n=\n \n{\nf\n[\n1\n],\n \nf\n[\n2\n],\n \nf\n[\n3\n]}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nmytest\n[\nx_\n]\n \n:=\n \n5\n\n\nOut\n[\n2\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nArray\n[\nmytest\n,\n \n3\n]\n\n\nOut\n[\n3\n]\n=\n \n{\n5\n,\n \n5\n,\n \n5\n}\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nArray\n[\na\n \n+\n \nb\n,\n \n3\n]\n\n\nOut\n[\n4\n]\n=\n \n{(\na\n \n+\n \nb\n)[\n1\n],\n \n(\na\n \n+\n \nb\n)[\n2\n],\n \n(\na\n \n+\n \nb\n)[\n3\n]}\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nArray\n[\na\n,\n \na\n]\n\n\nOut\n[\n5\n]\n=\n \nArray\n[\na\n,\n \na\n]", 
            "title": "Array "
        }, 
        {
            "location": "/builtin/list/array/#array", 
            "text": "Array[f, n]  creates a list of  f[i] , with  i  = 1 to  n .  Attributes[Array] := {Protected}", 
            "title": "Array"
        }, 
        {
            "location": "/builtin/list/array/#simple-examples", 
            "text": "In [ 1 ] :=   Array [ f ,   3 ]  Out [ 1 ] =   { f [ 1 ],   f [ 2 ],   f [ 3 ]}   In [ 2 ] :=   mytest [ x_ ]   :=   5  Out [ 2 ] =   Null   In [ 3 ] :=   Array [ mytest ,   3 ]  Out [ 3 ] =   { 5 ,   5 ,   5 }   In [ 4 ] :=   Array [ a   +   b ,   3 ]  Out [ 4 ] =   {( a   +   b )[ 1 ],   ( a   +   b )[ 2 ],   ( a   +   b )[ 3 ]}   In [ 5 ] :=   Array [ a ,   a ]  Out [ 5 ] =   Array [ a ,   a ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/cases/", 
            "text": "Cases\n\n\nCases[expr, pat]\n returns a new \nList\n of all elements in \nexpr\n that match \npat\n.\n\n\nAttributes[Cases] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \n3.5\n,\n \nx\n,\n \ny\n,\n \n4\n},\n \n_\n]\n\n\nOut\n[\n1\n]\n=\n \n{\n5\n,\n \n2\n,\n \n3.5\n,\n \nx\n,\n \ny\n,\n \n4\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \n3.5\n,\n \nx\n,\n \ny\n,\n \n4\n},\n \n_Integer\n]\n\n\nOut\n[\n2\n]\n=\n \n{\n5\n,\n2\n,\n4\n}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \n3.5\n,\n \nx\n,\n \ny\n,\n \n4\n},\n \n_Real\n]\n\n\nOut\n[\n3\n]\n=\n \n{\n3.5\n}\n\n\n\n\n\n\nFurther examples\n\n\nexpr\n need not be a list:\n\n\nIn\n[\n1\n]\n:=\n \nCases\n[\nbar\n[\na\n,\n \nb\n,\n \nc\n],\n \na\n]\n\n\nOut\n[\n1\n]\n=\n \n{\na\n}", 
            "title": "Cases "
        }, 
        {
            "location": "/builtin/list/cases/#cases", 
            "text": "Cases[expr, pat]  returns a new  List  of all elements in  expr  that match  pat .  Attributes[Cases] := {Protected}", 
            "title": "Cases"
        }, 
        {
            "location": "/builtin/list/cases/#simple-examples", 
            "text": "In [ 1 ] :=   Cases [{ 5 ,   2 ,   3.5 ,   x ,   y ,   4 },   _ ]  Out [ 1 ] =   { 5 ,   2 ,   3.5 ,   x ,   y ,   4 }   In [ 2 ] :=   Cases [{ 5 ,   2 ,   3.5 ,   x ,   y ,   4 },   _Integer ]  Out [ 2 ] =   { 5 , 2 , 4 }   In [ 3 ] :=   Cases [{ 5 ,   2 ,   3.5 ,   x ,   y ,   4 },   _Real ]  Out [ 3 ] =   { 3.5 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/cases/#further-examples", 
            "text": "expr  need not be a list:  In [ 1 ] :=   Cases [ bar [ a ,   b ,   c ],   a ]  Out [ 1 ] =   { a }", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/list/padright/", 
            "text": "PadRight\n\n\nAttributes[PadRight] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nPadRight\n[{\n1\n,\n \n2\n},\n \n5\n]\n\n\nOut\n[\n1\n]\n=\n \n{\n1\n,\n \n2\n,\n \n0\n,\n \n0\n,\n \n0\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nPadRight\n[{\n1\n,\n \n2\n},\n \n5\n,\n \nx\n]\n\n\nOut\n[\n2\n]\n=\n \n{\n1\n,\n \n2\n,\n \nx\n,\n \nx\n,\n \nx\n}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nPadRight\n[{\n1\n,\n \n2\n},\n \n1\n,\n \nx\n]\n\n\nOut\n[\n3\n]\n=\n \n{\n1\n}", 
            "title": "PadRight "
        }, 
        {
            "location": "/builtin/list/padright/#padright", 
            "text": "Attributes[PadRight] := {Protected}", 
            "title": "PadRight"
        }, 
        {
            "location": "/builtin/list/padright/#simple-examples", 
            "text": "In [ 1 ] :=   PadRight [{ 1 ,   2 },   5 ]  Out [ 1 ] =   { 1 ,   2 ,   0 ,   0 ,   0 }   In [ 2 ] :=   PadRight [{ 1 ,   2 },   5 ,   x ]  Out [ 2 ] =   { 1 ,   2 ,   x ,   x ,   x }   In [ 3 ] :=   PadRight [{ 1 ,   2 },   1 ,   x ]  Out [ 3 ] =   { 1 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/padleft/", 
            "text": "PadLeft\n\n\nAttributes[PadLeft] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nPadLeft\n[{\n1\n,\n \n2\n},\n \n5\n]\n\n\nOut\n[\n1\n]\n=\n \n{\n0\n,\n \n0\n,\n \n0\n,\n \n1\n,\n \n2\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nPadLeft\n[{\n1\n,\n \n2\n},\n \n5\n,\n \nx\n]\n\n\nOut\n[\n2\n]\n=\n \n{\nx\n,\n \nx\n,\n \nx\n,\n \n1\n,\n \n2\n}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nPadLeft\n[{\n1\n,\n \n2\n},\n \n1\n,\n \nx\n]\n\n\nOut\n[\n3\n]\n=\n \n{\n2\n}\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nPadLeft\n[\na\n[],\n \n5\n,\n \nx\n]\n\n\nOut\n[\n4\n]\n=\n \na\n[\nx\n,\n \nx\n,\n \nx\n,\n \nx\n,\n \nx\n]", 
            "title": "PadLeft "
        }, 
        {
            "location": "/builtin/list/padleft/#padleft", 
            "text": "Attributes[PadLeft] := {Protected}", 
            "title": "PadLeft"
        }, 
        {
            "location": "/builtin/list/padleft/#simple-examples", 
            "text": "In [ 1 ] :=   PadLeft [{ 1 ,   2 },   5 ]  Out [ 1 ] =   { 0 ,   0 ,   0 ,   1 ,   2 }   In [ 2 ] :=   PadLeft [{ 1 ,   2 },   5 ,   x ]  Out [ 2 ] =   { x ,   x ,   x ,   1 ,   2 }   In [ 3 ] :=   PadLeft [{ 1 ,   2 },   1 ,   x ]  Out [ 3 ] =   { 2 }   In [ 4 ] :=   PadLeft [ a [],   5 ,   x ]  Out [ 4 ] =   a [ x ,   x ,   x ,   x ,   x ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/list/range/", 
            "text": "Range\n\n\nRange[n]\n returns a \nList\n of integers from 1 to \nn\n.\n\n\nRange[m, n]\n returns a \nList\n of integers from \nm\n to \nn\n.\n\n\nAttributes[Range] := {Listable, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nRange\n[\n3\n]\n\n\nOut\n[\n1\n]\n=\n \n{\n1\n,\n \n2\n,\n \n3\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nRange\n[\n2\n,\n \n5\n]\n\n\nOut\n[\n2\n]\n=\n \n{\n2\n,\n \n3\n,\n \n4\n,\n \n5\n}", 
            "title": "Range "
        }, 
        {
            "location": "/builtin/list/range/#range", 
            "text": "Range[n]  returns a  List  of integers from 1 to  n .  Range[m, n]  returns a  List  of integers from  m  to  n .  Attributes[Range] := {Listable, Protected}", 
            "title": "Range"
        }, 
        {
            "location": "/builtin/list/range/#simple-examples", 
            "text": "In [ 1 ] :=   Range [ 3 ]  Out [ 1 ] =   { 1 ,   2 ,   3 }   In [ 2 ] :=   Range [ 2 ,   5 ]  Out [ 2 ] =   { 2 ,   3 ,   4 ,   5 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/order/", 
            "text": "order documentation\n\n\nOrder", 
            "title": "order"
        }, 
        {
            "location": "/builtin/order/#order-documentation", 
            "text": "Order", 
            "title": "order documentation"
        }, 
        {
            "location": "/builtin/order/order/", 
            "text": "Order\n\n\nOrder[e1, e2]\n returns 1 if \ne1\n should come before \ne2\n in canonical ordering, -1 if it should come after, and 0 if the two expressions are equal.\n\n\nAttributes[Order] := {Protected}\n\n\nSimple examples\n\n\nFind the relative order of symbols:\n\n\nIn\n[\n1\n]\n:=\n \nOrder\n[\na\n,\n \nb\n]\n\n\nOut\n[\n1\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nOrder\n[\nb\n,\n \na\n]\n\n\nOut\n[\n2\n]\n=\n \n-\n1\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nOrder\n[\na\n,\n \naa\n]\n\n\nOut\n[\n3\n]\n=\n \n1\n\n\n\n\n\n\nFind the relative order of numbers:\n\n\nIn\n[\n4\n]\n:=\n \nOrder\n[\n2\n,\n \n1.\n]\n\n\nOut\n[\n4\n]\n=\n \n-\n1\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nOrder\n[\n1\n,\n \n2\n]\n\n\nOut\n[\n5\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nOrder\n[\n1\n,\n \n1\n]\n\n\nOut\n[\n6\n]\n=\n \n0\n\n\n\n\n\n\nFind the relative order of strings:\n\n\nIn\n[\n7\n]\n:=\n \nOrder\n[\na\n,\n \nb\n]\n\n\nOut\n[\n7\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nOrder\n[\nb\n,\n \na\n]\n\n\nOut\n[\n8\n]\n=\n \n-\n1\n\n\n\n\n\n\nFind the relative order of heterogenous types:\n\n\nIn\n[\n9\n]\n:=\n \nOrder\n[\nab\n,\n \n1\n]\n\n\nOut\n[\n9\n]\n=\n \n-\n1\n\n\n\n\n\n\nIn\n[\n10\n]\n:=\n \nOrder\n[\n1\n,\n \nab\n]\n\n\nOut\n[\n10\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n11\n]\n:=\n \nOrder\n[\ny\n[\na\n],\n \nx\n]\n\n\nOut\n[\n11\n]\n=\n \n-\n1\n\n\n\n\n\n\nFind the relative order of rationals:\n\n\nIn\n[\n12\n]\n:=\n \nOrder\n[\nRational\n[\n-\n5\n,\n \n3\n],\n \nRational\n[\n-\n4\n,\n \n6\n]]\n\n\nOut\n[\n12\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n13\n]\n:=\n \nOrder\n[\nRational\n[\n4\n,\n \n6\n],\n \n.6\n]\n\n\nOut\n[\n13\n]\n=\n \n-\n1\n\n\n\n\n\n\nIn\n[\n14\n]\n:=\n \nOrder\n[\n.6\n,\n \nRational\n[\n4\n,\n \n6\n]]\n\n\nOut\n[\n14\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n15\n]\n:=\n \nOrder\n[\nRational\n[\n4\n,\n \n6\n],\n \n.7\n]\n\n\nOut\n[\n15\n]\n=\n \n1\n\n\n\n\n\n\nFind the relative order of expressions:\n\n\nIn\n[\n16\n]\n:=\n \nOrder\n[\nbar\n[\nx\n,\n \ny\n],\n \nbar\n[\nx\n,\n \ny\n]]\n\n\nOut\n[\n16\n]\n=\n \n0\n\n\n\n\n\n\nIn\n[\n17\n]\n:=\n \nOrder\n[\nfizz\n[\nbar\n[\nx\n,\n \ny\n]],\n \nfizz\n[\nbar\n[\nx\n,\n \ny\n,\n \na\n]]]\n\n\nOut\n[\n17\n]\n=\n \n1", 
            "title": "Order "
        }, 
        {
            "location": "/builtin/order/order/#order", 
            "text": "Order[e1, e2]  returns 1 if  e1  should come before  e2  in canonical ordering, -1 if it should come after, and 0 if the two expressions are equal.  Attributes[Order] := {Protected}", 
            "title": "Order"
        }, 
        {
            "location": "/builtin/order/order/#simple-examples", 
            "text": "Find the relative order of symbols:  In [ 1 ] :=   Order [ a ,   b ]  Out [ 1 ] =   1   In [ 2 ] :=   Order [ b ,   a ]  Out [ 2 ] =   - 1   In [ 3 ] :=   Order [ a ,   aa ]  Out [ 3 ] =   1   Find the relative order of numbers:  In [ 4 ] :=   Order [ 2 ,   1. ]  Out [ 4 ] =   - 1   In [ 5 ] :=   Order [ 1 ,   2 ]  Out [ 5 ] =   1   In [ 6 ] :=   Order [ 1 ,   1 ]  Out [ 6 ] =   0   Find the relative order of strings:  In [ 7 ] :=   Order [ a ,   b ]  Out [ 7 ] =   1   In [ 8 ] :=   Order [ b ,   a ]  Out [ 8 ] =   - 1   Find the relative order of heterogenous types:  In [ 9 ] :=   Order [ ab ,   1 ]  Out [ 9 ] =   - 1   In [ 10 ] :=   Order [ 1 ,   ab ]  Out [ 10 ] =   1   In [ 11 ] :=   Order [ y [ a ],   x ]  Out [ 11 ] =   - 1   Find the relative order of rationals:  In [ 12 ] :=   Order [ Rational [ - 5 ,   3 ],   Rational [ - 4 ,   6 ]]  Out [ 12 ] =   1   In [ 13 ] :=   Order [ Rational [ 4 ,   6 ],   .6 ]  Out [ 13 ] =   - 1   In [ 14 ] :=   Order [ .6 ,   Rational [ 4 ,   6 ]]  Out [ 14 ] =   1   In [ 15 ] :=   Order [ Rational [ 4 ,   6 ],   .7 ]  Out [ 15 ] =   1   Find the relative order of expressions:  In [ 16 ] :=   Order [ bar [ x ,   y ],   bar [ x ,   y ]]  Out [ 16 ] =   0   In [ 17 ] :=   Order [ fizz [ bar [ x ,   y ]],   fizz [ bar [ x ,   y ,   a ]]]  Out [ 17 ] =   1", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/plus/", 
            "text": "plus documentation\n\n\nPlus\n\n\nInfinity\n\n\nComplexInfinity\n\n\nIndeterminate", 
            "title": "plus"
        }, 
        {
            "location": "/builtin/plus/#plus-documentation", 
            "text": "Plus  Infinity  ComplexInfinity  Indeterminate", 
            "title": "plus documentation"
        }, 
        {
            "location": "/builtin/plus/plus/", 
            "text": "Plus\n\n\n(e1 + e2 + ...)\n computes the sum of all expressions in the function.\n\n\nAttributes[Plus] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n1\n \n+\n \n1\n\n\nOut\n[\n1\n]\n=\n \n2\n\n\n\n\n\n\nIf Reals are present, other Integers are demoted to Reals:\n\n\nIn\n[\n2\n]\n:=\n \n(\n5.2\n \n-\n \n.2\n)\n \n-\n \n5\n\n\nOut\n[\n2\n]\n=\n \n0.\n\n\n\n\n\n\nPlus automatically combines like terms:\n\n\nIn\n[\n3\n]\n:=\n \na\n \n+\n \nb\n^\n2\n \n+\n \n5\n*\nb\n^\n2\n\n\nOut\n[\n3\n]\n=\n \na\n+\n6\n*\nb\n^\n2\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \n(\na\n+\nb\n)\n-\n(\na\n+\nb\n)\n+\nc\n-\nc\n+\n2\n*\nc\n^\na\n+\n2\n*\nd\n+\n5\n*\nd\n+\nd\n-\n5\n*\nd\n+\n3\n*\nc\n^\na\n\n\nOut\n[\n4\n]\n=\n \n((\n5\n \n*\n \nc\n^\na\n)\n \n+\n \n(\n3\n \n*\n \nd\n))\n\n\n\n\n\n\nRules\n\n\nPlus\n[\na_\n,\n \n-\na_\n,\n \nrest___\n]\n \n:=\n \nPlus\n[\nrest\n]\n\n\nPlus\n[\nc1_Integer\n*\na_\n,\n \nc2_Integer\n*\na_\n,\n \nrest___\n]\n \n:=\n \n((\nc1\n+\nc2\n)\n*\na\n \n+\n \nrest\n)\n\n\nPlus\n[\nc1_Rational\n*\na_\n,\n \nc2_Rational\n*\na_\n,\n \nrest___\n]\n \n:=\n \n((\nc1\n+\nc2\n)\n*\na\n \n+\n \nrest\n)\n\n\nPlus\n[\nc1_Integer\n*\na_\n,\n \na_\n,\n \nrest___\n]\n \n:=\n \n(\nc1\n+\n1\n)\n*\na\n+\nrest\n\n\nPlus\n[\na_\n,\n \na_\n,\n \nrest___\n]\n \n:=\n \n2\n*\na\n \n+\n \nrest\n\n\nPlus\n[\nc1_Real\n*\na_\n,\n \nc2_Integer\n*\na_\n,\n \nrest___\n]\n \n:=\n \n(\nc1\n+\nc2\n)\n*\na\n \n+\n \nrest\n\n\nPlus\n[\nc_Real\n*\na_\n,\n \na_\n,\n \nrest___\n]\n \n:=\n \n(\nc\n+\n1\n)\n*\na\n \n+\n \nrest", 
            "title": "Plus "
        }, 
        {
            "location": "/builtin/plus/plus/#plus", 
            "text": "(e1 + e2 + ...)  computes the sum of all expressions in the function.  Attributes[Plus] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}", 
            "title": "Plus"
        }, 
        {
            "location": "/builtin/plus/plus/#simple-examples", 
            "text": "In [ 1 ] :=   1   +   1  Out [ 1 ] =   2   If Reals are present, other Integers are demoted to Reals:  In [ 2 ] :=   ( 5.2   -   .2 )   -   5  Out [ 2 ] =   0.   Plus automatically combines like terms:  In [ 3 ] :=   a   +   b ^ 2   +   5 * b ^ 2  Out [ 3 ] =   a + 6 * b ^ 2   In [ 4 ] :=   ( a + b ) - ( a + b ) + c - c + 2 * c ^ a + 2 * d + 5 * d + d - 5 * d + 3 * c ^ a  Out [ 4 ] =   (( 5   *   c ^ a )   +   ( 3   *   d ))", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/plus/plus/#rules", 
            "text": "Plus [ a_ ,   - a_ ,   rest___ ]   :=   Plus [ rest ]  Plus [ c1_Integer * a_ ,   c2_Integer * a_ ,   rest___ ]   :=   (( c1 + c2 ) * a   +   rest )  Plus [ c1_Rational * a_ ,   c2_Rational * a_ ,   rest___ ]   :=   (( c1 + c2 ) * a   +   rest )  Plus [ c1_Integer * a_ ,   a_ ,   rest___ ]   :=   ( c1 + 1 ) * a + rest  Plus [ a_ ,   a_ ,   rest___ ]   :=   2 * a   +   rest  Plus [ c1_Real * a_ ,   c2_Integer * a_ ,   rest___ ]   :=   ( c1 + c2 ) * a   +   rest  Plus [ c_Real * a_ ,   a_ ,   rest___ ]   :=   ( c + 1 ) * a   +   rest", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/plus/infinity/", 
            "text": "Infinity\n\n\nInfinity\n represents the mathematical concept of infinity.\n\n\nAttributes[Infinity] := {Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nInfinity\n \n-\n \n1\n\n\nOut\n[\n1\n]\n=\n \nInfinity\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nInfinity\n \n-\n \n990999999\n\n\nOut\n[\n2\n]\n=\n \nInfinity\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nInfinity\n \n-\n \n990999999.\n\n\nOut\n[\n3\n]\n=\n \nInfinity\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nInfinity\n \n-\n \nInfinity\n\n\nOut\n[\n4\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nInfinity\n*-\n1\n\n\nOut\n[\n5\n]\n=\n \n-\nInfinity\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \n-\nInfinity\n \n+\n \n1\n\n\nOut\n[\n6\n]\n=\n \n-\nInfinity\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \n-\nInfinity\n \n+\n \n999\n\n\nOut\n[\n7\n]\n=\n \n-\nInfinity\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \n-\nInfinity\n*-\n1\n\n\nOut\n[\n8\n]\n=\n \nInfinity\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \n1\n/\nInfinity\n\n\nOut\n[\n9\n]\n=\n \n0\n\n\n\n\n\n\nRules\n\n\nPlus\n[\nInfinity\n,\n \n_Integer\n,\n \nrest___\n]\n \n:=\n \nInfinity\n \n+\n \nrest\n\n\nPlus\n[\nInfinity\n,\n \n_Real\n,\n \nrest___\n]\n \n:=\n \nInfinity\n \n+\n \nrest\n\n\nPlus\n[\n-\nInfinity\n,\n \n_Integer\n,\n \nrest___\n]\n \n:=\n \n-\nInfinity\n \n+\n \nrest\n\n\nPlus\n[\n-\nInfinity\n,\n \n_Real\n,\n \nrest___\n]\n \n:=\n \n-\nInfinity\n \n+\n \nrest\n\n\nPlus\n[\nInfinity\n,\n \n-\nInfinity\n,\n \nrest___\n]\n \n:=\n \nIndeterminate\n \n+\n \nrest", 
            "title": "Infinity "
        }, 
        {
            "location": "/builtin/plus/infinity/#infinity", 
            "text": "Infinity  represents the mathematical concept of infinity.  Attributes[Infinity] := {Protected, ReadProtected}", 
            "title": "Infinity"
        }, 
        {
            "location": "/builtin/plus/infinity/#simple-examples", 
            "text": "In [ 1 ] :=   Infinity   -   1  Out [ 1 ] =   Infinity   In [ 2 ] :=   Infinity   -   990999999  Out [ 2 ] =   Infinity   In [ 3 ] :=   Infinity   -   990999999.  Out [ 3 ] =   Infinity   In [ 4 ] :=   Infinity   -   Infinity  Out [ 4 ] =   Indeterminate   In [ 5 ] :=   Infinity *- 1  Out [ 5 ] =   - Infinity   In [ 6 ] :=   - Infinity   +   1  Out [ 6 ] =   - Infinity   In [ 7 ] :=   - Infinity   +   999  Out [ 7 ] =   - Infinity   In [ 8 ] :=   - Infinity *- 1  Out [ 8 ] =   Infinity   In [ 9 ] :=   1 / Infinity  Out [ 9 ] =   0", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/plus/infinity/#rules", 
            "text": "Plus [ Infinity ,   _Integer ,   rest___ ]   :=   Infinity   +   rest  Plus [ Infinity ,   _Real ,   rest___ ]   :=   Infinity   +   rest  Plus [ - Infinity ,   _Integer ,   rest___ ]   :=   - Infinity   +   rest  Plus [ - Infinity ,   _Real ,   rest___ ]   :=   - Infinity   +   rest  Plus [ Infinity ,   - Infinity ,   rest___ ]   :=   Indeterminate   +   rest", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/plus/complexinfinity/", 
            "text": "ComplexInfinity\n\n\nComplexInfinity\n represents an an infinite quantity that extends in an unknown direction in the complex plane.\n\n\nAttributes[ComplexInfinity] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n0\n^\n(\n-\n1\n)\n\n\nOut\n[\n1\n]\n=\n \nComplexInfinity\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \na\n/\n0\n\n\nOut\n[\n2\n]\n=\n \nComplexInfinity\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nComplexInfinity\n \n*\n \nfoo\n[\nx\n]\n\n\nOut\n[\n3\n]\n=\n \nComplexInfinity\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nFactorial\n[\n-\n1\n]\n\n\nOut\n[\n4\n]\n=\n \nComplexInfinity", 
            "title": "ComplexInfinity "
        }, 
        {
            "location": "/builtin/plus/complexinfinity/#complexinfinity", 
            "text": "ComplexInfinity  represents an an infinite quantity that extends in an unknown direction in the complex plane.  Attributes[ComplexInfinity] := {Protected}", 
            "title": "ComplexInfinity"
        }, 
        {
            "location": "/builtin/plus/complexinfinity/#simple-examples", 
            "text": "In [ 1 ] :=   0 ^ ( - 1 )  Out [ 1 ] =   ComplexInfinity   In [ 2 ] :=   a / 0  Out [ 2 ] =   ComplexInfinity   In [ 3 ] :=   ComplexInfinity   *   foo [ x ]  Out [ 3 ] =   ComplexInfinity   In [ 4 ] :=   Factorial [ - 1 ]  Out [ 4 ] =   ComplexInfinity", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/plus/indeterminate/", 
            "text": "Indeterminate\n\n\nIndeterminate\n represents an indeterminate form.\n\n\nAttributes[Indeterminate] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n0\n/\n0\n\n\nOut\n[\n1\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nInfinity\n \n-\n \nInfinity\n\n\nOut\n[\n2\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \n0\n \n*\n \nInfinity\n\n\nOut\n[\n3\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \n0\n \n*\n \nComplexInfinity\n\n\nOut\n[\n4\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \n0\n^\n0\n\n\nOut\n[\n5\n]\n=\n \nIndeterminate", 
            "title": "Indeterminate "
        }, 
        {
            "location": "/builtin/plus/indeterminate/#indeterminate", 
            "text": "Indeterminate  represents an indeterminate form.  Attributes[Indeterminate] := {Protected}", 
            "title": "Indeterminate"
        }, 
        {
            "location": "/builtin/plus/indeterminate/#simple-examples", 
            "text": "In [ 1 ] :=   0 / 0  Out [ 1 ] =   Indeterminate   In [ 2 ] :=   Infinity   -   Infinity  Out [ 2 ] =   Indeterminate   In [ 3 ] :=   0   *   Infinity  Out [ 3 ] =   Indeterminate   In [ 4 ] :=   0   *   ComplexInfinity  Out [ 4 ] =   Indeterminate   In [ 5 ] :=   0 ^ 0  Out [ 5 ] =   Indeterminate", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/power/", 
            "text": "power documentation\n\n\nPower", 
            "title": "power"
        }, 
        {
            "location": "/builtin/power/#power-documentation", 
            "text": "Power", 
            "title": "power documentation"
        }, 
        {
            "location": "/builtin/power/power/", 
            "text": "Power\n\n\nAttributes[Power] := {Listable, NumericFunction, OneIdentity, Protected}\n\n\nSimple examples\n\n\nExponents of integers are computed exactly:\n\n\nIn\n[\n1\n]\n:=\n \n(\n-\n5\n)\n^-\n3\n\n\nOut\n[\n1\n]\n=\n \n-\n1\n/\n125\n\n\n\n\n\n\nFloating point exponents are handled with floating point precision:\n\n\nIn\n[\n2\n]\n:=\n \n.5\n^-\n10000.\n\n\nOut\n[\n2\n]\n=\n \n1.99506\ne\n+\n3010\n\n\n\n\n\n\nAutomatically apply some basic simplification rules:\n\n\nIn\n[\n3\n]\n:=\n \n(\nm\n^\n2.\n)\n^\n2\n\n\nOut\n[\n3\n]\n=\n \nm\n^\n4.\n\n\n\n\n\n\nFurther examples\n\n\nExpreduce handles problematic exponents accordingly:\n\n\nIn\n[\n1\n]\n:=\n \n0\n^\n0\n\n\nOut\n[\n1\n]\n=\n \nIndeterminate\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \n0\n^\n(\n-\n1\n)\n\n\nOut\n[\n2\n]\n=\n \nComplexInfinity\n\n\n\n\n\n\nRules\n\n\nPower\n[\nPower\n[\na_\n,\nb_Integer\n],\nc_Integer\n]\n \n:=\n \na\n^\n(\nb\n*\nc\n)\n\n\nPower\n[\nPower\n[\na_\n,\nb_Real\n],\nc_Integer\n]\n \n:=\n \na\n^\n(\nb\n*\nc\n)\n\n\nPower\n[\nTimes\n[\nExcept\n[\n_Symbol\n,\n \nfirst_\n],\n \ninner___\n],\n \npow_\n]\n \n:=\n \nfirst\n^\npow\n*\nPower\n[\nTimes\n[\ninner\n],\npow\n]\n\n\nPower\n[\nTimes\n[\nfirst_\n,\n \ninner___\n],\n \nExcept\n[\n_Symbol\n,\n \npow_\n]]\n \n:=\n \nfirst\n^\npow\n*\nPower\n[\nTimes\n[\ninner\n],\npow\n]\n\n\nPower\n[\nRational\n[\na_\n,\nb_\n],\n \n-\n1\n]\n \n:=\n \nRational\n[\nb\n,\na\n]", 
            "title": "Power "
        }, 
        {
            "location": "/builtin/power/power/#power", 
            "text": "Attributes[Power] := {Listable, NumericFunction, OneIdentity, Protected}", 
            "title": "Power"
        }, 
        {
            "location": "/builtin/power/power/#simple-examples", 
            "text": "Exponents of integers are computed exactly:  In [ 1 ] :=   ( - 5 ) ^- 3  Out [ 1 ] =   - 1 / 125   Floating point exponents are handled with floating point precision:  In [ 2 ] :=   .5 ^- 10000.  Out [ 2 ] =   1.99506 e + 3010   Automatically apply some basic simplification rules:  In [ 3 ] :=   ( m ^ 2. ) ^ 2  Out [ 3 ] =   m ^ 4.", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/power/power/#further-examples", 
            "text": "Expreduce handles problematic exponents accordingly:  In [ 1 ] :=   0 ^ 0  Out [ 1 ] =   Indeterminate   In [ 2 ] :=   0 ^ ( - 1 )  Out [ 2 ] =   ComplexInfinity", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/power/power/#rules", 
            "text": "Power [ Power [ a_ , b_Integer ], c_Integer ]   :=   a ^ ( b * c )  Power [ Power [ a_ , b_Real ], c_Integer ]   :=   a ^ ( b * c )  Power [ Times [ Except [ _Symbol ,   first_ ],   inner___ ],   pow_ ]   :=   first ^ pow * Power [ Times [ inner ], pow ]  Power [ Times [ first_ ,   inner___ ],   Except [ _Symbol ,   pow_ ]]   :=   first ^ pow * Power [ Times [ inner ], pow ]  Power [ Rational [ a_ , b_ ],   - 1 ]   :=   Rational [ b , a ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/random/", 
            "text": "random documentation\n\n\nRandomReal\n\n\nSeedRandom", 
            "title": "random"
        }, 
        {
            "location": "/builtin/random/#random-documentation", 
            "text": "RandomReal  SeedRandom", 
            "title": "random documentation"
        }, 
        {
            "location": "/builtin/random/randomreal/", 
            "text": "RandomReal\n\n\nRandomReal[]\n generates a random floating point from 0 to 1.\n\n\nRandomReal[max]\n generates a random floating point from 0 to \nmax\n.\n\n\nRandomReal[min, max]\n generates a random floating point from \nmin\n to `max.\n\n\nAttributes[RandomReal] := {Protected}\n\n\nDetails\n\n\nSeedRandom[UnixTime[]]\n is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n1\n]\n=\n \n0.0750914\n\n\n\n\n\n\nFurther examples\n\n\nUse \nSeedRandom\n to seed the RNG:\n\n\nIn\n[\n1\n]\n:=\n \nSeedRandom\n[\n3\n]\n\n\nOut\n[\n1\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n2\n]\n=\n \n0.719983\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n3\n]\n=\n \n0.652631\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nSeedRandom\n[\n3\n]\n\n\nOut\n[\n4\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n5\n]\n=\n \n0.719983\n\n\n\n\n\n\nRules\n\n\nRandomReal\n[{\nmin_\n,\n \nmax_\n}]\n \n:=\n \nRandomReal\n[]\n*\n(\nmax\n \n-\n \nmin\n)\n \n+\n \nmin\n\n\nRandomReal\n[\nmax_\n]\n \n:=\n \nRandomReal\n[]\n*\nmax", 
            "title": "RandomReal "
        }, 
        {
            "location": "/builtin/random/randomreal/#randomreal", 
            "text": "RandomReal[]  generates a random floating point from 0 to 1.  RandomReal[max]  generates a random floating point from 0 to  max .  RandomReal[min, max]  generates a random floating point from  min  to `max.  Attributes[RandomReal] := {Protected}", 
            "title": "RandomReal"
        }, 
        {
            "location": "/builtin/random/randomreal/#details", 
            "text": "SeedRandom[UnixTime[]]  is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.", 
            "title": "Details"
        }, 
        {
            "location": "/builtin/random/randomreal/#simple-examples", 
            "text": "In [ 1 ] :=   RandomReal []  Out [ 1 ] =   0.0750914", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/random/randomreal/#further-examples", 
            "text": "Use  SeedRandom  to seed the RNG:  In [ 1 ] :=   SeedRandom [ 3 ]  Out [ 1 ] =   Null   In [ 2 ] :=   RandomReal []  Out [ 2 ] =   0.719983   In [ 3 ] :=   RandomReal []  Out [ 3 ] =   0.652631   In [ 4 ] :=   SeedRandom [ 3 ]  Out [ 4 ] =   Null   In [ 5 ] :=   RandomReal []  Out [ 5 ] =   0.719983", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/random/randomreal/#rules", 
            "text": "RandomReal [{ min_ ,   max_ }]   :=   RandomReal [] * ( max   -   min )   +   min  RandomReal [ max_ ]   :=   RandomReal [] * max", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/random/seedrandom/", 
            "text": "SeedRandom\n\n\nSeedRandom[seed]\n seeds the internal random number generator with a given integer \nseed\n.\n\n\nAttributes[SeedRandom] := {Protected}\n\n\nDetails\n\n\nSeedRandom[UnixTime[]]\n is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n1\n]\n=\n \n0.0750914\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nSeedRandom\n[\n3\n]\n\n\nOut\n[\n2\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n3\n]\n=\n \n0.719983\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n4\n]\n=\n \n0.652631\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nSeedRandom\n[\n3\n]\n\n\nOut\n[\n5\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nRandomReal\n[]\n\n\nOut\n[\n6\n]\n=\n \n0.719983", 
            "title": "SeedRandom "
        }, 
        {
            "location": "/builtin/random/seedrandom/#seedrandom", 
            "text": "SeedRandom[seed]  seeds the internal random number generator with a given integer  seed .  Attributes[SeedRandom] := {Protected}", 
            "title": "SeedRandom"
        }, 
        {
            "location": "/builtin/random/seedrandom/#details", 
            "text": "SeedRandom[UnixTime[]]  is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.", 
            "title": "Details"
        }, 
        {
            "location": "/builtin/random/seedrandom/#simple-examples", 
            "text": "In [ 1 ] :=   RandomReal []  Out [ 1 ] =   0.0750914   In [ 2 ] :=   SeedRandom [ 3 ]  Out [ 2 ] =   Null   In [ 3 ] :=   RandomReal []  Out [ 3 ] =   0.719983   In [ 4 ] :=   RandomReal []  Out [ 4 ] =   0.652631   In [ 5 ] :=   SeedRandom [ 3 ]  Out [ 5 ] =   Null   In [ 6 ] :=   RandomReal []  Out [ 6 ] =   0.719983", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/replacement/", 
            "text": "replacement documentation\n\n\nReplaceAll\n\n\nReplaceRepeated\n\n\nRule\n\n\nRuleDelayed", 
            "title": "replacement"
        }, 
        {
            "location": "/builtin/replacement/#replacement-documentation", 
            "text": "ReplaceAll  ReplaceRepeated  Rule  RuleDelayed", 
            "title": "replacement documentation"
        }, 
        {
            "location": "/builtin/replacement/replaceall/", 
            "text": "ReplaceAll\n\n\nexpr /. rule\n replaces all occurences of the LHS of \nrule\n with the RHS of \nrule\n in \nexpr\n.\n\n\nexpr /. {r1, r2, ...}\n performes the same operation as \nexpr /. rule\n, but evaluating each \nr_n\n in sequence.\n\n\nAttributes[ReplaceAll] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n2\n^\n(\nx\n^\n2\n+\n1\n)\n \n+\n \nx\n^\n2\n \n/.\n \nx\n^\n2\n-\ny\n\n\nOut\n[\n1\n]\n=\n \n2\n^\n(\ny\n+\n1\n)\n \n+\n \ny\n\n\n\n\n\n\nIf no match is found, \nReplaceAll\n evaluates to an unchanged \nexpr\n:\n\n\nIn\n[\n2\n]\n:=\n \n2\n^\n(\nx\n^\n2\n+\n1\n)\n \n+\n \nx\n^\n2\n \n/.\n \nz\n^\n2\n-\ny\n\n\nOut\n[\n2\n]\n=\n \n2\n^\n(\nx\n^\n2\n+\n1\n)\n \n+\n \nx\n^\n2\n\n\n\n\n\n\nReplaceAll\n works within Orderless expressions as well (such as \nPlus\n):\n\n\nIn\n[\n3\n]\n:=\n \na\n \n+\n \nb\n \n+\n \nc\n \n+\n \nc\n^\n2\n \n/.\n \nc\n^\n2\n \n+\n \na\n \n-\n \nd\n\n\nOut\n[\n3\n]\n=\n \nb\n \n+\n \nc\n \n+\n \nd\n\n\n\n\n\n\nReplaceAll\n can use named patterns:\n\n\nIn\n[\n4\n]\n:=\n \na\n \n+\n \nb\n \n+\n \nc\n \n+\n \nd\n/.\n \nx_Symbol\n \n+\n \ny_Symbol\n \n-\n \nx\n^\ny\n\n\nOut\n[\n4\n]\n=\n \na\n^\nb\n \n+\n \nc\n \n+\n \nd\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \na\n \n+\n \n2\n*\nb\n \n+\n \n5\n*\nc\n \n/.\n \n(\nc1_Integer\n*\na_Symbol\n)\n \n-\n \n99\n*\na\n\n\nOut\n[\n5\n]\n=\n \na\n \n+\n \n99\n \n*\n \nb\n \n+\n \n99\n \n*\n \nc\n\n\n\n\n\n\nFurther examples\n\n\nReplaceAll\n can be used to replace sequences of expressions:\n\n\nIn\n[\n1\n]\n:=\n \na\n \n+\n \nb\n \n+\n \nc\n \n+\n \nd\n \n/.\n \na\n \n+\n \namatch___\n \n-\n \nfoo\n[\namatch\n]\n\n\nOut\n[\n1\n]\n=\n \nfoo\n[\nb\n,\n \nc\n,\n \nd\n]\n\n\n\n\n\n\nThe \nHead\n of functions can be replaced just as the subexpressions:\n\n\nIn\n[\n2\n]\n:=\n \n(\nx\n \n+\n \n2\n)[\n5\n,\n \n6\n]\n \n/.\n \n(\n2\n \n+\n \nx\n)\n \n-\n \nPlus\n\n\nOut\n[\n2\n]\n=\n \n11\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \na\n*\nb\n*\nc\n*\nd\n \n/.\n \n_Symbol\n \n-\n \n2\n\n\nOut\n[\n3\n]\n=\n \n2\n[\n2\n,\n \n2\n,\n \n2\n,\n \n2\n]", 
            "title": "ReplaceAll "
        }, 
        {
            "location": "/builtin/replacement/replaceall/#replaceall", 
            "text": "expr /. rule  replaces all occurences of the LHS of  rule  with the RHS of  rule  in  expr .  expr /. {r1, r2, ...}  performes the same operation as  expr /. rule , but evaluating each  r_n  in sequence.  Attributes[ReplaceAll] := {Protected}", 
            "title": "ReplaceAll"
        }, 
        {
            "location": "/builtin/replacement/replaceall/#simple-examples", 
            "text": "In [ 1 ] :=   2 ^ ( x ^ 2 + 1 )   +   x ^ 2   /.   x ^ 2 - y  Out [ 1 ] =   2 ^ ( y + 1 )   +   y   If no match is found,  ReplaceAll  evaluates to an unchanged  expr :  In [ 2 ] :=   2 ^ ( x ^ 2 + 1 )   +   x ^ 2   /.   z ^ 2 - y  Out [ 2 ] =   2 ^ ( x ^ 2 + 1 )   +   x ^ 2   ReplaceAll  works within Orderless expressions as well (such as  Plus ):  In [ 3 ] :=   a   +   b   +   c   +   c ^ 2   /.   c ^ 2   +   a   -   d  Out [ 3 ] =   b   +   c   +   d   ReplaceAll  can use named patterns:  In [ 4 ] :=   a   +   b   +   c   +   d /.   x_Symbol   +   y_Symbol   -   x ^ y  Out [ 4 ] =   a ^ b   +   c   +   d   In [ 5 ] :=   a   +   2 * b   +   5 * c   /.   ( c1_Integer * a_Symbol )   -   99 * a  Out [ 5 ] =   a   +   99   *   b   +   99   *   c", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/replacement/replaceall/#further-examples", 
            "text": "ReplaceAll  can be used to replace sequences of expressions:  In [ 1 ] :=   a   +   b   +   c   +   d   /.   a   +   amatch___   -   foo [ amatch ]  Out [ 1 ] =   foo [ b ,   c ,   d ]   The  Head  of functions can be replaced just as the subexpressions:  In [ 2 ] :=   ( x   +   2 )[ 5 ,   6 ]   /.   ( 2   +   x )   -   Plus  Out [ 2 ] =   11   In [ 3 ] :=   a * b * c * d   /.   _Symbol   -   2  Out [ 3 ] =   2 [ 2 ,   2 ,   2 ,   2 ]", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/replacement/replacerepeated/", 
            "text": "ReplaceRepeated\n\n\nexpr //. rule\n replaces all occurences of the LHS of \nrule\n with the RHS of \nrule\n in \nexpr\n repeatedly until the expression stabilizes.\n\n\nexpr //. {r1, r2, ...}\n performes the same operation as \nexpr //. rule\n, but evaluating each \nr_n\n in sequence.\n\n\nAttributes[ReplaceRepeated] := {Protected}\n\n\nSimple examples\n\n\nReplaceRepeated\n can be used to implement logarithm expansion:\n\n\nIn\n[\n1\n]\n:=\n \nlogRules\n \n:=\n \n{\nLog\n[\nx_\n \ny_\n]\n \n:\n \nLog\n[\nx\n]\n \n+\n \nLog\n[\ny\n],\n \nLog\n[\nx_\n^\nk_\n]\n \n:\n \nk\n \nLog\n[\nx\n]}\n\n\nOut\n[\n1\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nLog\n[\na\n^\nb\n*\nb\n^\n(\nc\n^\nd\n)]\n \n//.\n \nlogRules\n\n\nOut\n[\n2\n]\n=\n \nb\n \nLog\n[\na\n]\n \n+\n \n(\nc\n^\nd\n)\n \nLog\n[\nb\n]", 
            "title": "ReplaceRepeated "
        }, 
        {
            "location": "/builtin/replacement/replacerepeated/#replacerepeated", 
            "text": "expr //. rule  replaces all occurences of the LHS of  rule  with the RHS of  rule  in  expr  repeatedly until the expression stabilizes.  expr //. {r1, r2, ...}  performes the same operation as  expr //. rule , but evaluating each  r_n  in sequence.  Attributes[ReplaceRepeated] := {Protected}", 
            "title": "ReplaceRepeated"
        }, 
        {
            "location": "/builtin/replacement/replacerepeated/#simple-examples", 
            "text": "ReplaceRepeated  can be used to implement logarithm expansion:  In [ 1 ] :=   logRules   :=   { Log [ x_   y_ ]   :   Log [ x ]   +   Log [ y ],   Log [ x_ ^ k_ ]   :   k   Log [ x ]}  Out [ 1 ] =   Null   In [ 2 ] :=   Log [ a ^ b * b ^ ( c ^ d )]   //.   logRules  Out [ 2 ] =   b   Log [ a ]   +   ( c ^ d )   Log [ b ]", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/replacement/rule/", 
            "text": "Rule\n\n\nlhs -\n rhs\n can be used in replacement functions to say that instances of \nlhs\n should be replaced with \nrhs\n.\n\n\nAttributes[Rule] := {Protected, SequenceHold}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n2\n^\n(\nx\n^\n2\n+\n1\n)\n \n+\n \nx\n^\n2\n \n/.\n \nx\n^\n2\n \n-\n \ny\n\n\nOut\n[\n1\n]\n=\n \n2\n^\n(\ny\n+\n1\n)\n \n+\n \ny\n\n\n\n\n\n\nTo demonstrate the difference between \nRule\n and \nRuleDelayed\n:\n\n\nIn\n[\n2\n]\n:=\n \nEqual\n \n@@\n \n({\n1\n,\n \n1\n}\n \n/.\n \n1\n \n-\n \nRandomReal\n[])\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nEqual\n \n@@\n \n({\n1\n,\n \n1\n}\n \n/.\n \n1\n \n:\n \nRandomReal\n[])\n\n\nOut\n[\n3\n]\n=\n \nFalse", 
            "title": "Rule "
        }, 
        {
            "location": "/builtin/replacement/rule/#rule", 
            "text": "lhs -  rhs  can be used in replacement functions to say that instances of  lhs  should be replaced with  rhs .  Attributes[Rule] := {Protected, SequenceHold}", 
            "title": "Rule"
        }, 
        {
            "location": "/builtin/replacement/rule/#simple-examples", 
            "text": "In [ 1 ] :=   2 ^ ( x ^ 2 + 1 )   +   x ^ 2   /.   x ^ 2   -   y  Out [ 1 ] =   2 ^ ( y + 1 )   +   y   To demonstrate the difference between  Rule  and  RuleDelayed :  In [ 2 ] :=   Equal   @@   ({ 1 ,   1 }   /.   1   -   RandomReal [])  Out [ 2 ] =   True   In [ 3 ] :=   Equal   @@   ({ 1 ,   1 }   /.   1   :   RandomReal [])  Out [ 3 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/replacement/ruledelayed/", 
            "text": "RuleDelayed\n\n\nlhs :\n rhs\n can be used in replacement functions to say that instances of \nlhs\n should be replaced with \nrhs\n, evaluating \nrhs\n only after replacement.\n\n\nAttributes[RuleDelayed] := {HoldRest, Protected, SequenceHold}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n2\n^\n(\nx\n^\n2\n+\n1\n)\n \n+\n \nx\n^\n2\n \n/.\n \nx\n^\n2\n \n:\n \ny\n\n\nOut\n[\n1\n]\n=\n \n2\n^\n(\ny\n+\n1\n)\n \n+\n \ny\n\n\n\n\n\n\nTo demonstrate the difference between \nRule\n and \nRuleDelayed\n:\n\n\nIn\n[\n2\n]\n:=\n \nEqual\n \n@@\n \n({\n1\n,\n \n1\n}\n \n/.\n \n1\n \n-\n \nRandomReal\n[])\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nEqual\n \n@@\n \n({\n1\n,\n \n1\n}\n \n/.\n \n1\n \n:\n \nRandomReal\n[])\n\n\nOut\n[\n3\n]\n=\n \nFalse", 
            "title": "RuleDelayed "
        }, 
        {
            "location": "/builtin/replacement/ruledelayed/#ruledelayed", 
            "text": "lhs :  rhs  can be used in replacement functions to say that instances of  lhs  should be replaced with  rhs , evaluating  rhs  only after replacement.  Attributes[RuleDelayed] := {HoldRest, Protected, SequenceHold}", 
            "title": "RuleDelayed"
        }, 
        {
            "location": "/builtin/replacement/ruledelayed/#simple-examples", 
            "text": "In [ 1 ] :=   2 ^ ( x ^ 2 + 1 )   +   x ^ 2   /.   x ^ 2   :   y  Out [ 1 ] =   2 ^ ( y + 1 )   +   y   To demonstrate the difference between  Rule  and  RuleDelayed :  In [ 2 ] :=   Equal   @@   ({ 1 ,   1 }   /.   1   -   RandomReal [])  Out [ 2 ] =   True   In [ 3 ] :=   Equal   @@   ({ 1 ,   1 }   /.   1   :   RandomReal [])  Out [ 3 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/sort/", 
            "text": "sort documentation\n\n\nSort", 
            "title": "sort"
        }, 
        {
            "location": "/builtin/sort/#sort-documentation", 
            "text": "Sort", 
            "title": "sort documentation"
        }, 
        {
            "location": "/builtin/sort/sort/", 
            "text": "Sort\n\n\nSort[list]\n sorts the elements in list according to \nOrder\n.\n\n\nAttributes[Sort] := {Protected}\n\n\nSimple examples\n\n\nSort a list of numbers:\n\n\nIn\n[\n1\n]\n:=\n \nSort\n[{\n6\n,\n \n2\n,\n \n3.2\n,\n \n-\n5.1\n}]\n\n\nOut\n[\n1\n]\n=\n \n{\n-\n5.1\n,\n \n2\n,\n \n3.2\n,\n \n6\n}\n\n\n\n\n\n\nSort a list of strings:\n\n\nIn\n[\n2\n]\n:=\n \nSort\n[{\nhello\n,\n \na\n,\n \naa\n,\n \nzzz\n}]\n\n\nOut\n[\n2\n]\n=\n \n{\na\n,\n \naa\n,\n \nhello\n,\n \nzzz\n}\n\n\n\n\n\n\nSort a list of symbols:\n\n\nIn\n[\n3\n]\n:=\n \nSort\n[{\nd\n,\n \na\n,\n \nb\n,\n \nc\n}]\n\n\nOut\n[\n3\n]\n=\n \n{\na\n,\n \nb\n,\n \nc\n,\n \nd\n}\n\n\n\n\n\n\nSort a list of heterogenous expressions:\n\n\nIn\n[\n4\n]\n:=\n \nSort\n[{\n5\n,\n \nh\n,\n \nfoo\n[\ny\n,\n \n2\n],\n \nbar\n[\na\n^\nx\n]}]\n\n\nOut\n[\n4\n]\n=\n \n{\n5\n,\n \nh\n,\n \nbar\n[\na\n^\nx\n],\n \nfoo\n[\ny\n,\n \n2\n]}\n\n\n\n\n\n\nFurther examples\n\n\nThe object to sort need not be a list:\n\n\nIn\n[\n1\n]\n:=\n \nSort\n[\nfoo\n[\nd\n,\n \na\n,\n \nb\n,\n \nc\n]]\n\n\nOut\n[\n1\n]\n=\n \nfoo\n[\na\n,\n \nb\n,\n \nc\n,\n \nd\n]", 
            "title": "Sort "
        }, 
        {
            "location": "/builtin/sort/sort/#sort", 
            "text": "Sort[list]  sorts the elements in list according to  Order .  Attributes[Sort] := {Protected}", 
            "title": "Sort"
        }, 
        {
            "location": "/builtin/sort/sort/#simple-examples", 
            "text": "Sort a list of numbers:  In [ 1 ] :=   Sort [{ 6 ,   2 ,   3.2 ,   - 5.1 }]  Out [ 1 ] =   { - 5.1 ,   2 ,   3.2 ,   6 }   Sort a list of strings:  In [ 2 ] :=   Sort [{ hello ,   a ,   aa ,   zzz }]  Out [ 2 ] =   { a ,   aa ,   hello ,   zzz }   Sort a list of symbols:  In [ 3 ] :=   Sort [{ d ,   a ,   b ,   c }]  Out [ 3 ] =   { a ,   b ,   c ,   d }   Sort a list of heterogenous expressions:  In [ 4 ] :=   Sort [{ 5 ,   h ,   foo [ y ,   2 ],   bar [ a ^ x ]}]  Out [ 4 ] =   { 5 ,   h ,   bar [ a ^ x ],   foo [ y ,   2 ]}", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/sort/sort/#further-examples", 
            "text": "The object to sort need not be a list:  In [ 1 ] :=   Sort [ foo [ d ,   a ,   b ,   c ]]  Out [ 1 ] =   foo [ a ,   b ,   c ,   d ]", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/symbol/", 
            "text": "symbol documentation\n\n\nSet\n\n\nSetDelayed\n\n\nAttributes\n\n\nClear\n\n\nAtomQ", 
            "title": "symbol"
        }, 
        {
            "location": "/builtin/symbol/#symbol-documentation", 
            "text": "Set  SetDelayed  Attributes  Clear  AtomQ", 
            "title": "symbol documentation"
        }, 
        {
            "location": "/builtin/symbol/set/", 
            "text": "Set\n\n\nlhs = rhs\n sets \nlhs\n to stand for \nrhs\n.\n\n\nAttributes[Set] := {HoldFirst, Protected, SequenceHold}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nx\n=\n1\n+\n2\n\n\nOut\n[\n1\n]\n=\n \n3\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nx\n\n\nOut\n[\n2\n]\n=\n \n3\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nx\n+\n1\n\n\nOut\n[\n3\n]\n=\n \n4\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nx\n+\n1\n\n\nOut\n[\n4\n]\n=\n \n4\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nx\n=\n1\n+\n2\n\n\nOut\n[\n5\n]\n=\n \n3\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nx\n*\n2\n\n\nOut\n[\n6\n]\n=\n \n6\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nx\n=\nx\n*\n2\n\n\nOut\n[\n7\n]\n=\n \n6\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nx\n=\nx\n*\nx\n\n\nOut\n[\n8\n]\n=\n \n36\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \ny\n=\na\n*\na\n\n\nOut\n[\n9\n]\n=\n \na\n^\n2\n\n\n\n\n\n\nIn\n[\n10\n]\n:=\n \ny\n=\ny\n*\ny\n\n\nOut\n[\n10\n]\n=\n \na\n^\n4\n\n\n\n\n\n\nIn\n[\n11\n]\n:=\n \na\n=\n2\n\n\nOut\n[\n11\n]\n=\n \n2\n\n\n\n\n\n\nIn\n[\n12\n]\n:=\n \ny\n\n\nOut\n[\n12\n]\n=\n \n16\n\n\n\n\n\n\nFurther examples\n\n\nSet\n has the \nHoldFirst\n attribute, meaning \nrhs\n is evaluated before assignment:\n\n\nIn\n[\n1\n]\n:=\n \nAttributes\n[\nSet\n]\n\n\nOut\n[\n1\n]\n=\n \n{\nHoldFirst\n,\n \nProtected\n,\n \nSequenceHold\n}\n\n\n\n\n\n\nSetDelayed\n has the \nHoldAll\n attribute, meaning \nrhs\n is not evaluated during assignment:\n\n\nIn\n[\n2\n]\n:=\n \nAttributes\n[\nSetDelayed\n]\n\n\nOut\n[\n2\n]\n=\n \n{\nHoldAll\n,\n \nProtected\n,\n \nSequenceHold\n}", 
            "title": "Set "
        }, 
        {
            "location": "/builtin/symbol/set/#set", 
            "text": "lhs = rhs  sets  lhs  to stand for  rhs .  Attributes[Set] := {HoldFirst, Protected, SequenceHold}", 
            "title": "Set"
        }, 
        {
            "location": "/builtin/symbol/set/#simple-examples", 
            "text": "In [ 1 ] :=   x = 1 + 2  Out [ 1 ] =   3   In [ 2 ] :=   x  Out [ 2 ] =   3   In [ 3 ] :=   x + 1  Out [ 3 ] =   4   In [ 4 ] :=   x + 1  Out [ 4 ] =   4   In [ 5 ] :=   x = 1 + 2  Out [ 5 ] =   3   In [ 6 ] :=   x * 2  Out [ 6 ] =   6   In [ 7 ] :=   x = x * 2  Out [ 7 ] =   6   In [ 8 ] :=   x = x * x  Out [ 8 ] =   36   In [ 9 ] :=   y = a * a  Out [ 9 ] =   a ^ 2   In [ 10 ] :=   y = y * y  Out [ 10 ] =   a ^ 4   In [ 11 ] :=   a = 2  Out [ 11 ] =   2   In [ 12 ] :=   y  Out [ 12 ] =   16", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/symbol/set/#further-examples", 
            "text": "Set  has the  HoldFirst  attribute, meaning  rhs  is evaluated before assignment:  In [ 1 ] :=   Attributes [ Set ]  Out [ 1 ] =   { HoldFirst ,   Protected ,   SequenceHold }   SetDelayed  has the  HoldAll  attribute, meaning  rhs  is not evaluated during assignment:  In [ 2 ] :=   Attributes [ SetDelayed ]  Out [ 2 ] =   { HoldAll ,   Protected ,   SequenceHold }", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/symbol/setdelayed/", 
            "text": "SetDelayed\n\n\nlhs := rhs\n sets \nlhs\n to stand for \nrhs\n, with \nrhs\n not being evaluated until it is referenced by \nlhs\n.\n\n\nAttributes[SetDelayed] := {HoldAll, Protected, SequenceHold}\n\n\nSimple examples\n\n\nSetDelayed\n can be used to define functions:\n\n\nIn\n[\n1\n]\n:=\n \ntesta\n[\nx_\n]\n \n:=\n \nx\n*\n2\n\n\nOut\n[\n1\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \ntesta\n[\nx_Integer\n]\n \n:=\n \nx\n*\n3\n\n\nOut\n[\n2\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \ntesta\n[\nx_Real\n]\n \n:=\n \nx\n*\n4\n\n\nOut\n[\n3\n]\n=\n \nNull\n\n\n\n\n\n\nThe more \"specific\" definitions match first:\n\n\nIn\n[\n4\n]\n:=\n \ntesta\n[\n2.\n]\n\n\nOut\n[\n4\n]\n=\n \n8.\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \ntesta\n[\n2\n]\n\n\nOut\n[\n5\n]\n=\n \n6\n\n\n\n\n\n\nThere is no specific match for \ntesta[k]\n, so the general case matches:\n\n\nIn\n[\n6\n]\n:=\n \ntesta\n[\nk\n]\n\n\nOut\n[\n6\n]\n=\n \n2\n \n*\n \nk\n\n\n\n\n\n\nFurther examples\n\n\nSet\n has the \nHoldFirst\n attribute, meaning \nrhs\n is evaluated before assignment:\n\n\nIn\n[\n1\n]\n:=\n \nAttributes\n[\nSet\n]\n\n\nOut\n[\n1\n]\n=\n \n{\nHoldFirst\n,\n \nProtected\n,\n \nSequenceHold\n}\n\n\n\n\n\n\nSetDelayed\n has the \nHoldAll\n attribute, meaning \nrhs\n is not evaluated during assignment:\n\n\nIn\n[\n2\n]\n:=\n \nAttributes\n[\nSetDelayed\n]\n\n\nOut\n[\n2\n]\n=\n \n{\nHoldAll\n,\n \nProtected\n,\n \nSequenceHold\n}", 
            "title": "SetDelayed "
        }, 
        {
            "location": "/builtin/symbol/setdelayed/#setdelayed", 
            "text": "lhs := rhs  sets  lhs  to stand for  rhs , with  rhs  not being evaluated until it is referenced by  lhs .  Attributes[SetDelayed] := {HoldAll, Protected, SequenceHold}", 
            "title": "SetDelayed"
        }, 
        {
            "location": "/builtin/symbol/setdelayed/#simple-examples", 
            "text": "SetDelayed  can be used to define functions:  In [ 1 ] :=   testa [ x_ ]   :=   x * 2  Out [ 1 ] =   Null   In [ 2 ] :=   testa [ x_Integer ]   :=   x * 3  Out [ 2 ] =   Null   In [ 3 ] :=   testa [ x_Real ]   :=   x * 4  Out [ 3 ] =   Null   The more \"specific\" definitions match first:  In [ 4 ] :=   testa [ 2. ]  Out [ 4 ] =   8.   In [ 5 ] :=   testa [ 2 ]  Out [ 5 ] =   6   There is no specific match for  testa[k] , so the general case matches:  In [ 6 ] :=   testa [ k ]  Out [ 6 ] =   2   *   k", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/symbol/setdelayed/#further-examples", 
            "text": "Set  has the  HoldFirst  attribute, meaning  rhs  is evaluated before assignment:  In [ 1 ] :=   Attributes [ Set ]  Out [ 1 ] =   { HoldFirst ,   Protected ,   SequenceHold }   SetDelayed  has the  HoldAll  attribute, meaning  rhs  is not evaluated during assignment:  In [ 2 ] :=   Attributes [ SetDelayed ]  Out [ 2 ] =   { HoldAll ,   Protected ,   SequenceHold }", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/symbol/attributes/", 
            "text": "Attributes\n\n\nAttributes[sym]\n returns a \nList\n of attributes for \nsym\n.\n\n\nAttributes[Attributes] := {HoldAll, Listable, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nAttributes\n[\nInfinity\n]\n\n\nOut\n[\n1\n]\n=\n \n{\nProtected\n,\n \nReadProtected\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nAttributes\n[\nAttributes\n]\n\n\nOut\n[\n2\n]\n=\n \n{\nHoldAll\n,\n \nListable\n,\n \nProtected\n}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nAttributes\n[\nPlus\n]\n\n\nOut\n[\n3\n]\n=\n \n{\nFlat\n,\n \nListable\n,\n \nNumericFunction\n,\n \nOneIdentity\n,\n \nOrderless\n,\n \nProtected\n}\n\n\n\n\n\n\nThe default set of attributes is the empty list:\n\n\nIn\n[\n4\n]\n:=\n \nAttributes\n[\nundefinedSym\n]\n\n\nOut\n[\n4\n]\n=\n \n{}\n\n\n\n\n\n\nFurther examples\n\n\nOnly symbols can have attributes:\n\n\nIn\n[\n1\n]\n:=\n \nAttributes\n[\n2\n]\n\n\nOut\n[\n1\n]\n=\n \nAttributes\n[\n2\n]\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nAttributes\n[\na\n^\n2\n]\n\n\nOut\n[\n2\n]\n=\n \nAttributes\n[\na\n^\n2\n]", 
            "title": "Attributes "
        }, 
        {
            "location": "/builtin/symbol/attributes/#attributes", 
            "text": "Attributes[sym]  returns a  List  of attributes for  sym .  Attributes[Attributes] := {HoldAll, Listable, Protected}", 
            "title": "Attributes"
        }, 
        {
            "location": "/builtin/symbol/attributes/#simple-examples", 
            "text": "In [ 1 ] :=   Attributes [ Infinity ]  Out [ 1 ] =   { Protected ,   ReadProtected }   In [ 2 ] :=   Attributes [ Attributes ]  Out [ 2 ] =   { HoldAll ,   Listable ,   Protected }   In [ 3 ] :=   Attributes [ Plus ]  Out [ 3 ] =   { Flat ,   Listable ,   NumericFunction ,   OneIdentity ,   Orderless ,   Protected }   The default set of attributes is the empty list:  In [ 4 ] :=   Attributes [ undefinedSym ]  Out [ 4 ] =   {}", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/symbol/attributes/#further-examples", 
            "text": "Only symbols can have attributes:  In [ 1 ] :=   Attributes [ 2 ]  Out [ 1 ] =   Attributes [ 2 ]   In [ 2 ] :=   Attributes [ a ^ 2 ]  Out [ 2 ] =   Attributes [ a ^ 2 ]", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/symbol/clear/", 
            "text": "Clear\n\n\nClear[sym1, sym2, ...]\n clears the symbol definitions from the evaluation context.\n\n\nAttributes[Clear] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \na\n\n\nOut\n[\n1\n]\n=\n \na\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \na\n \n=\n \n5\n\n\nOut\n[\n2\n]\n=\n \n5\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nb\n \n=\n \n6\n\n\nOut\n[\n3\n]\n=\n \n6\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nc\n \n=\n \n7\n\n\nOut\n[\n4\n]\n=\n \n7\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \na\n\n\nOut\n[\n5\n]\n=\n \n5\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nClear\n[\na\n,\n \n99\n,\n \nb\n]\n\n\nOut\n[\n6\n]\n=\n \nNull\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \na\n\n\nOut\n[\n7\n]\n=\n \na\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nb\n\n\nOut\n[\n8\n]\n=\n \nb\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \nc\n\n\nOut\n[\n9\n]\n=\n \n7", 
            "title": "Clear "
        }, 
        {
            "location": "/builtin/symbol/clear/#clear", 
            "text": "Clear[sym1, sym2, ...]  clears the symbol definitions from the evaluation context.  Attributes[Clear] := {HoldAll, Protected}", 
            "title": "Clear"
        }, 
        {
            "location": "/builtin/symbol/clear/#simple-examples", 
            "text": "In [ 1 ] :=   a  Out [ 1 ] =   a   In [ 2 ] :=   a   =   5  Out [ 2 ] =   5   In [ 3 ] :=   b   =   6  Out [ 3 ] =   6   In [ 4 ] :=   c   =   7  Out [ 4 ] =   7   In [ 5 ] :=   a  Out [ 5 ] =   5   In [ 6 ] :=   Clear [ a ,   99 ,   b ]  Out [ 6 ] =   Null   In [ 7 ] :=   a  Out [ 7 ] =   a   In [ 8 ] :=   b  Out [ 8 ] =   b   In [ 9 ] :=   c  Out [ 9 ] =   7", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/symbol/atomq/", 
            "text": "AtomQ\n\n\nAtomQ[expr]\n returns True if \nexpr\n is an atomic type, and False if \nexpr\n is a full expression.\n\n\nAttributes[AtomQ] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nAtomQ\n[\nhello\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nAtomQ\n[\n5\n/\n3\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nAtomQ\n[\nhello\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nAtomQ\n[\na\n/\nb\n]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nAtomQ\n[\nbar\n[\nx\n]]\n\n\nOut\n[\n5\n]\n=\n \nFalse", 
            "title": "AtomQ "
        }, 
        {
            "location": "/builtin/symbol/atomq/#atomq", 
            "text": "AtomQ[expr]  returns True if  expr  is an atomic type, and False if  expr  is a full expression.  Attributes[AtomQ] := {Protected}", 
            "title": "AtomQ"
        }, 
        {
            "location": "/builtin/symbol/atomq/#simple-examples", 
            "text": "In [ 1 ] :=   AtomQ [ hello ]  Out [ 1 ] =   True   In [ 2 ] :=   AtomQ [ 5 / 3 ]  Out [ 2 ] =   True   In [ 3 ] :=   AtomQ [ hello ]  Out [ 3 ] =   True   In [ 4 ] :=   AtomQ [ a / b ]  Out [ 4 ] =   False   In [ 5 ] :=   AtomQ [ bar [ x ]]  Out [ 5 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/system/", 
            "text": "system documentation\n\n\nExpreduceSetLogging\n\n\nTiming\n\n\nPrint\n\n\nCompoundExpression\n\n\nHead\n\n\nMessageName\n\n\nInfix", 
            "title": "system"
        }, 
        {
            "location": "/builtin/system/#system-documentation", 
            "text": "ExpreduceSetLogging  Timing  Print  CompoundExpression  Head  MessageName  Infix", 
            "title": "system documentation"
        }, 
        {
            "location": "/builtin/system/expreducesetlogging/", 
            "text": "ExpreduceSetLogging\n\n\nExpreduceSetLogging[bool]\n sets the logging state to \nbool\n.\n\n\nAttributes[ExpreduceSetLogging] := {Protected}\n\n\nDetails\n\n\nLogging output prints to the console. There can be a lot of logging output, especially for more complicated pattern matches.", 
            "title": "ExpreduceSetLogging "
        }, 
        {
            "location": "/builtin/system/expreducesetlogging/#expreducesetlogging", 
            "text": "ExpreduceSetLogging[bool]  sets the logging state to  bool .  Attributes[ExpreduceSetLogging] := {Protected}", 
            "title": "ExpreduceSetLogging"
        }, 
        {
            "location": "/builtin/system/expreducesetlogging/#details", 
            "text": "Logging output prints to the console. There can be a lot of logging output, especially for more complicated pattern matches.", 
            "title": "Details"
        }, 
        {
            "location": "/builtin/system/timing/", 
            "text": "Timing\n\n\nTiming[expr]\n returns a \nList\n with the first element being the time in seconds for the evaluation of \nexpr\n, and the second element being the result.\n\n\nAttributes[Timing] := {HoldAll, Protected, SequenceHold}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nTiming\n[\nSum\n[\na\n,\n \n{\na\n,\n \n100000000\n}]]\n\n\nOut\n[\n1\n]\n=\n \n{\n0.00167509\n,\n \n5000000050000000\n}", 
            "title": "Timing "
        }, 
        {
            "location": "/builtin/system/timing/#timing", 
            "text": "Timing[expr]  returns a  List  with the first element being the time in seconds for the evaluation of  expr , and the second element being the result.  Attributes[Timing] := {HoldAll, Protected, SequenceHold}", 
            "title": "Timing"
        }, 
        {
            "location": "/builtin/system/timing/#simple-examples", 
            "text": "In [ 1 ] :=   Timing [ Sum [ a ,   { a ,   100000000 }]]  Out [ 1 ] =   { 0.00167509 ,   5000000050000000 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/system/print/", 
            "text": "Print\n\n\nPrint[expr]\n prints the string representation of \nexpr\n to the console and returns \nNull\n.\n\n\nAttributes[Print] := {Protected}", 
            "title": "Print "
        }, 
        {
            "location": "/builtin/system/print/#print", 
            "text": "Print[expr]  prints the string representation of  expr  to the console and returns  Null .  Attributes[Print] := {Protected}", 
            "title": "Print"
        }, 
        {
            "location": "/builtin/system/compoundexpression/", 
            "text": "CompoundExpression\n\n\nCompoundExpression[e1, e2, ...]\n evaluates each expression in order and returns the result of the last one.\n\n\nAttributes[CompoundExpression] := {HoldAll, Protected, ReadProtected}\n\n\nSimple examples\n\n\nThe result of the first expression is not included in the output, but the result of the second is:\n\n\nIn\n[\n1\n]\n:=\n \na\n \n=\n \n5\n;\n \na\n \n-\n \n2\n\n\nOut\n[\n1\n]\n=\n \n3\n\n\n\n\n\n\nIncluding a trailing semicolon causes the expression to return \nNull\n:\n\n\nIn\n[\n2\n]\n:=\n \na\n \n=\n \n5\n;\n \na\n \n-\n \n2\n;\n\n\nOut\n[\n2\n]\n=\n \nNull", 
            "title": "CompoundExpression "
        }, 
        {
            "location": "/builtin/system/compoundexpression/#compoundexpression", 
            "text": "CompoundExpression[e1, e2, ...]  evaluates each expression in order and returns the result of the last one.  Attributes[CompoundExpression] := {HoldAll, Protected, ReadProtected}", 
            "title": "CompoundExpression"
        }, 
        {
            "location": "/builtin/system/compoundexpression/#simple-examples", 
            "text": "The result of the first expression is not included in the output, but the result of the second is:  In [ 1 ] :=   a   =   5 ;   a   -   2  Out [ 1 ] =   3   Including a trailing semicolon causes the expression to return  Null :  In [ 2 ] :=   a   =   5 ;   a   -   2 ;  Out [ 2 ] =   Null", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/system/head/", 
            "text": "Head\n\n\nHead[expr]\n returns the head of the expression.\n\n\nAttributes[Head] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHead\n[\nf\n[\nx\n]]\n\n\nOut\n[\n1\n]\n=\n \nf\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nHead\n[\nx\n]\n\n\nOut\n[\n2\n]\n=\n \nSymbol\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nHead\n[{\nx\n}]\n\n\nOut\n[\n3\n]\n=\n \nList\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nHead\n[\na\n \n+\n \nb\n]\n\n\nOut\n[\n4\n]\n=\n \nPlus\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nHead\n[\n1\n]\n\n\nOut\n[\n5\n]\n=\n \nInteger\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nHead\n[\n1.\n]\n\n\nOut\n[\n6\n]\n=\n \nReal\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nHead\n[\n2\n/\n7\n]\n\n\nOut\n[\n7\n]\n=\n \nRational\n\n\n\n\n\n\nIn\n[\n8\n]\n:=\n \nHead\n[\n1\n/\n7\n]\n\n\nOut\n[\n8\n]\n=\n \nRational\n\n\n\n\n\n\nIn\n[\n9\n]\n:=\n \nHead\n[\n1\n]\n\n\nOut\n[\n9\n]\n=\n \nString\n\n\n\n\n\n\nIn\n[\n10\n]\n:=\n \nHead\n[\nHead\n[(\na\n \n+\n \nb\n)[\nx\n]]]\n\n\nOut\n[\n10\n]\n=\n \nPlus", 
            "title": "Head "
        }, 
        {
            "location": "/builtin/system/head/#head", 
            "text": "Head[expr]  returns the head of the expression.  Attributes[Head] := {Protected}", 
            "title": "Head"
        }, 
        {
            "location": "/builtin/system/head/#simple-examples", 
            "text": "In [ 1 ] :=   Head [ f [ x ]]  Out [ 1 ] =   f   In [ 2 ] :=   Head [ x ]  Out [ 2 ] =   Symbol   In [ 3 ] :=   Head [{ x }]  Out [ 3 ] =   List   In [ 4 ] :=   Head [ a   +   b ]  Out [ 4 ] =   Plus   In [ 5 ] :=   Head [ 1 ]  Out [ 5 ] =   Integer   In [ 6 ] :=   Head [ 1. ]  Out [ 6 ] =   Real   In [ 7 ] :=   Head [ 2 / 7 ]  Out [ 7 ] =   Rational   In [ 8 ] :=   Head [ 1 / 7 ]  Out [ 8 ] =   Rational   In [ 9 ] :=   Head [ 1 ]  Out [ 9 ] =   String   In [ 10 ] :=   Head [ Head [( a   +   b )[ x ]]]  Out [ 10 ] =   Plus", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/system/messagename/", 
            "text": "MessageName\n\n\nsym::msg\n references a particular message for \nsym\n.\n\n\nAttributes[MessageName] := {HoldFirst, Protected, ReadProtected}\n\n\nSimple examples\n\n\nMessageName\n is used to store the usage messages of built-in symbols:\n\n\nIn\n[\n1\n]\n:=\n \nMessageName\n::\nusage\n\n\nOut\n[\n1\n]\n=\n \n`sym::msg` references a particular message for `sym`.", 
            "title": "MessageName "
        }, 
        {
            "location": "/builtin/system/messagename/#messagename", 
            "text": "sym::msg  references a particular message for  sym .  Attributes[MessageName] := {HoldFirst, Protected, ReadProtected}", 
            "title": "MessageName"
        }, 
        {
            "location": "/builtin/system/messagename/#simple-examples", 
            "text": "MessageName  is used to store the usage messages of built-in symbols:  In [ 1 ] :=   MessageName :: usage  Out [ 1 ] =   `sym::msg` references a particular message for `sym`.", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/system/infix/", 
            "text": "Infix\n\n\nInfix[expr, sep]\n represents \nexpr\n in infix form with separator \nsep\n when converted to a string.\n\n\nAttributes[Infix] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nInfix\n[\nfoo\n[\nbar\n,\n \nfuzz\n,\n \nzip\n],\n \n|\n]\n \n//\n \nToString\n\n\nOut\n[\n1\n]\n=\n \n(bar|fuzz|zip)", 
            "title": "Infix "
        }, 
        {
            "location": "/builtin/system/infix/#infix", 
            "text": "Infix[expr, sep]  represents  expr  in infix form with separator  sep  when converted to a string.  Attributes[Infix] := {Protected}", 
            "title": "Infix"
        }, 
        {
            "location": "/builtin/system/infix/#simple-examples", 
            "text": "In [ 1 ] :=   Infix [ foo [ bar ,   fuzz ,   zip ],   | ]   //   ToString  Out [ 1 ] =   (bar|fuzz|zip)", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/string/", 
            "text": "string documentation\n\n\nToString\n\n\nStringJoin", 
            "title": "string"
        }, 
        {
            "location": "/builtin/string/#string-documentation", 
            "text": "ToString  StringJoin", 
            "title": "string documentation"
        }, 
        {
            "location": "/builtin/string/tostring/", 
            "text": "ToString\n\n\nToString[expr, form]\n converts \nexpr\n into a string using printing method \nform\n.\n\n\nAttributes[ToString] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nToString\n[\na\n^\n2\n,\n \nInputForm\n]\n\n\nOut\n[\n1\n]\n=\n \na^2\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nHello World\n \n//\n \nToString\n\n\nOut\n[\n2\n]\n=\n \nHello World\n\n\n\n\n\n\nRules\n\n\nToString\n[\na_\n]\n \n:=\n \nToString\n[\na\n,\n \nOutputForm\n]", 
            "title": "ToString "
        }, 
        {
            "location": "/builtin/string/tostring/#tostring", 
            "text": "ToString[expr, form]  converts  expr  into a string using printing method  form .  Attributes[ToString] := {Protected}", 
            "title": "ToString"
        }, 
        {
            "location": "/builtin/string/tostring/#simple-examples", 
            "text": "In [ 1 ] :=   ToString [ a ^ 2 ,   InputForm ]  Out [ 1 ] =   a^2   In [ 2 ] :=   Hello World   //   ToString  Out [ 2 ] =   Hello World", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/string/tostring/#rules", 
            "text": "ToString [ a_ ]   :=   ToString [ a ,   OutputForm ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/string/stringjoin/", 
            "text": "StringJoin\n\n\ns1 \n s2 \n ...\n can join a list of strings into a single string.\n\n\nAttributes[StringJoin] := {Flat, OneIdentity, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nHello\n \n \n \n \n \nWorld\n\n\nOut\n[\n1\n]\n=\n \nHello World\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nIf a=2, then \n \n \nToString\n[\na\n^\n2\n,\n \nInputForm\n]\n \n \n=\n \n \nToString\n[\na\n^\n2\n \n/.\n \na\n \n-\n \n2\n,\n \nInputForm\n]\n\n\nOut\n[\n2\n]\n=\n \nIf a=2, then a^2=4\n\n\n\n\n\n\nFurther examples\n\n\nThe \nStringJoin\n of nothing is the empty string:\n\n\nIn\n[\n1\n]\n:=\n \nStringJoin\n[]\n\n\nOut\n[\n1\n]\n=\n \n\n\n\n\n\n\nIf \nStringJoin\n receives any non-string arguments, the expression does not evaluate:\n\n\nIn\n[\n2\n]\n:=\n \nStringJoin\n[\nHello\n,\n \n5\n]\n\n\nOut\n[\n2\n]\n=\n \nHello\n \n \n5\n\n\n\n\n\n\nThis function takes \nList\n arguments as well:\n\n\nIn\n[\n3\n]\n:=\n \nStringJoin\n[{\na\n,\n \nb\n,\n \nc\n}]\n\n\nOut\n[\n3\n]\n=\n \nabc\n\n\n\n\n\n\nRules\n\n\nStringJoin\n[\nlist_List\n]\n \n:=\n \nStringJoin\n[\nlist\n \n/.\n \nList\n-\nSequence\n]", 
            "title": "StringJoin "
        }, 
        {
            "location": "/builtin/string/stringjoin/#stringjoin", 
            "text": "s1   s2   ...  can join a list of strings into a single string.  Attributes[StringJoin] := {Flat, OneIdentity, Protected}", 
            "title": "StringJoin"
        }, 
        {
            "location": "/builtin/string/stringjoin/#simple-examples", 
            "text": "In [ 1 ] :=   Hello           World  Out [ 1 ] =   Hello World   In [ 2 ] :=   If a=2, then      ToString [ a ^ 2 ,   InputForm ]     =     ToString [ a ^ 2   /.   a   -   2 ,   InputForm ]  Out [ 2 ] =   If a=2, then a^2=4", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/string/stringjoin/#further-examples", 
            "text": "The  StringJoin  of nothing is the empty string:  In [ 1 ] :=   StringJoin []  Out [ 1 ] =     If  StringJoin  receives any non-string arguments, the expression does not evaluate:  In [ 2 ] :=   StringJoin [ Hello ,   5 ]  Out [ 2 ] =   Hello     5   This function takes  List  arguments as well:  In [ 3 ] :=   StringJoin [{ a ,   b ,   c }]  Out [ 3 ] =   abc", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/string/stringjoin/#rules", 
            "text": "StringJoin [ list_List ]   :=   StringJoin [ list   /.   List - Sequence ]", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/time/", 
            "text": "time documentation\n\n\nUnixTime", 
            "title": "time"
        }, 
        {
            "location": "/builtin/time/#time-documentation", 
            "text": "UnixTime", 
            "title": "time documentation"
        }, 
        {
            "location": "/builtin/time/unixtime/", 
            "text": "UnixTime\n\n\nUnixTime[]\n returns the integer seconds since the Unix epoch in UTC time.\n\n\nAttributes[UnixTime] := {Protected, ReadProtected}\n\n\nSimple examples\n\n\nGet the current Unix timestamp:\n\n\nIn\n[\n1\n]\n:=\n \nUnixTime\n[]\n\n\nOut\n[\n1\n]\n=\n \n1484805639\n\n\n\n\n\n\nUnixTime\n returns an Integer:\n\n\nIn\n[\n2\n]\n:=\n \nUnixTime\n[]\n \n//\n \nHead\n\n\nOut\n[\n2\n]\n=\n \nInteger", 
            "title": "UnixTime "
        }, 
        {
            "location": "/builtin/time/unixtime/#unixtime", 
            "text": "UnixTime[]  returns the integer seconds since the Unix epoch in UTC time.  Attributes[UnixTime] := {Protected, ReadProtected}", 
            "title": "UnixTime"
        }, 
        {
            "location": "/builtin/time/unixtime/#simple-examples", 
            "text": "Get the current Unix timestamp:  In [ 1 ] :=   UnixTime []  Out [ 1 ] =   1484805639   UnixTime  returns an Integer:  In [ 2 ] :=   UnixTime []   //   Head  Out [ 2 ] =   Integer", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/times/", 
            "text": "times documentation\n\n\nTimes\n\n\nFactorial", 
            "title": "times"
        }, 
        {
            "location": "/builtin/times/#times-documentation", 
            "text": "Times  Factorial", 
            "title": "times documentation"
        }, 
        {
            "location": "/builtin/times/times/", 
            "text": "Times\n\n\n(e1 * e2 * ...)\n computes the product of all expressions in the function.\n\n\nAttributes[Times] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}\n\n\nSimple examples\n\n\nSimplification rules apply automatically:\n\n\nIn\n[\n1\n]\n:=\n \n(\n3\n \n+\n \n(\nx\n^\n2\n \n*\n \n0\n))\n \n*\n \n2\n^-\n1\n\n\nOut\n[\n1\n]\n=\n \n3\n/\n2\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \na\n^\n2\n*\na\n^\nc\n\n\nOut\n[\n2\n]\n=\n \na\n^\n(\n2\n+\nc\n)\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \na\n/\nb\n/\nc\n/\nd\n\n\nOut\n[\n3\n]\n=\n \na\n/\n(\nb\n*\nc\n*\nd\n)\n\n\n\n\n\n\nFurther examples\n\n\nRational numbers are suppported (explicit rational declaration added for clarity):\n\n\nIn\n[\n1\n]\n:=\n \nRational\n[\n1\n,\n \n-\n2\n]\n*\nRational\n[\n-\n2\n,\n \n3\n]\n*-\n2\n\n\nOut\n[\n1\n]\n=\n \n-\n2\n/\n3\n\n\n\n\n\n\nThe product of nothing is defined to be one:\n\n\nIn\n[\n2\n]\n:=\n \nTimes\n[]\n\n\nOut\n[\n2\n]\n=\n \n1\n\n\n\n\n\n\nRules\n\n\nTimes\n[\na_\n,\n \na_\n,\n \nrest___\n]\n \n:=\n \na\n^\n2\n \n*\n \nrest\n\n\nTimes\n[\na_\n^\nn_\n,\n \na_\n,\n \nrest___\n]\n \n:=\n \na\n^\n(\nn\n+\n1\n)\n \n*\n \nrest\n\n\nTimes\n[\na_\n^\nn_\n,\n \na_\n^\nm_\n,\n \nrest___\n]\n \n:=\n \na\n^\n(\nn\n+\nm\n)\n \n*\n \nrest\n\n\nTimes\n[\nden_Integer\n^-\n1\n,\n \nnum_Integer\n,\n \nrest___\n]\n \n:=\n \nRational\n[\nnum\n,\nden\n]\n \n*\n \nrest\n\n\nTimes\n[\na_\n,\n \na_\n^-\n1\n,\n \nrest___\n]\n \n:=\n \nrest\n\n\nTimes\n[\na_\n^\nb_\n,\n \na_\n^-\n1\n,\n \nrest___\n]\n \n:=\n \na\n^\n(\nb\n-\n1\n)\n \n*\n \nrest\n\n\n(\n1\n/\nInfinity\n)\n \n:=\n \n0\n\n\nTimes\n[\nComplexInfinity\n,\n \n(\n_?\n(\nFunction\n[\nAtomQ\n[\n#\n]\n \n==\n \nFalse\n]))\n|\n(\n_Symbol\n),\n \nrest___\n]\n \n:=\n \nComplexInfinity\n \n*\n \nrest", 
            "title": "Times "
        }, 
        {
            "location": "/builtin/times/times/#times", 
            "text": "(e1 * e2 * ...)  computes the product of all expressions in the function.  Attributes[Times] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}", 
            "title": "Times"
        }, 
        {
            "location": "/builtin/times/times/#simple-examples", 
            "text": "Simplification rules apply automatically:  In [ 1 ] :=   ( 3   +   ( x ^ 2   *   0 ))   *   2 ^- 1  Out [ 1 ] =   3 / 2   In [ 2 ] :=   a ^ 2 * a ^ c  Out [ 2 ] =   a ^ ( 2 + c )   In [ 3 ] :=   a / b / c / d  Out [ 3 ] =   a / ( b * c * d )", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/times/times/#further-examples", 
            "text": "Rational numbers are suppported (explicit rational declaration added for clarity):  In [ 1 ] :=   Rational [ 1 ,   - 2 ] * Rational [ - 2 ,   3 ] *- 2  Out [ 1 ] =   - 2 / 3   The product of nothing is defined to be one:  In [ 2 ] :=   Times []  Out [ 2 ] =   1", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/times/times/#rules", 
            "text": "Times [ a_ ,   a_ ,   rest___ ]   :=   a ^ 2   *   rest  Times [ a_ ^ n_ ,   a_ ,   rest___ ]   :=   a ^ ( n + 1 )   *   rest  Times [ a_ ^ n_ ,   a_ ^ m_ ,   rest___ ]   :=   a ^ ( n + m )   *   rest  Times [ den_Integer ^- 1 ,   num_Integer ,   rest___ ]   :=   Rational [ num , den ]   *   rest  Times [ a_ ,   a_ ^- 1 ,   rest___ ]   :=   rest  Times [ a_ ^ b_ ,   a_ ^- 1 ,   rest___ ]   :=   a ^ ( b - 1 )   *   rest  ( 1 / Infinity )   :=   0  Times [ ComplexInfinity ,   ( _? ( Function [ AtomQ [ # ]   ==   False ])) | ( _Symbol ),   rest___ ]   :=   ComplexInfinity   *   rest", 
            "title": "Rules"
        }, 
        {
            "location": "/builtin/times/factorial/", 
            "text": "Factorial\n\n\nn!\n returns the factorial of \nn\n.\n\n\nAttributes[Factorial] := {Listable, NumericFunction, Protected, ReadProtected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \n20\n!\n\n\nOut\n[\n1\n]\n=\n \n2432902008176640000\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nFactorial\n[\n5\n]\n\n\nOut\n[\n2\n]\n=\n \n120\n\n\n\n\n\n\nFurther examples\n\n\nIn\n[\n1\n]\n:=\n \nFactorial\n[\n0\n]\n\n\nOut\n[\n1\n]\n=\n \n1\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nFactorial\n[\n-\n1\n]\n\n\nOut\n[\n2\n]\n=\n \nComplexInfinity", 
            "title": "Factorial "
        }, 
        {
            "location": "/builtin/times/factorial/#factorial", 
            "text": "n!  returns the factorial of  n .  Attributes[Factorial] := {Listable, NumericFunction, Protected, ReadProtected}", 
            "title": "Factorial"
        }, 
        {
            "location": "/builtin/times/factorial/#simple-examples", 
            "text": "In [ 1 ] :=   20 !  Out [ 1 ] =   2432902008176640000   In [ 2 ] :=   Factorial [ 5 ]  Out [ 2 ] =   120", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/times/factorial/#further-examples", 
            "text": "In [ 1 ] :=   Factorial [ 0 ]  Out [ 1 ] =   1   In [ 2 ] :=   Factorial [ - 1 ]  Out [ 2 ] =   ComplexInfinity", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/pattern/", 
            "text": "pattern documentation\n\n\nPattern\n\n\nBlank\n\n\nBlankSequence\n\n\nBlankNullSequence\n\n\nExcept\n\n\nPatternTest\n\n\nCondition\n\n\nAlternatives", 
            "title": "pattern"
        }, 
        {
            "location": "/builtin/pattern/#pattern-documentation", 
            "text": "Pattern  Blank  BlankSequence  BlankNullSequence  Except  PatternTest  Condition  Alternatives", 
            "title": "pattern documentation"
        }, 
        {
            "location": "/builtin/pattern/pattern/", 
            "text": "Pattern\n\n\nname{BLANKFORM}\n is equivalent to \nPattern[name, {BLANKFORM}]\n and can be used in pattern matching to refer to the matched expression as \nname\n, where \n{BLANKFORM}\n is one of \n{_, __, ___}\n.\n\n\nname{BLANKFORM}head\n is equivalent to \nPattern[name, {BLANKFORM}head]\n and can be used in pattern matching to refer to the matched expression as \nname\n, where \n{BLANKFORM}\n is one of \n{_, __, ___}\n.\n\n\nAttributes[Pattern] := {HoldFirst, Protected}\n\n\nSimple examples\n\n\nTo demonstrate referencing \nname\n in the replacement RHS:\n\n\nIn\n[\n1\n]\n:=\n \nfoo\n[\n2\n,\n \n1\n]\n \n/.\n \nfoo\n[\na_\n,\n \nb_\n]\n \n-\n \na\n\n\nOut\n[\n1\n]\n=\n \n2\n\n\n\n\n\n\nIf two matches share the same name, they must be equivalent:\n\n\nIn\n[\n2\n]\n:=\n \nfoo\n[\n2\n,\n \n1\n]\n \n/.\n \nfoo\n[\na_\n,\n \na_\n]\n \n-\n \na\n\n\nOut\n[\n2\n]\n=\n \nfoo\n[\n2\n,\n \n1\n]\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nfoo\n[\n2\n,\n \n2\n]\n \n/.\n \nfoo\n[\na_\n,\n \na_\n]\n \n-\n \na\n\n\nOut\n[\n3\n]\n=\n \n2\n\n\n\n\n\n\nTo demonstrate the head matching capability:\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\n2\n,\n \na_Integer\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\n2\n,\n \na_Real\n]\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nFurther examples\n\n\nTo demonstrate patterns matching a sequence of expressions:\n\n\nIn\n[\n1\n]\n:=\n \nfoo\n[\n2\n,\n \n1\n]\n \n/.\n \nfoo\n[\na___Integer\n]\n \n-\n \nbar\n[\na\n]\n\n\nOut\n[\n1\n]\n=\n \nbar\n[\n2\n,\n \n1\n]", 
            "title": "Pattern "
        }, 
        {
            "location": "/builtin/pattern/pattern/#pattern", 
            "text": "name{BLANKFORM}  is equivalent to  Pattern[name, {BLANKFORM}]  and can be used in pattern matching to refer to the matched expression as  name , where  {BLANKFORM}  is one of  {_, __, ___} .  name{BLANKFORM}head  is equivalent to  Pattern[name, {BLANKFORM}head]  and can be used in pattern matching to refer to the matched expression as  name , where  {BLANKFORM}  is one of  {_, __, ___} .  Attributes[Pattern] := {HoldFirst, Protected}", 
            "title": "Pattern"
        }, 
        {
            "location": "/builtin/pattern/pattern/#simple-examples", 
            "text": "To demonstrate referencing  name  in the replacement RHS:  In [ 1 ] :=   foo [ 2 ,   1 ]   /.   foo [ a_ ,   b_ ]   -   a  Out [ 1 ] =   2   If two matches share the same name, they must be equivalent:  In [ 2 ] :=   foo [ 2 ,   1 ]   /.   foo [ a_ ,   a_ ]   -   a  Out [ 2 ] =   foo [ 2 ,   1 ]   In [ 3 ] :=   foo [ 2 ,   2 ]   /.   foo [ a_ ,   a_ ]   -   a  Out [ 3 ] =   2   To demonstrate the head matching capability:  In [ 4 ] :=   MatchQ [ 2 ,   a_Integer ]  Out [ 4 ] =   True   In [ 5 ] :=   MatchQ [ 2 ,   a_Real ]  Out [ 5 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/pattern/#further-examples", 
            "text": "To demonstrate patterns matching a sequence of expressions:  In [ 1 ] :=   foo [ 2 ,   1 ]   /.   foo [ a___Integer ]   -   bar [ a ]  Out [ 1 ] =   bar [ 2 ,   1 ]", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/pattern/blank/", 
            "text": "Blank\n\n\n_\n matches any expression.\n\n\n_head\n matches any expression with a \nHead\n of \nhead\n.\n\n\nAttributes[Blank] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n,\n \n_\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\n1\n,\n \n_Integer\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\ns\n,\n \n_Integer\n]\n\n\nOut\n[\n3\n]\n=\n \nFalse\n\n\n\n\n\n\nBlank\n works with nonatomic \nhead\ns:\n\n\nIn\n[\n4\n]\n:=\n \na\n*\nb\n*\nc\n*\nd\n \n/.\n \n_Times\n \n-\n \n2\n\n\nOut\n[\n4\n]\n=\n \n2\n\n\n\n\n\n\nFurther examples\n\n\nFor \nOrderless\n functions, the match engine will attempt to find a match in any order:\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\nx\n+\n3.\n,\n \nc1match_Real\n+\nmatcha_\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue", 
            "title": "Blank "
        }, 
        {
            "location": "/builtin/pattern/blank/#blank", 
            "text": "_  matches any expression.  _head  matches any expression with a  Head  of  head .  Attributes[Blank] := {Protected}", 
            "title": "Blank"
        }, 
        {
            "location": "/builtin/pattern/blank/#simple-examples", 
            "text": "In [ 1 ] :=   MatchQ [ a   +   b ,   _ ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ 1 ,   _Integer ]  Out [ 2 ] =   True   In [ 3 ] :=   MatchQ [ s ,   _Integer ]  Out [ 3 ] =   False   Blank  works with nonatomic  head s:  In [ 4 ] :=   a * b * c * d   /.   _Times   -   2  Out [ 4 ] =   2", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/blank/#further-examples", 
            "text": "For  Orderless  functions, the match engine will attempt to find a match in any order:  In [ 1 ] :=   MatchQ [ x + 3. ,   c1match_Real + matcha_ ]  Out [ 1 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/pattern/blanksequence/", 
            "text": "BlankSequence\n\n\n__\n matches any sequence of one or more expressions.\n\n\n__head\n matches any sequence of one or more expressions, each with a \nHead\n of \nhead\n.\n\n\nAttributes[BlankSequence] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n \n+\n \nc\n,\n \na\n \n+\n \nb\n \n+\n \n__\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n \n+\n \nc\n,\n \na\n \n+\n \nb\n \n+\n \nc\n \n+\n \n__\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nFurther examples\n\n\nWith head assertions:\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\na\n \n*\n \nb\n,\n \n__Symbol\n]\n\n\nOut\n[\n1\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\na\n \n*\n \nb\n,\n \nx__Symbol\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\na\n,\n \n__Symbol\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\na\n \n*\n \nb\n,\n \nx__Times\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\na\n \n*\n \nb\n,\n \nx__Plus\n]\n\n\nOut\n[\n5\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n,\n \nx__Plus\n]\n\n\nOut\n[\n6\n]\n=\n \nTrue", 
            "title": "BlankSequence "
        }, 
        {
            "location": "/builtin/pattern/blanksequence/#blanksequence", 
            "text": "__  matches any sequence of one or more expressions.  __head  matches any sequence of one or more expressions, each with a  Head  of  head .  Attributes[BlankSequence] := {Protected}", 
            "title": "BlankSequence"
        }, 
        {
            "location": "/builtin/pattern/blanksequence/#simple-examples", 
            "text": "In [ 1 ] :=   MatchQ [ a   +   b   +   c ,   a   +   b   +   __ ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ a   +   b   +   c ,   a   +   b   +   c   +   __ ]  Out [ 2 ] =   False", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/blanksequence/#further-examples", 
            "text": "With head assertions:  In [ 1 ] :=   MatchQ [ a   *   b ,   __Symbol ]  Out [ 1 ] =   False   In [ 2 ] :=   MatchQ [ a   *   b ,   x__Symbol ]  Out [ 2 ] =   False   In [ 3 ] :=   MatchQ [ a ,   __Symbol ]  Out [ 3 ] =   True   In [ 4 ] :=   MatchQ [ a   *   b ,   x__Times ]  Out [ 4 ] =   True   In [ 5 ] :=   MatchQ [ a   *   b ,   x__Plus ]  Out [ 5 ] =   False   In [ 6 ] :=   MatchQ [ a   +   b ,   x__Plus ]  Out [ 6 ] =   True", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/pattern/blanknullsequence/", 
            "text": "BlankNullSequence\n\n\n___\n matches any sequence of zero or more expressions.\n\n\n___head\n matches any sequence of zero or more expressions, each with a \nHead\n of \nhead\n.\n\n\nAttributes[BlankNullSequence] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\na\n*\nb\n,\n \n___\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n,\n \na\n \n+\n \nb\n \n+\n \n___\n]\n\n\nOut\n[\n2\n]\n=\n \nTrue\n\n\n\n\n\n\nFurther examples\n\n\nWith head assertions:\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n \n+\n \nc\n,\n \na\n \n+\n \nx___Symbol\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\na\n \n+\n \nb\n \n+\n \nc\n,\n \na\n \n+\n \nx___Plus\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse", 
            "title": "BlankNullSequence "
        }, 
        {
            "location": "/builtin/pattern/blanknullsequence/#blanknullsequence", 
            "text": "___  matches any sequence of zero or more expressions.  ___head  matches any sequence of zero or more expressions, each with a  Head  of  head .  Attributes[BlankNullSequence] := {Protected}", 
            "title": "BlankNullSequence"
        }, 
        {
            "location": "/builtin/pattern/blanknullsequence/#simple-examples", 
            "text": "In [ 1 ] :=   MatchQ [ a * b ,   ___ ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ a   +   b ,   a   +   b   +   ___ ]  Out [ 2 ] =   True", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/blanknullsequence/#further-examples", 
            "text": "With head assertions:  In [ 1 ] :=   MatchQ [ a   +   b   +   c ,   a   +   x___Symbol ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ a   +   b   +   c ,   a   +   x___Plus ]  Out [ 2 ] =   False", 
            "title": "Further examples"
        }, 
        {
            "location": "/builtin/pattern/except/", 
            "text": "Except\n\n\nExcept[pat]\n matches all expressions except those that match \npat\n.\n\n\nExcept[pat1, pat2]\n matches all expressions that match \npat2\n but not \npat1\n.\n\n\nAttributes[Except] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \n3.5\n,\n \nx\n,\n \ny\n,\n \n4\n},\n \nExcept\n[\n_Real\n]]\n\n\nOut\n[\n1\n]\n=\n \n{\n5\n,\n \n2\n,\n \nx\n,\n \ny\n,\n \n4\n}\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \na\n^\nb\n,\n \nx\n,\n \ny\n,\n \n4\n},\n \nExcept\n[\n_Symbol\n^\n_Symbol\n]]\n\n\nOut\n[\n2\n]\n=\n \n{\n5\n,\n \n2\n,\n \nx\n,\n \ny\n,\n \n4\n}\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \n{\na\n,\n \nb\n,\n \n0\n,\n \n1\n,\n \n2\n,\n \nx\n,\n \ny\n}\n \n/.\n \nExcept\n[\n0\n,\n \na_Integer\n]\n \n-\n \nfoo\n[\na\n]\n\n\nOut\n[\n3\n]\n=\n \n{\na\n,\n \nb\n,\n \n0\n,\n \nfoo\n[\n1\n],\n \nfoo\n[\n2\n],\n \nx\n,\n \ny\n}", 
            "title": "Except "
        }, 
        {
            "location": "/builtin/pattern/except/#except", 
            "text": "Except[pat]  matches all expressions except those that match  pat .  Except[pat1, pat2]  matches all expressions that match  pat2  but not  pat1 .  Attributes[Except] := {Protected}", 
            "title": "Except"
        }, 
        {
            "location": "/builtin/pattern/except/#simple-examples", 
            "text": "In [ 1 ] :=   Cases [{ 5 ,   2 ,   3.5 ,   x ,   y ,   4 },   Except [ _Real ]]  Out [ 1 ] =   { 5 ,   2 ,   x ,   y ,   4 }   In [ 2 ] :=   Cases [{ 5 ,   2 ,   a ^ b ,   x ,   y ,   4 },   Except [ _Symbol ^ _Symbol ]]  Out [ 2 ] =   { 5 ,   2 ,   x ,   y ,   4 }   In [ 3 ] :=   { a ,   b ,   0 ,   1 ,   2 ,   x ,   y }   /.   Except [ 0 ,   a_Integer ]   -   foo [ a ]  Out [ 3 ] =   { a ,   b ,   0 ,   foo [ 1 ],   foo [ 2 ],   x ,   y }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/patterntest/", 
            "text": "PatternTest\n\n\npat?test\n matches when the expression matches \npat\n and \ntest[MATCH]\n evaluates to \nTrue\n.\n\n\nAttributes[PatternTest] := {HoldRest, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\n1\n,\n \n_?\nNumberQ\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\na\n,\n \n_?\nNumberQ\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\n1\n,\n \n1\n?\nNumberQ\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\n1\n,\n \n1.5\n?\nNumberQ\n]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\n1.5\n,\n \n1.5\n?\nNumberQ\n]\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nCases\n[{\n5\n,\n \n2\n,\n \na\n^\nb\n,\n \nx\n,\n \ny\n,\n \n4.5\n},\n \n_?\nNumberQ\n]\n\n\nOut\n[\n6\n]\n=\n \n{\n5\n,\n2\n,\n4.5\n}", 
            "title": "PatternTest "
        }, 
        {
            "location": "/builtin/pattern/patterntest/#patterntest", 
            "text": "pat?test  matches when the expression matches  pat  and  test[MATCH]  evaluates to  True .  Attributes[PatternTest] := {HoldRest, Protected}", 
            "title": "PatternTest"
        }, 
        {
            "location": "/builtin/pattern/patterntest/#simple-examples", 
            "text": "In [ 1 ] :=   MatchQ [ 1 ,   _? NumberQ ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ a ,   _? NumberQ ]  Out [ 2 ] =   False   In [ 3 ] :=   MatchQ [ 1 ,   1 ? NumberQ ]  Out [ 3 ] =   True   In [ 4 ] :=   MatchQ [ 1 ,   1.5 ? NumberQ ]  Out [ 4 ] =   False   In [ 5 ] :=   MatchQ [ 1.5 ,   1.5 ? NumberQ ]  Out [ 5 ] =   True   In [ 6 ] :=   Cases [{ 5 ,   2 ,   a ^ b ,   x ,   y ,   4.5 },   _? NumberQ ]  Out [ 6 ] =   { 5 , 2 , 4.5 }", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/condition/", 
            "text": "Condition\n\n\npat /; cond\n matches an expression if the expression matches \npat\n, and if \ncond\n evaluates to \nTrue\n with all the named patterns substituted in.\n\n\nAttributes[Condition] := {HoldAll, Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nMatchQ\n[\n5\n,\n \n_\n \n/;\n \nTrue\n]\n\n\nOut\n[\n1\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\n5\n,\n \n_\n \n/;\n \nFalse\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\n5\n,\n \ny_\n \n/;\n \nTrue\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\n5\n,\n \ny_Real\n \n/;\n \nTrue\n]\n\n\nOut\n[\n4\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nMatchQ\n[\n5\n,\n \ny_Integer\n \n/;\n \nTrue\n]\n\n\nOut\n[\n5\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \nMatchQ\n[\n5\n,\n \ny_\n \n/;\n \ny\n \n==\n \n0\n]\n\n\nOut\n[\n6\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nMatchQ\n[\n5\n,\n \ny_\n \n/;\n \ny\n \n==\n \n5\n]\n\n\nOut\n[\n7\n]\n=\n \nTrue", 
            "title": "Condition "
        }, 
        {
            "location": "/builtin/pattern/condition/#condition", 
            "text": "pat /; cond  matches an expression if the expression matches  pat , and if  cond  evaluates to  True  with all the named patterns substituted in.  Attributes[Condition] := {HoldAll, Protected}", 
            "title": "Condition"
        }, 
        {
            "location": "/builtin/pattern/condition/#simple-examples", 
            "text": "In [ 1 ] :=   MatchQ [ 5 ,   _   /;   True ]  Out [ 1 ] =   True   In [ 2 ] :=   MatchQ [ 5 ,   _   /;   False ]  Out [ 2 ] =   False   In [ 3 ] :=   MatchQ [ 5 ,   y_   /;   True ]  Out [ 3 ] =   True   In [ 4 ] :=   MatchQ [ 5 ,   y_Real   /;   True ]  Out [ 4 ] =   False   In [ 5 ] :=   MatchQ [ 5 ,   y_Integer   /;   True ]  Out [ 5 ] =   True   In [ 6 ] :=   MatchQ [ 5 ,   y_   /;   y   ==   0 ]  Out [ 6 ] =   False   In [ 7 ] :=   MatchQ [ 5 ,   y_   /;   y   ==   5 ]  Out [ 7 ] =   True", 
            "title": "Simple examples"
        }, 
        {
            "location": "/builtin/pattern/alternatives/", 
            "text": "Alternatives\n\n\nalt1 | alt2 | ...\n matches an expression if it matches any pattern in the list of alternatives.\n\n\nAttributes[Alternatives] := {Protected}\n\n\nSimple examples\n\n\nIn\n[\n1\n]\n:=\n \nc\n \n|\n \nd\n\n\nOut\n[\n1\n]\n=\n \nAlternatives\n[\nc\n,\nd\n]\n\n\n\n\n\n\nIn\n[\n2\n]\n:=\n \nMatchQ\n[\nb\n,\n \nc\n \n|\n \nd\n]\n\n\nOut\n[\n2\n]\n=\n \nFalse\n\n\n\n\n\n\nIn\n[\n3\n]\n:=\n \nMatchQ\n[\nc\n,\n \nc\n \n|\n \nd\n]\n\n\nOut\n[\n3\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n4\n]\n:=\n \nMatchQ\n[\nd\n,\n \nc\n \n|\n \nd\n]\n\n\nOut\n[\n4\n]\n=\n \nTrue\n\n\n\n\n\n\nIn\n[\n5\n]\n:=\n \nCases\n[{\na\n,\n \nb\n,\n \nc\n,\n \n1\n,\n \n2\n},\n \nc\n \n|\n \n_Integer\n]\n\n\nOut\n[\n5\n]\n=\n \n{\nc\n,\n \n1\n,\n \n2\n}\n\n\n\n\n\n\nIn\n[\n6\n]\n:=\n \n{\na\n,\n \nb\n,\n \nc\n,\n \n1.\n,\n \n2\n}\n \n/.\n \namatch_Symbol\n \n|\n \namatch_Integer\n \n-\n \namatch\n \n+\n \n1\n\n\nOut\n[\n6\n]\n=\n \n(\n1\n \n+\n \nList\n)[\n1\n \n+\n \na\n,\n \n1\n \n+\n \nb\n,\n \n1\n \n+\n \nc\n,\n \n1.\n,\n \n3\n]\n\n\n\n\n\n\nIn\n[\n7\n]\n:=\n \nCases\n[{\na\n,\n \nb\n,\n \nc\n,\n \nd\n,\n \ne\n,\n \nf\n},\n \nb\n \n|\n \nc\n \n|\n \nd\n \n|\n \ne\n]\n\n\nOut\n[\n7\n]\n=\n \n{\nb\n,\n \nc\n,\n \nd\n,\n \ne\n}", 
            "title": "Alternatives "
        }, 
        {
            "location": "/builtin/pattern/alternatives/#alternatives", 
            "text": "alt1 | alt2 | ...  matches an expression if it matches any pattern in the list of alternatives.  Attributes[Alternatives] := {Protected}", 
            "title": "Alternatives"
        }, 
        {
            "location": "/builtin/pattern/alternatives/#simple-examples", 
            "text": "In [ 1 ] :=   c   |   d  Out [ 1 ] =   Alternatives [ c , d ]   In [ 2 ] :=   MatchQ [ b ,   c   |   d ]  Out [ 2 ] =   False   In [ 3 ] :=   MatchQ [ c ,   c   |   d ]  Out [ 3 ] =   True   In [ 4 ] :=   MatchQ [ d ,   c   |   d ]  Out [ 4 ] =   True   In [ 5 ] :=   Cases [{ a ,   b ,   c ,   1 ,   2 },   c   |   _Integer ]  Out [ 5 ] =   { c ,   1 ,   2 }   In [ 6 ] :=   { a ,   b ,   c ,   1. ,   2 }   /.   amatch_Symbol   |   amatch_Integer   -   amatch   +   1  Out [ 6 ] =   ( 1   +   List )[ 1   +   a ,   1   +   b ,   1   +   c ,   1. ,   3 ]   In [ 7 ] :=   Cases [{ a ,   b ,   c ,   d ,   e ,   f },   b   |   c   |   d   |   e ]  Out [ 7 ] =   { b ,   c ,   d ,   e }", 
            "title": "Simple examples"
        }
    ]
}