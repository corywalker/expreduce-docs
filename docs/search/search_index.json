{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Expreduce","text":"<p>Expreduce implements a language with specialized constructs for term rewriting. It is a neat language for a computer algebra system because it is able to express expression manipulation steps in a form very similar to standard math equations. For example, the product rule in calculus can be expressed as:</p> <pre><code>D[a_*b_,x_] := D[a,x]*b + a*D[b,x]\n</code></pre> <p>Now that the kernel understands the product rule, when it later encounters a pattern matching the above LHS, it will recursively apply the product rule until the expression stabilizes.</p> <p>The term rewriting system and pattern matching engine is fairly advanced. The computer algebra system at this stage is extremely limited, but simple calculus and algebraic manipulation is certainly supported (see examples below). If you are looking for a more mature computer algebra system, please consider using Mathematica (proprietary) or Mathics (open source, Sympy-backed).</p>"},{"location":"#source-code","title":"Source code","text":"<p>Expreduce is on GitHub.</p>"},{"location":"#install-and-run","title":"Install and run","text":"<p>DOWNLOAD HERE</p> <p>If you just want to get started, you can download a binary release and run the software without any downloading Go or compiling. Head over to the latest release and download the correct package for your OS.</p>"},{"location":"#from-source","title":"From source","text":"<pre><code>go get github.com/corywalker/expreduce\nexpreduce\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>Welcome to Expreduce!\nIn[1]:= D[Cos[Log[Sin[x]]+x]+x,x]\nOut[1]= 1 + -(1 + Cot[x])*Sin[x + Log[Sin[x]]]\nIn[2]:= Integrate[5*E^(3*x),{x,2,a}] // Expand\nOut[2]= -5/3*E^6 + 5/3*E^(3*a)\nIn[3]:= FactorSquareFree[1 - 2*x^2 + x^4]\nOut[3]= (-1 + x^2)^2\nIn[4]:= Sum[i, {i, 1, n}]\nOut[4]= 1/2*n*(1 + n)\nIn[5]:= Together[(1/2 + 3/a)^2+b/c]\nOut[5]= 1/4*a^-2*c^-1*(4*a^2*b + 36*c + 12*a*c + a^2*c)\nIn[6]:= 40!\nOut[6]= 815915283247897734345611269596115894272000000000\nIn[7]:= Solve[x^2-x-2.5==0,x]\nOut[7]= {{x -&gt; -1.15831}, {x -&gt; 2.15831}}\n</code></pre>"},{"location":"#rubi-integration-rules","title":"Rubi integration rules","text":"<p>Expreduce uses the Rubi integration suite by Albert Rich. The rules can be loaded by running <code>LoadRubi[]</code> and then the integration can be called like <code>Int[Sin[a + b*Log[c*x^n]], x]</code>. These rules are much more powerful than the simplistic ones in <code>Integrate[]</code>.</p> <p>http://www.apmaths.uwo.ca/~arich/</p>"},{"location":"#integration-examples","title":"Integration examples","text":"<pre><code>In[1]:= Int[((A + C*Sin[e + f*x]^2)*(a + a*Sin[e + f*x])^m*(c + -c*Sin[e + f*x])^(-1/2)), x]\nOut[1]= (f^-1*Cos[e + f*x]*Hypergeometric2F1[1, 1/2 + m, 3/2 + m, 1/2*(1 + Sin[e + f*x])]*(1 + 2*m)^-1*(A + C)*(a + a*Sin[e + f*x])^m*(c + -c*Sin[e + f*x])^(-1/2) + -2*C*a^-1*f^-1*Cos[e + f*x]*(3 + 2*m)^-1*(a + a*Sin[e + f*x])^(1 + m)*(c + -c*Sin[e + f*x])^(-1/2))\nIn[2]:= Int[(x^-5*(a*x)^(-1/2)*(1 + -a*x)^(-1/2)*(1 + a*x)), x]\nOut[1]= (-2/9*a^4*(a*x)^(-9/2)*(1 + -a*x)^(1/2) + -34/63*a^4*(a*x)^(-7/2)*(1 + -a*x)^(1/2) + -68/105*a^4*(a*x)^(-5/2)*(1 + -a*x)^(1/2) + -272/315*a^4*(a*x)^(-3/2)*(1 + -a*x)^(1/2) + -544/315*a^4*(a*x)^(-1/2)*(1 + -a*x)^(1/2))\n</code></pre>"},{"location":"#other-projects","title":"Other projects","text":"<p>Expreduce is indeed very similar to Mathics, a similar term rewriting system that uses Sympy as a backend for CAS operations. I created expreduce for a few reasons. The first is that I wanted to learn everything I could about term rewriting systems. The second is that I believe the syntax implemented in here is better suited for building a computer algebra system than using Python to manipulate expressions (as Sympy, and thus Mathics does). Using a language with first-class support for pattern matching and replacement across expression trees is ideal for writing a computer algebra system. This combined with an optimized core can lead to efficient and informed evaluation without much translation work for the programmer when translating equations to code.</p>"},{"location":"#current-limitations","title":"Current limitations","text":"<p>When the engine applies rules for a given symbol, it tries to match the most \"specific\" rules first. The current definition of specificity is basic now, but can certainly be improved upon. It works in most cases but I can envision cases where it will be wrong. Right now there is no way to override the order of rule application, but it should be simple to add in the future.</p> <p>The pattern matching system can be very slow, especially when working with <code>Orderless</code> expressions with many terms. This is because correctly matching such terms often involves checking many different permutations of a pattern until one finds a match. My theory right now is that the current matching system is behaving naively and that it can be modified to speed things up.</p>"},{"location":"#future-directions","title":"Future directions","text":"<p>I'm interested in trying to apply Golang's concurrency paradigms to the evaluation sequence. Some low hanging fruit would be to have parallel computation of mapping pure functions onto Lists or other expressions (computing the derivative of a list expressions). Similarly, supporting automatic threading of Listable functions would be nice (computing sin(x) of a large array). The evaluation of an expression often starts with evaluating each of the parameters at the beginning. This could potentially be made concurrent as well. A more complicated but very interesting application would be to break down the pattern matching engine into concurrent components. We would have to be very careful about side effects here, so we might need to overhaul our scoping constructs or somehow restrict access to the EvalState. Another option would be to create a function that predicts if another function has side effects (is this feasible?). A true prediction could allow the system to fall back to non-concurrent evaluation.</p> <p>Since there are at least two other replacement engines that implement the same syntax that I know of (another one here), it would could be useful to decide on a standard link protocol such that the replacement engine is independent of the rules that run on top of it. Another layer of abstraction is the frontend. Really the hierarchy goes as follows: core &lt;- rules &lt;- frontend. It would be nice to see all of these functions factored out and interchangeable.</p> <p>Also of interest is to build up some formal theory on the rule definitions. There should be some pre-existing literature on this, as term-rewriting is a studied field. Some interesting questions to answer are:</p> <ol> <li>Given a set of rules for a symbol (or the universe of rules?), can we find duplicates or reduce the set of rules to the most fundamental ones? Answering such a question would improve the efficiency and clarity of the system.</li> <li>Given a set of rules for a symbol (or the universe of rules?), can we prove that the recursive rewrites will terminate? It is fairly easy to write a rule that loops on itself or in cooperation with other rules. Of course, we should remove from consideration some of the imperative symbols such as <code>While</code> and <code>For</code>. Even with these imperative functions removed, is this question still the halting problem? Can we restrict our considerations enough such that the problem is not the halting problem? Answering this question would improve the stability of the system.</li> </ol>"},{"location":"#development","title":"Development","text":"<p>Pretty standard Go workflow. Just remember to <code>go generate</code>. <pre><code># To update any .m changes or changes to the parser:\ngo generate ./...\n# To run the test suite:\ngo test ./...\n</code></pre></p> <p>The use of <code>go generate</code> might require the download of additional dependencies.</p>"},{"location":"builtin/arithmetic/","title":"arithmetic documentation","text":"<p>Plus</p> <p>Sum</p> <p>Times</p> <p>Product</p> <p>Abs</p> <p>Divide</p> <p>Increment</p> <p>Decrement</p> <p>PreIncrement</p> <p>PreDecrement</p> <p>AddTo</p> <p>SubtractFrom</p>"},{"location":"builtin/arithmetic/abs/","title":"Abs","text":"<p><code>Abs[expr]</code> calculates the absolute value of <code>expr</code>.</p> <p><code>Attributes[Abs] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/abs/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Abs[-5]\nOut[1]= 5\n</code></pre> <pre><code>In[2]:= Abs[5]\nOut[2]= 5\n</code></pre> Absolute values of unspecified inputs will be left unevaluated: <pre><code>In[3]:= Abs[a]\nOut[3]= Abs[a]\n</code></pre> But sometimes simplifications can occur: <pre><code>In[4]:= Abs[Sin[x]*-1]\nOut[4]= Abs[Sin[x]]\n</code></pre></p>"},{"location":"builtin/arithmetic/addto/","title":"AddTo","text":"<p><code>AddTo[a, b]</code> adds <code>b</code> to <code>a</code> and returns the new value.</p> <p><code>Attributes[AddTo] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/arithmetic/addto/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= AddTo[toModify, 2]\nOut[2]= 5\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 5\n</code></pre></p>"},{"location":"builtin/arithmetic/decrement/","title":"Decrement","text":"<p><code>Decrement[a]</code> subtracts 1 from <code>a</code> and returns the original value.</p> <p><code>Attributes[Decrement] := {HoldFirst, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/decrement/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= Decrement[toModify]\nOut[2]= 3\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 2\n</code></pre></p>"},{"location":"builtin/arithmetic/divide/","title":"Divide","text":"<p><code>Divide[a, b]</code> computes <code>a/b</code>.</p> <p><code>Attributes[Divide] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/arithmetic/divide/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Divide[10, 5]\nOut[1]= 2\n</code></pre>"},{"location":"builtin/arithmetic/increment/","title":"Increment","text":"<p><code>Increment[a]</code> adds 1 to <code>a</code> and returns the original value.</p> <p><code>Attributes[Increment] := {HoldFirst, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/increment/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= Increment[toModify]\nOut[2]= 3\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 4\n</code></pre></p>"},{"location":"builtin/arithmetic/plus/","title":"Plus","text":"<p><code>(e1 + e2 + ...)</code> computes the sum of all expressions in the function.</p> <p><code>Attributes[Plus] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/arithmetic/plus/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= 1 + 1\nOut[1]= 2\n</code></pre> If Reals are present, other Integers are demoted to Reals: <pre><code>In[2]:= (5.2 + 0.2*-1) + 5*-1\nOut[2]= 0.\n</code></pre> Plus automatically combines like terms: <pre><code>In[3]:= a + b^2 + 5*b^2\nOut[3]= a + 6*b^2\n</code></pre> <pre><code>In[4]:= (a + b) + (a + b)*-1 + c + c*-1 + 2*c^a + 2*d + 5*d + d + (5*d)*-1 + 3*c^a\nOut[4]= 5*c^a + 3*d\n</code></pre> <pre><code>In[5]:= 4*a*b*c*d*e*f - 7*a*b*c*d*e*f\nOut[5]= -3*a*b*c*d*e*f\n</code></pre></p>"},{"location":"builtin/arithmetic/predecrement/","title":"PreDecrement","text":"<p><code>PreDecrement[a]</code> subtracts 1 from <code>a</code> and returns the new value.</p> <p><code>Attributes[PreDecrement] := {HoldFirst, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/predecrement/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= PreDecrement[toModify]\nOut[2]= 2\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 2\n</code></pre></p>"},{"location":"builtin/arithmetic/preincrement/","title":"PreIncrement","text":"<p><code>PreIncrement[a]</code> adds 1 to <code>a</code> and returns the new value.</p> <p><code>Attributes[PreIncrement] := {HoldFirst, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/preincrement/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= PreIncrement[toModify]\nOut[2]= 4\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 4\n</code></pre></p>"},{"location":"builtin/arithmetic/product/","title":"Product","text":"<p><code>Product[expr, n]</code> returns the product of <code>n</code> copies of <code>expr</code>.</p> <p><code>Product[expr, {sym, n}]</code> returns the product of <code>expr</code> evaluated with <code>sym</code> = 1 to <code>n</code>.</p> <p><code>Product[expr, {sym, m, n}]</code> returns the product of <code>expr</code> evaluated with <code>sym</code> = <code>m</code> to <code>n</code>.</p> <p><code>Attributes[Product] := {HoldAll, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/product/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Product[a, {a, 1, 5}]\nOut[1]= 120\n</code></pre> <pre><code>In[2]:= Product[f[a], {a, 1, 5}]\nOut[2]= f[1]*f[2]*f[3]*f[4]*f[5]\n</code></pre> <pre><code>In[3]:= Product[a^2, {a, 4}]\nOut[3]= 576\n</code></pre> <pre><code>In[4]:= Product[a + b, {a, 1, 2}, {b, 1, 3}]\nOut[4]= 1440\n</code></pre></p>"},{"location":"builtin/arithmetic/subtractfrom/","title":"SubtractFrom","text":"<p><code>SubtractFrom[a, b]</code> subtracts <code>b</code> from <code>a</code> and returns the new value.</p> <p><code>Attributes[SubtractFrom] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/arithmetic/subtractfrom/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= toModify = 3\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= SubtractFrom[toModify, 2]\nOut[2]= 1\n</code></pre> <pre><code>In[3]:= toModify\nOut[3]= 1\n</code></pre></p>"},{"location":"builtin/arithmetic/sum/","title":"Sum","text":"<p><code>Sum[expr, n]</code> returns the sum of <code>n</code> copies of <code>expr</code>.</p> <p><code>Sum[expr, {sym, n}]</code> returns the sum of <code>expr</code> evaluated with <code>sym</code> = 1 to <code>n</code>.</p> <p><code>Sum[expr, {sym, m, n}]</code> returns the sum of <code>expr</code> evaluated with <code>sym</code> = <code>m</code> to <code>n</code>.</p> <p><code>Attributes[Sum] := {HoldAll, Protected, ReadProtected}</code></p>"},{"location":"builtin/arithmetic/sum/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Sum[i, {i, 5, 10}]\nOut[1]= 45\n</code></pre> <pre><code>In[2]:= Sum[i, {i, 1, 10}]\nOut[2]= 55\n</code></pre> <pre><code>In[3]:= Sum[i, {i, 0, 10}]\nOut[3]= 55\n</code></pre> <pre><code>In[4]:= Sum[i, {i, 1, 30000}]\nOut[4]= 450015000\n</code></pre> <pre><code>In[5]:= Sum[i, {i, 0, 30000}]\nOut[5]= 450015000\n</code></pre> <pre><code>In[6]:= Sum[i, {i, 0, n}]\nOut[6]= (1*n*(1 + n))/(2)\n</code></pre> <pre><code>In[7]:= Sum[i, {i, 1, n}]\nOut[7]= (1*n*(1 + n))/(2)\n</code></pre> <pre><code>In[8]:= Sum[a + b, {a, 0, 2}, {b, 0, 3}]\nOut[8]= 30\n</code></pre> <pre><code>In[9]:= Sum[a, {a, {b, c, d, e}}]\nOut[9]= b + c + d + e\n</code></pre> <pre><code>In[10]:= Sum[a*f, {a, {b, c, d, e}}, {f, {g, h}}]\nOut[10]= b*g + c*g + d*g + e*g + b*h + c*h + d*h + e*h\n</code></pre> <pre><code>In[11]:= Sum[i, {i, n*50}]\nOut[11]= 25*n*(1 + 50*n)\n</code></pre></p>"},{"location":"builtin/arithmetic/times/","title":"Times","text":"<p><code>(e1 * e2 * ...)</code> computes the product of all expressions in the function.</p> <p><code>Attributes[Times] := {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/arithmetic/times/#simple-examples","title":"Simple examples","text":"<p>Simplification rules apply automatically: <pre><code>In[1]:= (3 + x^2*0)/(2)\nOut[1]= (3)/(2)\n</code></pre> <pre><code>In[2]:= a^2*a^c\nOut[2]= a^(2 + c)\n</code></pre> <pre><code>In[3]:= (((a)/(b))/(c))/(d)\nOut[3]= (a)/(b*c*d)\n</code></pre></p>"},{"location":"builtin/arithmetic/times/#further-examples","title":"Further examples","text":"<p>Rational numbers are suppported (explicit rational declaration added for clarity): <pre><code>In[1]:= Rational[1, -2]*Rational[-2, 3]*-2\nOut[1]= (-2)/(3)\n</code></pre> The product of nothing is defined to be one: <pre><code>In[2]:= Times[]\nOut[2]= 1\n</code></pre></p>"},{"location":"builtin/atoms/","title":"atoms documentation","text":"<p>Rational</p> <p>Complex</p> <p>String</p> <p>Real</p> <p>Integer</p> <p>IntegerQ</p> <p>Im</p> <p>Re</p>"},{"location":"builtin/atoms/complex/","title":"Complex","text":"<p><code>Complex</code> is the head for the atomic rational type.</p> <p><code>Attributes[Complex] := {Protected}</code></p>"},{"location":"builtin/atoms/complex/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= (4 + 8*I)*(2 + 3*I)\nOut[1]= Complex[-16, 28]\n</code></pre>"},{"location":"builtin/atoms/im/","title":"Im","text":"<p><code>Im[e]</code> finds the imaginary part of <code>e</code>.</p> <p><code>Attributes[Im] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/atoms/im/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Im[1]\nOut[1]= 0\n</code></pre> <pre><code>In[2]:= Im[0.5]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= Im[(2)/(3)]\nOut[3]= 0\n</code></pre> <pre><code>In[4]:= Im[2 + I]\nOut[4]= 1\n</code></pre> <pre><code>In[5]:= Im[(1*E^(I*(Pi)/(4)))/(2)]\nOut[5]= (1)/(2*Sqrt[2])\n</code></pre> <pre><code>In[6]:= Im[(I*-1)/(Sqrt[2])]\nOut[6]= (-1)/(Sqrt[2])\n</code></pre> <pre><code>In[7]:= Im[a*I*b]\nOut[7]= Re[a*b]\n</code></pre> <pre><code>In[8]:= Im[(I)/(Sqrt[2])*-1 + (1*E^((I*Pi))/(4))/(2)]\nOut[8]= (1)/((2*Sqrt[2]))*-1\n</code></pre></p>"},{"location":"builtin/atoms/integer/","title":"Integer","text":"<p><code>Integer</code> is the head for the atomic integer type.</p> <p><code>Attributes[Integer] := {Protected}</code></p>"},{"location":"builtin/atoms/integer/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Head[153]\nOut[1]= Integer\n</code></pre> Integer numbers are backed by arbitrary-precision data structures: <pre><code>In[2]:= Factorial[40]\nOut[2]= 815915283247897734345611269596115894272000000000\n</code></pre></p>"},{"location":"builtin/atoms/integer/#further-examples","title":"Further examples","text":"<pre><code>In[1]:= MatchQ[153, _Integer]\nOut[1]= True\n</code></pre>"},{"location":"builtin/atoms/integerq/","title":"IntegerQ","text":"<p><code>IntegerQ[e]</code> returns True if <code>e</code> is an Integer, False otherwise.</p> <p><code>Attributes[IntegerQ] := {Protected}</code></p>"},{"location":"builtin/atoms/integerq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= IntegerQ[a]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= IntegerQ[1]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= IntegerQ[2.]\nOut[3]= False\n</code></pre></p>"},{"location":"builtin/atoms/rational/","title":"Rational","text":"<p><code>Rational</code> is the head for the atomic rational type.</p> <p><code>Attributes[Rational] := {Protected}</code></p>"},{"location":"builtin/atoms/rational/#simple-examples","title":"Simple examples","text":"<p>Rationals are created from <code>Times</code> when a rational form is encountered: <pre><code>In[1]:= Head[(5)/(6)]\nOut[1]= Rational\n</code></pre> Which is equivalent to typing them in directly: <pre><code>In[2]:= Head[(5)/(6)]\nOut[2]= Rational\n</code></pre> Or being even more explicit: <pre><code>In[3]:= Head[Rational[5, 6]]\nOut[3]= Rational\n</code></pre> Rationals simplify on evaluation: <pre><code>In[4]:= Rational[10, 6]\nOut[4]= (5)/(3)\n</code></pre> Which might include evaluating to an Integer: <pre><code>In[5]:= Head[Rational[-100, 10]]\nOut[5]= Integer\n</code></pre> Rationals of non-Integer types are not allowed: <pre><code>In[6]:= Rational[0, n]\nOut[6]= Rational[0, n]\n</code></pre></p>"},{"location":"builtin/atoms/rational/#further-examples","title":"Further examples","text":"<p>Undefined rationals are handled accordingly: <pre><code>In[1]:= Rational[0, 0]\nOut[1]= Indeterminate\n</code></pre> <pre><code>In[2]:= Rational[1, 0]\nOut[2]= ComplexInfinity\n</code></pre> Rational numbers have some special handling for pattern matching: <pre><code>In[3]:= test = Rational[2, 3]\nOut[3]= (2)/(3)\n</code></pre> <pre><code>In[4]:= MatchQ[test, (2)/(3)]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= MatchQ[test, Rational[a_Integer, b_Integer]]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= ((2)/(3)) /. ((Rational[a_Integer, b_Integer] -&gt; {a, b}))\nOut[6]= {2, 3}\n</code></pre> <pre><code>In[7]:= ((2)/(3)) /. (((a_Integer)/(b_Integer) -&gt; {a, b}))\nOut[7]= (2)/(3)\n</code></pre></p>"},{"location":"builtin/atoms/re/","title":"Re","text":"<p><code>Re[e]</code> finds the real part of <code>e</code>.</p> <p><code>Attributes[Re] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/atoms/re/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Re[1]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Re[0.5]\nOut[2]= 0.5\n</code></pre> <pre><code>In[3]:= Re[(2)/(3)]\nOut[3]= (2)/(3)\n</code></pre> <pre><code>In[4]:= Re[2 + I]\nOut[4]= 2\n</code></pre> <pre><code>In[5]:= Re[(1*E^(I*(Pi)/(4)))/(2)]\nOut[5]= (1)/(2*Sqrt[2])\n</code></pre> <pre><code>In[6]:= Re[foo + 1]\nOut[6]= 1 + Re[foo]\n</code></pre> <pre><code>In[7]:= Re[foo + 1 + bar]\nOut[7]= 1 + Re[foo + bar]\n</code></pre> <pre><code>In[8]:= Re[foo + I]\nOut[8]= Re[foo]\n</code></pre> <pre><code>In[9]:= Re[foo + I + bar]\nOut[9]= Re[foo + bar]\n</code></pre> <pre><code>In[10]:= Re[(a)/(2)]\nOut[10]= (Re[a])/(2)\n</code></pre></p>"},{"location":"builtin/atoms/real/","title":"Real","text":"<p><code>Real</code> is the head for the atomic floating point type.</p> <p><code>Attributes[Real] := {Protected}</code></p>"},{"location":"builtin/atoms/real/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Head[1.53]\nOut[1]= Real\n</code></pre> One can force Real interperetation on an Integer by appending a decimal point: <pre><code>In[2]:= Head[1.]\nOut[2]= Real\n</code></pre> Real numbers are backed by arbitrary-precision floating points: <pre><code>In[3]:= 10.^5000 / 10.^4999\nOut[3]= 10.\n</code></pre></p>"},{"location":"builtin/atoms/real/#further-examples","title":"Further examples","text":"<pre><code>In[1]:= MatchQ[1.53, _Real]\nOut[1]= True\n</code></pre>"},{"location":"builtin/atoms/string/","title":"String","text":"<p><code>String</code> is the head for the atomic string type.</p> <p><code>Attributes[String] := {Protected}</code></p>"},{"location":"builtin/atoms/string/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= \"Hello\"\nOut[1]= \"Hello\"\n</code></pre> <pre><code>In[2]:= \"Hello\" == \"Hello\"\nOut[2]= True\n</code></pre> <pre><code>In[3]:= \"Hello\" == \"Hello world\"\nOut[3]= False\n</code></pre> <pre><code>In[4]:= Head[\"Hello\"]\nOut[4]= String\n</code></pre></p>"},{"location":"builtin/boolean/","title":"boolean documentation","text":"<p>And</p> <p>Or</p> <p>Not</p> <p>TrueQ</p> <p>BooleanQ</p> <p>AllTrue</p> <p>Boole</p>"},{"location":"builtin/boolean/alltrue/","title":"AllTrue","text":"<p><code>AllTrue[list, condition]</code> returns True if all parts of <code>list</code> satisfy <code>condition</code>.</p> <p><code>Attributes[AllTrue] := {Protected}</code></p>"},{"location":"builtin/boolean/alltrue/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= AllTrue[{1, a}, NumberQ]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= AllTrue[{1, 2}, NumberQ]\nOut[2]= True\n</code></pre></p>"},{"location":"builtin/boolean/and/","title":"And","text":"<p><code>e1 &amp;&amp; e2 &amp;&amp; ...</code> returns <code>True</code> if all expressions evaluate to <code>True</code>.</p> <p><code>Attributes[And] := {Flat, HoldAll, OneIdentity, Protected}</code></p>"},{"location":"builtin/boolean/and/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= True &amp;&amp; False\nOut[1]= False\n</code></pre> <pre><code>In[2]:= True &amp;&amp; True &amp;&amp; True\nOut[2]= True\n</code></pre></p>"},{"location":"builtin/boolean/boole/","title":"Boole","text":"<p><code>Boole[e]</code> returns 0 if <code>e</code> is False and 1 if <code>e</code> is True.</p> <p><code>Attributes[Boole] := {Listable, Protected}</code></p>"},{"location":"builtin/boolean/boole/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Boole[True]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Boole[False]\nOut[2]= 0\n</code></pre></p>"},{"location":"builtin/boolean/booleanq/","title":"BooleanQ","text":"<p><code>BooleanQ[expr]</code> returns True if <code>expr</code> is True or False, False otherwise.</p> <p><code>Attributes[BooleanQ] := {Protected}</code></p>"},{"location":"builtin/boolean/booleanq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= BooleanQ[True]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= BooleanQ[False]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= BooleanQ[1]\nOut[3]= False\n</code></pre></p>"},{"location":"builtin/boolean/not/","title":"Not","text":"<p><code>!e</code> returns <code>True</code> if <code>e</code> is <code>False</code> and <code>False</code> if <code>e</code> is <code>True</code>.</p> <p><code>Attributes[Not] := {Protected}</code></p>"},{"location":"builtin/boolean/not/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Not[True]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= Not[False]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= Not[a]\nOut[3]= Not[a]\n</code></pre> <pre><code>In[4]:= Not[Not[a]]\nOut[4]= a\n</code></pre></p>"},{"location":"builtin/boolean/or/","title":"Or","text":"<p><code>e1 || e2 || ...</code> returns <code>True</code> if any expressions evaluate to <code>True</code>.</p> <p><code>Attributes[Or] := {Flat, HoldAll, OneIdentity, Protected}</code></p>"},{"location":"builtin/boolean/or/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= True || False\nOut[1]= True\n</code></pre> <pre><code>In[2]:= False || False || False\nOut[2]= False\n</code></pre></p>"},{"location":"builtin/boolean/trueq/","title":"TrueQ","text":"<p><code>TrueQ[expr]</code> returns True if <code>expr</code> is True, False otherwise.</p> <p><code>Attributes[TrueQ] := {Protected}</code></p>"},{"location":"builtin/boolean/trueq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= TrueQ[True]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= TrueQ[False]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= TrueQ[1]\nOut[3]= False\n</code></pre></p>"},{"location":"builtin/calculus/","title":"calculus documentation","text":"<p>D</p> <p>Grad</p> <p>Integrate</p>"},{"location":"builtin/calculus/d/","title":"D","text":"<p><code>D[f, x]</code> finds the partial derivative of <code>f</code> with respect to <code>x</code>.</p> <p><code>Attributes[D] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/calculus/d/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= D[(2*x^(3)/(2))/(3) + (2*x^(5)/(2))/(5), x]\nOut[1]= Sqrt[x] + x^(3)/(2)\n</code></pre> <pre><code>In[2]:= D[Log[5*x^2], x]\nOut[2]= (2)/(x)\n</code></pre> <pre><code>In[3]:= D[Cos[Log[x]], x]\nOut[3]= (Sin[Log[x]])/(x)*-1\n</code></pre></p>"},{"location":"builtin/calculus/grad/","title":"Grad","text":"<p><code>Grad[e, {var1, var2, ...}]</code> finds the gradient of <code>e</code> with respect to the named variables.</p> <p><code>Attributes[Grad] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/calculus/grad/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Grad[Cos[x + 2*y], {x, y}]\nOut[1]= {Sin[x + 2*y]*-1, -2*Sin[x + 2*y]}\n</code></pre>"},{"location":"builtin/calculus/integrate/","title":"Integrate","text":"<p><code>Integrate[f, x]</code> finds the indefinite integral of <code>f</code> with respect to <code>x</code>.</p> <p>!!! warning \"Under development\"     This function is under development, and as such will be incomplete and inaccurate.</p> <p><code>Attributes[Integrate] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/calculus/integrate/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= LoadRubiBundledSnapshot[]\nOut[1]= Null\n</code></pre> <pre><code>In[2]:= Integrate[x^(2)/(3) + 3*x + 2, x]\nOut[2]= 2*x + (3*x^(5)/(3))/(5) + (3*x^2)/(2)\n</code></pre> <pre><code>In[3]:= Integrate[Integrate[Sin[x] + Log[x], x], x]\nOut[3]= ((3*x^2))/(4)*-1 + (1)/(2)*x^2*Log[x] + Sin[x]*-1\n</code></pre> <pre><code>In[4]:= Integrate[x^2, {x, 0, 1}]\nOut[4]= (1)/(3)\n</code></pre> <pre><code>In[5]:= ((Integrate[x^2, {x, 0.5, 1.}] + 0.291667*-1)) &lt; (1e-05.)\nOut[5]= True\n</code></pre> <pre><code>In[6]:= Integrate[E^(3*x), x]\nOut[6]= (E^(3*x))/(3)\n</code></pre> <pre><code>In[7]:= Integrate[x^(a + b), x]\nOut[7]= (x^(1 + a + b))/(1 + a + b)\n</code></pre> <pre><code>In[8]:= Integrate[x^2, {x, 0, n}]\nOut[8]= (n^3)/(3)\n</code></pre> <pre><code>In[9]:= Integrate[x^2, {x, 0, x}]\nOut[9]= (x^3)/(3)\n</code></pre></p>"},{"location":"builtin/combinatorics/","title":"combinatorics documentation","text":"<p>IntegerPartitions</p> <p>Permutations</p> <p>Multinomial</p> <p>Factorial</p> <p>Tuples</p>"},{"location":"builtin/combinatorics/factorial/","title":"Factorial","text":"<p><code>n!</code> returns the factorial of <code>n</code>.</p> <p><code>Attributes[Factorial] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/combinatorics/factorial/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Factorial[20]\nOut[1]= 2432902008176640000\n</code></pre> <pre><code>In[2]:= Factorial[5]\nOut[2]= 120\n</code></pre></p>"},{"location":"builtin/combinatorics/factorial/#further-examples","title":"Further examples","text":"<p><pre><code>In[1]:= Factorial[0]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Factorial[-1]\nOut[2]= ComplexInfinity\n</code></pre></p>"},{"location":"builtin/combinatorics/integerpartitions/","title":"IntegerPartitions","text":"<p><code>IntegerPartitions[n]</code> lists the possible ways to partition <code>n</code> into smaller integers.</p> <p><code>IntegerPartitions[n, k]</code> lists the possible ways to partition <code>n</code> into smaller integers, using up to <code>k</code> elements.</p> <p><code>Attributes[IntegerPartitions] := {Protected}</code></p>"},{"location":"builtin/combinatorics/integerpartitions/#simple-examples","title":"Simple examples","text":"<p>Find the partitions of 4: <pre><code>In[1]:= IntegerPartitions[4]\nOut[1]= {{4}, {3, 1}, {2, 2}, {2, 1, 1}, {1, 1, 1, 1}}\n</code></pre> Find the partitions of 10, using a maximum of k = 2 integers: <pre><code>In[2]:= IntegerPartitions[10, 2]\nOut[2]= {{10}, {9, 1}, {8, 2}, {7, 3}, {6, 4}, {5, 5}}\n</code></pre></p>"},{"location":"builtin/combinatorics/integerpartitions/#further-examples","title":"Further examples","text":"<p>The partitions of zero is a nested empty List: <pre><code>In[1]:= IntegerPartitions[0]\nOut[1]= {{}}\n</code></pre></p>"},{"location":"builtin/combinatorics/multinomial/","title":"Multinomial","text":"<p><code>Multinomial[n1, n2, ...]</code> gives the multinomial coefficient for the given term.</p> <p><code>Attributes[Multinomial] := {Listable, NumericFunction, Orderless, Protected, ReadProtected}</code></p>"},{"location":"builtin/combinatorics/multinomial/#simple-examples","title":"Simple examples","text":"<p>Find the multinomial coefficient for the 1, 3, 1 term: <pre><code>In[1]:= Multinomial[1, 3, 1]\nOut[1]= 20\n</code></pre> <code>Multinomial</code> handles symbolic arguments: <pre><code>In[2]:= Multinomial[1, k, 1]\nOut[2]= (Factorial[k + 2])/(Factorial[k])\n</code></pre></p>"},{"location":"builtin/combinatorics/permutations/","title":"Permutations","text":"<p><code>Permutations[list]</code> lists the possible permutations for a given list.</p> <p><code>Attributes[Permutations] := {Protected}</code></p>"},{"location":"builtin/combinatorics/permutations/#simple-examples","title":"Simple examples","text":"<p>Find the permutations of <code>{1, 2, 3}</code>: <pre><code>In[1]:= Permutations[Range[3]]\nOut[1]= {{1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}}\n</code></pre> <code>Permutations</code> ignores duplicates: <pre><code>In[2]:= Permutations[{1, 2, 2}]\nOut[2]= {{1, 2, 2}, {2, 1, 2}, {2, 2, 1}}\n</code></pre></p>"},{"location":"builtin/combinatorics/tuples/","title":"Tuples","text":"<p><code>Tuples[list, n]</code> all possible tuples of <code>list</code> of length <code>n</code>.</p> <p><code>Attributes[Tuples] := {Protected}</code></p>"},{"location":"builtin/combinatorics/tuples/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Tuples[Range[1, 3], 2]\nOut[1]= {{1, 1}, {1, 2}, {1, 3}, {2, 1}, {2, 2}, {2, 3}, {3, 1}, {3, 2}, {3, 3}}\n</code></pre>"},{"location":"builtin/comparison/","title":"comparison documentation","text":"<p>Equal</p> <p>Unequal</p> <p>SameQ</p> <p>UnsameQ</p> <p>AtomQ</p> <p>NumberQ</p> <p>NumericQ</p> <p>Less</p> <p>Greater</p> <p>LessEqual</p> <p>GreaterEqual</p> <p>Positive</p> <p>Negative</p> <p>Max</p> <p>Min</p> <p>PossibleZeroQ</p> <p>MinMax</p> <p>Element</p> <p>Inequality</p>"},{"location":"builtin/comparison/atomq/","title":"AtomQ","text":"<p><code>AtomQ[expr]</code> returns True if <code>expr</code> is an atomic type, and False if <code>expr</code> is a full expression.</p> <p><code>Attributes[AtomQ] := {Protected}</code></p>"},{"location":"builtin/comparison/atomq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= AtomQ[\"hello\"]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= AtomQ[(5)/(3)]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= AtomQ[hello]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= AtomQ[(a)/(b)]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= AtomQ[bar[x]]\nOut[5]= False\n</code></pre></p>"},{"location":"builtin/comparison/element/","title":"Element","text":"<p><code>Element[i, s]</code> checks if <code>i</code> is an element of <code>s</code>.</p> <p><code>Attributes[Element] := {Protected}</code></p>"},{"location":"builtin/comparison/element/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Element[-1, Integers]\nOut[1]= True\n</code></pre>"},{"location":"builtin/comparison/equal/","title":"Equal","text":"<p><code>lhs == rhs</code> evaluates to True or False if equality or inequality is known.</p> <p><code>Attributes[Equal] := {Protected}</code></p>"},{"location":"builtin/comparison/equal/#simple-examples","title":"Simple examples","text":"<p>Expressions known to be equal will evaluate to True: <pre><code>In[1]:= 9*x==x*9\nOut[1]= True\n</code></pre> Sometimes expressions may or may not be equal, or Expreduce does not know how to test for equality. In these cases, the statement will remain unevaluated: <pre><code>In[2]:= 9*x==x*10\nOut[2]= (9*x == 10*x)\n</code></pre> Equal considers Integers and Reals that are close enough to be equal: <pre><code>In[3]:= tmp=5\nOut[3]= 5\n</code></pre> <pre><code>In[4]:= tmp==5\nOut[4]= True\n</code></pre> <pre><code>In[5]:= tmp==5.\nOut[5]= True\n</code></pre> <pre><code>In[6]:= tmp==5.00000\nOut[6]= True\n</code></pre> Equal can test for Rational equality: <pre><code>In[7]:= 4/3==3/2\nOut[7]= False\n</code></pre> <pre><code>In[8]:= 4/3==8/6\nOut[8]= True\n</code></pre></p>"},{"location":"builtin/comparison/equal/#further-examples","title":"Further examples","text":"<p><pre><code>In[1]:= If[xx == 2, yy, zz] == If[xx == 2, yy, zz]\nOut[1]= True\n</code></pre> Equal does not match patterns: <pre><code>In[2]:= {1, 2, 3} == _List\nOut[2]= {1, 2, 3} == _List\n</code></pre> This functionality is reserved for MatchQ: <pre><code>In[3]:= MatchQ[{1, 2, 3}, _List]\nOut[3]= True\n</code></pre></p>"},{"location":"builtin/comparison/greater/","title":"Greater","text":"<p><code>a &gt; b</code> returns True if <code>a</code> is greater than <code>b</code>.</p> <p><code>Attributes[Greater] := {Protected}</code></p>"},{"location":"builtin/comparison/greater/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (a) &gt; (b)\nOut[1]= (a) &gt; (b)\n</code></pre> <pre><code>In[2]:= (1) &gt; (2)\nOut[2]= False\n</code></pre> <pre><code>In[3]:= (3) &gt; (5.5)\nOut[3]= False\n</code></pre> <pre><code>In[4]:= (5.5) &gt; (3)\nOut[4]= True\n</code></pre> <pre><code>In[5]:= (3) &gt; (3)\nOut[5]= False\n</code></pre> <pre><code>In[6]:= (3) &gt; (2) &gt; (1)\nOut[6]= True\n</code></pre></p>"},{"location":"builtin/comparison/greaterequal/","title":"GreaterEqual","text":"<p><code>a &gt;= b</code> returns True if <code>a</code> is greater than or equal to <code>b</code>.</p> <p><code>Attributes[GreaterEqual] := {Protected}</code></p>"},{"location":"builtin/comparison/greaterequal/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (a) &gt;= (b)\nOut[1]= (a) &gt;= (b)\n</code></pre> <pre><code>In[2]:= (1) &gt;= (2)\nOut[2]= False\n</code></pre> <pre><code>In[3]:= (3) &gt;= (5.5)\nOut[3]= False\n</code></pre> <pre><code>In[4]:= (5.5) &gt;= (3)\nOut[4]= True\n</code></pre> <pre><code>In[5]:= (3) &gt;= (3)\nOut[5]= True\n</code></pre> <pre><code>In[6]:= (3) &gt;= (2) &gt;= (2) &gt;= (1)\nOut[6]= True\n</code></pre></p>"},{"location":"builtin/comparison/inequality/","title":"Inequality","text":"<p><code>Attributes[Inequality] := {Protected}</code></p>"},{"location":"builtin/comparison/inequality/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Inequality[Pi*-1, Less, 0, LessEqual, Pi]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= Inequality[Pi*-1, Less, 0, LessEqual, a]\nOut[2]= (0) &lt;= (a)\n</code></pre></p>"},{"location":"builtin/comparison/less/","title":"Less","text":"<p><code>a &lt; b</code> returns True if <code>a</code> is less than <code>b</code>.</p> <p><code>Attributes[Less] := {Protected}</code></p>"},{"location":"builtin/comparison/less/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (a) &lt; (b)\nOut[1]= (a) &lt; (b)\n</code></pre> <pre><code>In[2]:= (1) &lt; (2)\nOut[2]= True\n</code></pre> <pre><code>In[3]:= (3) &lt; (5.5)\nOut[3]= True\n</code></pre> <pre><code>In[4]:= (5.5) &lt; (3)\nOut[4]= False\n</code></pre> <pre><code>In[5]:= (3) &lt; (3)\nOut[5]= False\n</code></pre> <pre><code>In[6]:= (1) &lt; (2) &lt; (3)\nOut[6]= True\n</code></pre></p>"},{"location":"builtin/comparison/lessequal/","title":"LessEqual","text":"<p><code>a &lt;= b</code> returns True if <code>a</code> is less than or equal to <code>b</code>.</p> <p><code>Attributes[LessEqual] := {Protected}</code></p>"},{"location":"builtin/comparison/lessequal/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (a) &lt;= (b)\nOut[1]= (a) &lt;= (b)\n</code></pre> <pre><code>In[2]:= (1) &lt;= (2)\nOut[2]= True\n</code></pre> <pre><code>In[3]:= (3) &lt;= (5.5)\nOut[3]= True\n</code></pre> <pre><code>In[4]:= (5.5) &lt;= (3)\nOut[4]= False\n</code></pre> <pre><code>In[5]:= (3) &lt;= (3)\nOut[5]= True\n</code></pre> <pre><code>In[6]:= (1) &lt;= (2) &lt;= (3)\nOut[6]= True\n</code></pre></p>"},{"location":"builtin/comparison/max/","title":"Max","text":"<p><code>Max[e1, e2, ...]</code> the maximum of the expressions.</p> <p><code>Attributes[Max] := {Flat, NumericFunction, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/comparison/max/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Max[1, 2, 3]\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= Max[1, a, 3]\nOut[2]= Max[3, a]\n</code></pre></p>"},{"location":"builtin/comparison/min/","title":"Min","text":"<p><code>Min[e1, e2, ...]</code> the maximum of the expressions.</p> <p><code>Attributes[Min] := {Flat, NumericFunction, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/comparison/min/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Min[1, 2, 3]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Min[1, a, 3]\nOut[2]= Min[1, a]\n</code></pre></p>"},{"location":"builtin/comparison/minmax/","title":"MinMax","text":"<p><code>MinMax[l]</code> returns <code>{Min[l], Max[l]}</code>.</p> <p><code>Attributes[MinMax] := {Protected}</code></p>"},{"location":"builtin/comparison/minmax/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= MinMax[Range[5]]\nOut[1]= {1, 5}\n</code></pre>"},{"location":"builtin/comparison/negative/","title":"Negative","text":"<p><code>Negative[x]</code> returns <code>True</code> if <code>x</code> is positive.</p> <p><code>Attributes[Negative] := {Listable, Protected}</code></p>"},{"location":"builtin/comparison/negative/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Map[Negative, {1, 0, -1, a}]\nOut[1]= {False, False, True, Negative[a]}\n</code></pre>"},{"location":"builtin/comparison/numberq/","title":"NumberQ","text":"<p><code>NumberQ[expr]</code> returns True if <code>expr</code> is numeric, otherwise False.</p> <p><code>Attributes[NumberQ] := {Protected}</code></p>"},{"location":"builtin/comparison/numberq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= NumberQ[2]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= NumberQ[2.2]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= NumberQ[Rational[5, 2]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= NumberQ[Infinity]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= NumberQ[Sqrt[2]]\nOut[5]= False\n</code></pre> <pre><code>In[6]:= NumberQ[randomvar]\nOut[6]= False\n</code></pre> <pre><code>In[7]:= NumberQ[\"hello\"]\nOut[7]= False\n</code></pre></p>"},{"location":"builtin/comparison/numericq/","title":"NumericQ","text":"<p><code>NumericQ[expr]</code> returns <code>True</code> if <code>expr</code> is a numeric quantity, <code>False</code> otherwise.</p> <p><code>Attributes[NumericQ] := {Protected}</code></p>"},{"location":"builtin/comparison/numericq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= NumericQ[5]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= NumericQ[a]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= NumericQ[Sin[a]]\nOut[3]= False\n</code></pre> <pre><code>In[4]:= NumericQ[Sin[2]]\nOut[4]= True\n</code></pre></p>"},{"location":"builtin/comparison/positive/","title":"Positive","text":"<p><code>Positive[x]</code> returns <code>True</code> if <code>x</code> is positive.</p> <p><code>Attributes[Positive] := {Listable, Protected}</code></p>"},{"location":"builtin/comparison/positive/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Map[Positive, {1, 0, -1, a}]\nOut[1]= {True, False, False, Positive[a]}\n</code></pre>"},{"location":"builtin/comparison/possiblezeroq/","title":"PossibleZeroQ","text":"<p><code>PossibleZeroQ[e]</code> returns True if <code>e</code> is most likely equivalent to zero.</p> <p><code>Attributes[PossibleZeroQ] := {Listable, Protected}</code></p>"},{"location":"builtin/comparison/possiblezeroq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PossibleZeroQ[a + a*-1]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= PossibleZeroQ[a + b*-1]\nOut[2]= False\n</code></pre></p>"},{"location":"builtin/comparison/sameq/","title":"SameQ","text":"<p><code>lhs === rhs</code> evaluates to True if <code>lhs</code> and <code>rhs</code> are identical after evaluation, False otherwise.</p> <p><code>Attributes[SameQ] := {Protected}</code></p>"},{"location":"builtin/comparison/sameq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= a===a\nOut[1]= True\n</code></pre> <pre><code>In[2]:= 5 === 5\nOut[2]= True\n</code></pre> Unlike Equal, SameQ does not forgive differences between Integers and Reals: <pre><code>In[3]:= 5 === 5.\nOut[3]= False\n</code></pre> SameQ considers the arguments of all expressions and subexpressions: <pre><code>In[4]:= foo[x == 2, y, x] === foo[x == 2, y, x]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= foo[x == 2, y, x] === foo[x == 2., y, x]\nOut[5]= False\n</code></pre></p>"},{"location":"builtin/comparison/sameq/#further-examples","title":"Further examples","text":"<p>SameQ does not match patterns: <pre><code>In[1]:= {1, 2, 3} === _List\nOut[1]= False\n</code></pre> This functionality is reserved for MatchQ: <pre><code>In[2]:= MatchQ[{1, 2, 3}, _List]\nOut[2]= True\n</code></pre></p>"},{"location":"builtin/comparison/unequal/","title":"Unequal","text":"<p><code>lhs != rhs</code> evaluates to True if inequality is known or False if equality is known.</p> <p><code>Attributes[Unequal] := {Protected}</code></p>"},{"location":"builtin/comparison/unequal/#simple-examples","title":"Simple examples","text":"<p>Expressions known to be unequal will evaluate to True: <pre><code>In[1]:= 9 != 8\nOut[1]= True\n</code></pre> Sometimes expressions may or may not be unequal, or Expreduce does not know how to test for inequality. In these cases, the statement will remain unevaluated: <pre><code>In[2]:= 9*x != x*10\nOut[2]= ((9*x) != (10*x))\n</code></pre> Unequal considers Integers and Reals that are close enough to be equal: <pre><code>In[3]:= tmp=5\nOut[3]= 5\n</code></pre> <pre><code>In[4]:= tmp != 5\nOut[4]= False\n</code></pre> <pre><code>In[5]:= tmp != 5.\nOut[5]= False\n</code></pre> <pre><code>In[6]:= tmp != 5.00000\nOut[6]= False\n</code></pre> Unequal can test for Rational inequality: <pre><code>In[7]:= 4/3 != 3/2\nOut[7]= True\n</code></pre> <pre><code>In[8]:= 4/3 != 8/6\nOut[8]= False\n</code></pre></p>"},{"location":"builtin/comparison/unsameq/","title":"UnsameQ","text":"<p><code>lhs =!= rhs</code> evaluates to False if <code>lhs</code> and <code>rhs</code> are identical after evaluation, True otherwise.</p> <p><code>Attributes[UnsameQ] := {Protected}</code></p>"},{"location":"builtin/comparison/unsameq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= a=!=a\nOut[1]= False\n</code></pre> <pre><code>In[2]:= 5 =!= 5\nOut[2]= False\n</code></pre> <pre><code>In[3]:= a=!=b\nOut[3]= True\n</code></pre></p>"},{"location":"builtin/equationdata/","title":"equationdata documentation","text":""},{"location":"builtin/expression/","title":"expression documentation","text":"<p>Head</p> <p>Depth</p> <p>Length</p> <p>Sequence</p> <p>Evaluate</p> <p>Hold</p> <p>HoldForm</p> <p>Flatten</p> <p>LeafCount</p> <p>ExpreduceLeafCountSimplify</p> <p>Unevaluated</p> <p>HoldComplete</p>"},{"location":"builtin/expression/depth/","title":"Depth","text":"<p><code>Depth[expr]</code> returns the depth of <code>expr</code>.</p> <p><code>Attributes[Depth] := {Protected}</code></p>"},{"location":"builtin/expression/depth/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Depth[foo]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Depth[{foo}]\nOut[2]= 2\n</code></pre> <pre><code>In[3]:= Depth[bar[foo, bar]]\nOut[3]= 2\n</code></pre> <pre><code>In[4]:= Depth[foo[foo[]]]\nOut[4]= 3\n</code></pre> <pre><code>In[5]:= Depth[3]\nOut[5]= 1\n</code></pre> <pre><code>In[6]:= Depth[3.5]\nOut[6]= 1\n</code></pre> <pre><code>In[7]:= Depth[(3)/(5)]\nOut[7]= 1\n</code></pre> <pre><code>In[8]:= Depth[foo[{{{}}}][]]\nOut[8]= 2\n</code></pre></p>"},{"location":"builtin/expression/evaluate/","title":"Evaluate","text":"<p><code>Evaluate[expr]</code> evaluates to an evaluated form of <code>expr</code>, even when under hold conditions.</p> <p><code>Attributes[Evaluate] := {Protected}</code></p>"},{"location":"builtin/expression/evaluate/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Hold[Evaluate[1 + 3], 2 + 1]\nOut[1]= Hold[4, 2 + 1]\n</code></pre> <pre><code>In[2]:= Hold[foo[Evaluate[1 + 1]]]\nOut[2]= Hold[foo[Evaluate[1 + 1]]]\n</code></pre> <pre><code>In[3]:= Hold[Evaluate[1 + 3, 5 + 2], 2 + 1]\nOut[3]= Hold[4, 7, 2 + 1]\n</code></pre> <pre><code>In[4]:= Hold[Sequence[1 + 3, 5 + 2], 2 + 1]\nOut[4]= Hold[1 + 3, 5 + 2, 2 + 1]\n</code></pre></p>"},{"location":"builtin/expression/expreduceleafcountsimplify/","title":"ExpreduceLeafCountSimplify","text":"<p><code>Attributes[ExpreduceLeafCountSimplify] := {Protected}</code></p>"},{"location":"builtin/expression/flatten/","title":"Flatten","text":"<p><code>Flatten[list]</code> flattens out lists in <code>list</code>.</p> <p><code>Attributes[Flatten] := {Protected}</code></p>"},{"location":"builtin/expression/flatten/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Flatten[1]\nOut[1]= Flatten[1]\n</code></pre> Input must be nonatomic: <pre><code>In[2]:= Flatten[{1}]\nOut[2]= {1}\n</code></pre> <pre><code>In[3]:= Flatten[{{{{1}}}}]\nOut[3]= {1}\n</code></pre> <pre><code>In[4]:= Flatten[{{{{1}, 2}}, 3}]\nOut[4]= {1, 2, 3}\n</code></pre> <pre><code>In[5]:= Flatten[{{{{1}, 2}}, 3, 4}]\nOut[5]= {1, 2, 3, 4}\n</code></pre> <pre><code>In[6]:= Flatten[{-1, {{{1}, 2}}, 3, 4}]\nOut[6]= {-1, 1, 2, 3, 4}\n</code></pre> A level of zero means no change: <pre><code>In[7]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, 0]\nOut[7]= {-1, {{{1}, 2}}, 3, 4}\n</code></pre> <pre><code>In[8]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, 1]\nOut[8]= {-1, {{1}, 2}, 3, 4}\n</code></pre> <pre><code>In[9]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, 2]\nOut[9]= {-1, {1}, 2, 3, 4}\n</code></pre> <pre><code>In[10]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, 3]\nOut[10]= {-1, 1, 2, 3, 4}\n</code></pre> <pre><code>In[11]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, 4]\nOut[11]= {-1, 1, 2, 3, 4}\n</code></pre> <pre><code>In[12]:= Flatten[{-1, {{{1}, 2}}, 3, 4}, a]\nOut[12]= Flatten[{-1, {{{1}, 2}}, 3, 4}, a]\n</code></pre> <pre><code>In[13]:= Flatten[{-1, {foo[{{1}, 2}]}, 3, 4}, 999]\nOut[13]= {-1, foo[{{1}, 2}], 3, 4}\n</code></pre> <pre><code>In[14]:= Flatten[{-1, {foo[{{1}, 2}]}, 3, 4}, 999]\nOut[14]= {-1, foo[{{1}, 2}], 3, 4}\n</code></pre> <pre><code>In[15]:= Flatten[{-1, {1[{{1}, 2}]}, 3, 4}, 999]\nOut[15]= {-1, 1[{{1}, 2}], 3, 4}\n</code></pre></p>"},{"location":"builtin/expression/head/","title":"Head","text":"<p><code>Head[expr]</code> returns the head of the expression.</p> <p><code>Attributes[Head] := {Protected}</code></p>"},{"location":"builtin/expression/head/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Head[f[x]]\nOut[1]= f\n</code></pre> <pre><code>In[2]:= Head[x]\nOut[2]= Symbol\n</code></pre> <pre><code>In[3]:= Head[{x}]\nOut[3]= List\n</code></pre> <pre><code>In[4]:= Head[a + b]\nOut[4]= Plus\n</code></pre> <pre><code>In[5]:= Head[1]\nOut[5]= Integer\n</code></pre> <pre><code>In[6]:= Head[1.]\nOut[6]= Real\n</code></pre> <pre><code>In[7]:= Head[(2)/(7)]\nOut[7]= Rational\n</code></pre> <pre><code>In[8]:= Head[(1)/(7)]\nOut[8]= Rational\n</code></pre> <pre><code>In[9]:= Head[\"1\"]\nOut[9]= String\n</code></pre> <pre><code>In[10]:= Head[Head[a + b[x]]]\nOut[10]= Plus\n</code></pre></p>"},{"location":"builtin/expression/hold/","title":"Hold","text":"<p><code>Hold[expr]</code> prevents automatic evaluation of <code>expr</code>.</p> <p><code>Attributes[Hold] := {HoldAll, Protected}</code></p>"},{"location":"builtin/expression/hold/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Hold[Power[5, 3]]\nOut[1]= Hold[5^3]\n</code></pre> <pre><code>In[2]:= Hold[Power[5., 3.]]\nOut[2]= Hold[5.^3.]\n</code></pre></p>"},{"location":"builtin/expression/holdcomplete/","title":"HoldComplete","text":"<p><code>HoldComplete[e1, e2, ...]</code> holds evaluation of its arguments, even evaluation that would take place under <code>Hold</code>.</p> <p><code>Attributes[HoldComplete] := {HoldAllComplete, Protected}</code></p>"},{"location":"builtin/expression/holdcomplete/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= HoldComplete[Evaluate[a + a], 2 + 2, Sequence[a, b]]\nOut[1]= HoldComplete[Evaluate[a + a], 2 + 2, Sequence[a, b]]\n</code></pre> <pre><code>In[2]:= Length[HoldComplete[Evaluate[a + a], 2 + 2, Sequence[a, b]]]\nOut[2]= 3\n</code></pre></p>"},{"location":"builtin/expression/holdform/","title":"HoldForm","text":"<p><code>HoldForm[expr]</code> prevents automatic evaluation of <code>expr</code>. Prints as <code>expr</code>.</p> <p><code>Attributes[HoldForm] := {HoldAll, Protected}</code></p>"},{"location":"builtin/expression/holdform/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= HoldForm[Power[5, 3]]\nOut[1]= (5^3)\n</code></pre> <pre><code>In[2]:= HoldForm[Power[5., 3.]]\nOut[2]= (5.^3.)\n</code></pre></p>"},{"location":"builtin/expression/leafcount/","title":"LeafCount","text":"<p><code>LeafCount[e]</code> returns the count of leaves in <code>e</code>.</p> <p><code>Attributes[LeafCount] := {Protected}</code></p>"},{"location":"builtin/expression/leafcount/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= LeafCount[a + b]\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= LeafCount[a^2 + b^Factorial[c]]\nOut[2]= 8\n</code></pre> <pre><code>In[3]:= LeafCount[a]\nOut[3]= 1\n</code></pre></p>"},{"location":"builtin/expression/length/","title":"Length","text":"<p><code>Length[expr]</code> returns the length of <code>expr</code>.</p> <p><code>Attributes[Length] := {Protected}</code></p>"},{"location":"builtin/expression/length/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Length[{1, 2, 3, 4}]\nOut[1]= 4\n</code></pre> <pre><code>In[2]:= Length[{}]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= Length[{5}]\nOut[3]= 1\n</code></pre></p>"},{"location":"builtin/expression/length/#further-examples","title":"Further examples","text":"<p><code>expr</code> need not have a <code>List</code> head: <pre><code>In[1]:= Length[foo[1, 2]]\nOut[1]= 2\n</code></pre> The length of an atomic expression is zero: <pre><code>In[2]:= Length[a]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= Length[2.5]\nOut[3]= 0\n</code></pre> <pre><code>In[4]:= Length[\"hello\"]\nOut[4]= 0\n</code></pre></p>"},{"location":"builtin/expression/sequence/","title":"Sequence","text":"<p><code>Sequence[e1, e2, ...]</code> holds a list of expressions to be automatically inserted into another function.</p> <p><code>Attributes[Sequence] := {Protected}</code></p>"},{"location":"builtin/expression/sequence/#simple-examples","title":"Simple examples","text":"<p>Sequence arguments are automatically inserted into the parent functions: <pre><code>In[1]:= foo[a, Sequence[2, 3]]\nOut[1]= foo[a, 2, 3]\n</code></pre> Outside of the context of functions, Sequence objects do not merge: <pre><code>In[2]:= Sequence[2, 3]\nOut[2]= Sequence[2, 3]\n</code></pre> <pre><code>In[3]:= Sequence[2, 3] + Sequence[5, 4]\nOut[3]= 14\n</code></pre> <pre><code>In[4]:= Sequence[2, 3]*Sequence[5, 4]\nOut[4]= 120\n</code></pre></p>"},{"location":"builtin/expression/sequence/#further-examples","title":"Further examples","text":"<p>Empty <code>Sequence[]</code> objects effectively disappear: <pre><code>In[1]:= foo[Sequence[]]\nOut[1]= foo[]\n</code></pre></p>"},{"location":"builtin/expression/unevaluated/","title":"Unevaluated","text":"<p><code>Unevaluated[e]</code> do not evaluate <code>e</code> in an expression, but treat as <code>e</code>.</p> <p><code>Attributes[Unevaluated] := {HoldAllComplete, Protected}</code></p>"},{"location":"builtin/expression/unevaluated/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Apply[List, Unevaluated[1 + 2]]\nOut[1]= {1, 2}\n</code></pre>"},{"location":"builtin/flowcontrol/","title":"flowcontrol documentation","text":"<p>If</p> <p>While</p> <p>CompoundExpression</p> <p>Return</p> <p>Which</p> <p>Switch</p> <p>With</p> <p>Do</p> <p>For</p>"},{"location":"builtin/flowcontrol/compoundexpression/","title":"CompoundExpression","text":"<p><code>CompoundExpression[e1, e2, ...]</code> evaluates each expression in order and returns the result of the last one.</p> <p><code>Attributes[CompoundExpression] := {HoldAll, Protected, ReadProtected}</code></p>"},{"location":"builtin/flowcontrol/compoundexpression/#simple-examples","title":"Simple examples","text":"<p>The result of the first expression is not included in the output, but the result of the second is: <pre><code>In[1]:= CompoundExpression[a = 5, a + 2*-1]\nOut[1]= 3\n</code></pre> Including a trailing semicolon causes the expression to return <code>Null</code>: <pre><code>In[2]:= CompoundExpression[a = 5, a + 2*-1, Null]\nOut[2]= Null\n</code></pre></p>"},{"location":"builtin/flowcontrol/do/","title":"Do","text":"<p><code>Do[expr, n]</code> evaluates <code>expr</code> <code>n</code> times.</p> <p><code>Table[expr, {sym, n}]</code> evaluates <code>expr</code> with <code>sym</code> = 1 to <code>n</code>.</p> <p><code>Table[expr, {sym, m, n}]</code> evaluates <code>expr</code> with <code>sym</code> = <code>m</code> to <code>n</code>.</p> <p><code>Attributes[Do] := {HoldAll, Protected}</code></p>"},{"location":"builtin/flowcontrol/do/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Catch[CompoundExpression[Do[If[(a) &gt; (6), Throw[a]], {a, 10}], False]]\nOut[1]= 7\n</code></pre>"},{"location":"builtin/flowcontrol/for/","title":"For","text":"<p><code>For[beg, cond, incr, expr]</code> runs a for loop.</p> <p><code>Attributes[For] := {HoldAll, Protected}</code></p>"},{"location":"builtin/flowcontrol/for/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= CompoundExpression[For[n = 1, (n) &lt; (1000), Increment[n], If[PrimeQ[n] &amp;&amp; ((n) &gt; (7)), Return[]]], n]\nOut[1]= 11\n</code></pre>"},{"location":"builtin/flowcontrol/if/","title":"If","text":"<p><code>If[cond, iftrue, iffalse]</code> returns <code>iftrue</code> if <code>cond</code> is True, and <code>iffalse</code> if <code>cond</code> is False.</p> <p><code>Attributes[If] := {HoldRest, Protected}</code></p>"},{"location":"builtin/flowcontrol/if/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= x=9\nOut[1]= 9\n</code></pre> <pre><code>In[2]:= If[x+3==12, x*2, x+3]\nOut[2]= 18\n</code></pre> <pre><code>In[3]:= If[x+3==11, x*2, x+3]\nOut[3]= 12\n</code></pre></p>"},{"location":"builtin/flowcontrol/if/#further-examples","title":"Further examples","text":"<p>Undefined conditions leave the statement unevaluated. <pre><code>In[1]:= If[undefined, a, b]\nOut[1]= If[undefined, a, b]\n</code></pre></p>"},{"location":"builtin/flowcontrol/return/","title":"Return","text":"<p><code>Return[x]</code> returns <code>x</code> immediately.</p> <p><code>Attributes[Return] := {Protected}</code></p>"},{"location":"builtin/flowcontrol/return/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= CompoundExpression[myreturnfunc := CompoundExpression[Return[x], hello], myreturnfunc]\nOut[1]= x\n</code></pre> <pre><code>In[2]:= CompoundExpression[ret[x_] := CompoundExpression[Return[x], hello], ret[3]]\nOut[2]= 3\n</code></pre> <pre><code>In[3]:= CompoundExpression[myfoo := CompoundExpression[i = 1, While[(i) &lt; (5), CompoundExpression[If[i === 3, Return[i]], i = i + 1]]], myfoo]\nOut[3]= 3\n</code></pre> <pre><code>In[4]:= Return[3]\nOut[4]= Return[3]\n</code></pre> <pre><code>In[5]:= CompoundExpression[retother := CompoundExpression[Return[], hello], retother]\nOut[5]= Null\n</code></pre></p>"},{"location":"builtin/flowcontrol/switch/","title":"Switch","text":"<p><code>Switch[e, case1, val1, case2, val2, ...]</code> attempts to match <code>e</code> with the cases in order. If a match is found, returns the corresponding value.</p> <p><code>Attributes[Switch] := {HoldRest, Protected, ReadProtected}</code></p>"},{"location":"builtin/flowcontrol/switch/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Switch[z, _, b, z, c]\nOut[1]= b\n</code></pre> <pre><code>In[2]:= Switch[z, k_Symbol, k]\nOut[2]= k\n</code></pre> <pre><code>In[3]:= Switch[z, 1]\nOut[3]= Switch[z, 1]\n</code></pre> <pre><code>In[4]:= Switch[z, d, b, l, c]\nOut[4]= Switch[z, d, b, l, c]\n</code></pre></p>"},{"location":"builtin/flowcontrol/which/","title":"Which","text":"<p><code>Which[cond, res, cond, res, ...]</code> tries each <code>cond</code> in sequence and returns the corresponding result if True.</p> <p><code>Attributes[Which] := {HoldAll, Protected}</code></p>"},{"location":"builtin/flowcontrol/which/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Which[(1) &gt; (2), a, (1) &lt; (2), b]\nOut[1]= b\n</code></pre> <pre><code>In[2]:= Which[(2) &gt; (2), a, (2) &lt; (2), b]\nOut[2]= Null\n</code></pre></p>"},{"location":"builtin/flowcontrol/while/","title":"While","text":"<p><code>While[cond, body]</code> evaluates <code>cond</code>, and if it returns True, evaluates <code>body</code>. This happens repeatedly.</p> <p><code>Attributes[While] := {HoldAll, Protected}</code></p>"},{"location":"builtin/flowcontrol/while/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= a = 1\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= While[a != 5, a = a + 1]\nOut[2]= Null\n</code></pre> <pre><code>In[3]:= a\nOut[3]= 5\n</code></pre></p>"},{"location":"builtin/flowcontrol/with/","title":"With","text":"<p><code>With[{s1=v1, s2=v2, ...}, body]</code> locally replaces the specified symbols in body with their respective values.</p> <p><code>Attributes[With] := {HoldAll, Protected}</code></p>"},{"location":"builtin/flowcontrol/with/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= With[{x = 2}, {x, 3*x}]\nOut[1]= {2, 6}\n</code></pre> <pre><code>In[2]:= With[{x := 2, y := 3}, {x, 3*y}]\nOut[2]= {2, 9}\n</code></pre></p>"},{"location":"builtin/functional/","title":"functional documentation","text":"<p>Function</p> <p>Slot</p> <p>Apply</p> <p>Map</p> <p>MapIndexed</p> <p>FoldList</p> <p>Fold</p> <p>NestList</p> <p>Nest</p> <p>NestWhileList</p> <p>NestWhile</p> <p>FixedPointList</p> <p>FixedPoint</p> <p>Array</p> <p>Identity</p>"},{"location":"builtin/functional/apply/","title":"Apply","text":"<p><code>Apply[f, e]</code> (<code>f@@e</code>) replaces the head of expression <code>e</code> with <code>f</code>.</p> <p><code>Attributes[Apply] := {Protected}</code></p>"},{"location":"builtin/functional/apply/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Apply[bar, foo[syma, symb]]\nOut[1]= bar[syma, symb]\n</code></pre> <pre><code>In[2]:= Apply[bar, foo[syma, symb]]\nOut[2]= bar[syma, symb]\n</code></pre> <pre><code>In[3]:= Apply[List, syma + symb]\nOut[3]= {syma, symb}\n</code></pre> <code>Apply</code> is useful in performing aggregations on <code>List</code>s: <pre><code>In[4]:= Apply[Times, {2, 6}]\nOut[4]= 12\n</code></pre> <pre><code>In[5]:= Apply[Times, {a, b}]\nOut[5]= a*b\n</code></pre></p>"},{"location":"builtin/functional/apply/#further-examples","title":"Further examples","text":"<p><code>Apply</code> has no effect on atoms: <pre><code>In[1]:= Apply[foo, 1]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Apply[foo, bar]\nOut[2]= bar\n</code></pre></p>"},{"location":"builtin/functional/array/","title":"Array","text":"<p><code>Array[f, n]</code> creates a list of <code>f[i]</code>, with <code>i</code> = 1 to <code>n</code>.</p> <p><code>Attributes[Array] := {Protected}</code></p>"},{"location":"builtin/functional/array/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Array[f, 3]\nOut[1]= {f[1], f[2], f[3]}\n</code></pre> <pre><code>In[2]:= mytest[x_] := 5\nOut[2]= Null\n</code></pre> <pre><code>In[3]:= Array[mytest, 3]\nOut[3]= {5, 5, 5}\n</code></pre> <pre><code>In[4]:= Array[a + b, 3]\nOut[4]= {a + b[1], a + b[2], a + b[3]}\n</code></pre> <pre><code>In[5]:= Array[a, a]\nOut[5]= Array[a, a]\n</code></pre></p>"},{"location":"builtin/functional/fixedpoint/","title":"FixedPoint","text":"<p><code>FixedPoint[f, expr]</code> applies <code>f</code> to <code>expr</code> until <code>UnsameQ</code> applied to the two most recent results returns False.</p> <p><code>Attributes[FixedPoint] := {Protected}</code></p>"},{"location":"builtin/functional/fixedpoint/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= FixedPoint[Function[D[Slot[1], x]], x^3]\nOut[1]= 0\n</code></pre>"},{"location":"builtin/functional/fixedpointlist/","title":"FixedPointList","text":"<p><code>FixedPointList[f, expr]</code> applies <code>f</code> to <code>expr</code> until <code>UnsameQ</code> applied to the two most recent results returns False. It returns a list of all intermediate results.</p> <p><code>Attributes[FixedPointList] := {Protected}</code></p>"},{"location":"builtin/functional/fixedpointlist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Length[FixedPointList[Function[(Slot[1] + (3)/(Slot[1]))/(2)], 1.]]\nOut[1]= 7\n</code></pre> <pre><code>In[2]:= FixedPointList[Function[D[Slot[1], x]], x^3]\nOut[2]= {x^3, 3*x^2, 6*x, 6, 0, 0}\n</code></pre></p>"},{"location":"builtin/functional/fold/","title":"Fold","text":"<p><code>Fold[f, x, {a, b}]</code> returns <code>f[f[x, a], b]</code>, and this nesting continues for lists of arbitrary length. <code>Fold[f, {a, b, c}]</code> returns <code>Fold[f, a, {b, c}]</code>. <code>Fold[f]</code> is an operator form that can be applied to expressions such as <code>{a, b, c}</code>.</p> <p><code>Attributes[Fold] := {Protected}</code></p>"},{"location":"builtin/functional/fold/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Fold[f, 1, {2, 3}]\nOut[1]= f[f[1, 2], 3]\n</code></pre> <pre><code>In[2]:= Fold[f, {1, 2, 3}]\nOut[2]= f[f[1, 2], 3]\n</code></pre> <pre><code>In[3]:= Fold[f, e1, h[e2, e3, e4]]\nOut[3]= f[f[f[e1, e2], e3], e4]\n</code></pre> <pre><code>In[4]:= Fold[f, h, {}]\nOut[4]= h\n</code></pre></p>"},{"location":"builtin/functional/foldlist/","title":"FoldList","text":"<p>`FoldList[f, x, {a, b}] returns {x, f[x, a], f[f[x, a], b]}</p> <p><code>Attributes[FoldList] := {Protected}</code></p>"},{"location":"builtin/functional/foldlist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FoldList[f, 1, {2, 3}]\nOut[1]= {1, f[1, 2], f[f[1, 2], 3]}\n</code></pre> <pre><code>In[2]:= FoldList[f, {1, 2, 3}]\nOut[2]= {1, f[1, 2], f[f[1, 2], 3]}\n</code></pre> <pre><code>In[3]:= FoldList[f, e1, h[e2, e3, e4]]\nOut[3]= h[e1, f[e1, e2], f[f[e1, e2], e3], f[f[f[e1, e2], e3], e4]]\n</code></pre> <pre><code>In[4]:= FoldList[f, h, {}]\nOut[4]= {h}\n</code></pre></p>"},{"location":"builtin/functional/function/","title":"Function","text":"<p><code>Function[inner]</code> defines a pure function where <code>inner</code> is evaluated with <code>Slot</code> parameters.</p> <p><code>Function[x, inner]</code> defines a pure function where <code>inner</code> is evaluated a single parameter <code>x</code>.</p> <p><code>Attributes[Function] := {HoldAll, Protected}</code></p>"},{"location":"builtin/functional/function/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Function[1 + Slot[1]][x]\nOut[1]= 1 + x\n</code></pre> <pre><code>In[2]:= Function[1 + Slot[1] + 2*Slot[2]][x, y]\nOut[2]= 1 + x + 2*y\n</code></pre> <pre><code>In[3]:= Function[x, x^2][a]\nOut[3]= a^2\n</code></pre> <pre><code>In[4]:= Function[x, x^2][a, b]\nOut[4]= a^2\n</code></pre> <pre><code>In[5]:= Function[x, x^2][x]\nOut[5]= x^2\n</code></pre> <pre><code>In[6]:= Function[x, x^2][-2]\nOut[6]= 4\n</code></pre></p>"},{"location":"builtin/functional/identity/","title":"Identity","text":"<p><code>Identity[expr_]</code> returns <code>expr</code>.</p> <p><code>Attributes[Identity] := {Protected}</code></p>"},{"location":"builtin/functional/identity/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Identity[5]\nOut[1]= 5\n</code></pre> <pre><code>In[2]:= Identity[Identity[a]]\nOut[2]= a\n</code></pre></p>"},{"location":"builtin/functional/map/","title":"Map","text":"<p><code>Map[f, expr]</code> returns a new expression with the same head as <code>expr</code>, but with <code>f</code> mapped to each of the arguments. Map[f, expr, levelspec] maps f to all subexpressions that match the level specification levelspec.</p> <p><code>Attributes[Map] := {Protected}</code></p>"},{"location":"builtin/functional/map/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Map[foo, {a, b, c}]\nOut[1]= {foo[a], foo[b], foo[c]}\n</code></pre> <pre><code>In[2]:= Map[foo, {a, b, c}]\nOut[2]= {foo[a], foo[b], foo[c]}\n</code></pre> <pre><code>In[3]:= Map[Times, {2, 4, 9}]\nOut[3]= {2, 4, 9}\n</code></pre> <pre><code>In[4]:= Map[foo, {{a, b}, c}]\nOut[4]= {foo[{a, b}], foo[c]}\n</code></pre> <pre><code>In[5]:= Map[foo]\nOut[5]= Map[foo]\n</code></pre> <pre><code>In[6]:= Map[foo, foo]\nOut[6]= foo\n</code></pre> <pre><code>In[7]:= Map[foo, foo, foo]\nOut[7]= Map[foo, foo, foo]\n</code></pre> Pure functions are useful with <code>Map</code>: <pre><code>In[8]:= Map[Function[x, x^2], {2, 4}]\nOut[8]= {4, 16}\n</code></pre> <pre><code>In[9]:= Map[Function[Slot[1]^2], {2, 4}]\nOut[9]= {4, 16}\n</code></pre> <pre><code>In[10]:= f[a[f[b[f[c], f[d], f[e]]], f[l[f[g[f[h], f[j]]], f[k]]]]]\nOut[10]= Map[f, a[b[c, d, e], l[g[h, j], k]], {Infinity*-1, Infinity}]\n</code></pre> <pre><code>In[11]:= a[f[b[f[c], f[d], f[e]]], f[l[f[g[f[h], f[j]]], f[k]]]]\nOut[11]= Map[f, a[b[c, d, e], l[g[h, j], k]], Infinity]\n</code></pre> <pre><code>In[12]:= a[f[b[f[c], f[d], f[e]]], l[f[g[f[h], f[j]]], f[k]]]\nOut[12]= Map[f, a[b[c, d, e], l[g[h, j], k]], {-2, Infinity}]\n</code></pre> <pre><code>In[13]:= a[b[c, d, e], l[f[g[h, j]], k]]\nOut[13]= Map[f, a[b[c, d, e], l[g[h, j], k]], {2, -2}]\n</code></pre> <pre><code>In[14]:= a[f[b[f[c], f[d], f[e]]], f[l[f[g[h, j]], f[k]]]]\nOut[14]= Map[f, a[b[c, d, e], l[g[h, j], k]], 2]\n</code></pre> <pre><code>In[15]:= a[f[b[c, d, e]], f[l[f[g[h, j]], k]]]\nOut[15]= Map[f, a[b[c, d, e], l[g[h, j], k]], -2]\n</code></pre></p>"},{"location":"builtin/functional/mapindexed/","title":"MapIndexed","text":"<p><code>MapIndexed[f, expr]</code> returns a new expression with the same head as <code>expr</code>, but with <code>f</code> mapped to each of the arguments. Additionally, MapIdnexed supplies the part specification of the subexpression as the second argument of f. Map[f, expr, levelspec] maps f to all subexpressions that match the level specification levelspec, also supplying the part specification for each subexpression as the second argument to f.</p> <p><code>Attributes[MapIndexed] := {Protected}</code></p>"},{"location":"builtin/functional/mapindexed/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= f[a[f[b[f[c, {1, 1}], f[d, {1, 2}], f[e, {1, 3}]], {1}], f[l[f[g[f[h, {2, 1, 1}], f[j, {2, 1, 2}]], {2, 1}], f[k, {2, 2}]], {2}]], {}]\nOut[1]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], {Infinity*-1, Infinity}]\n</code></pre> <pre><code>In[2]:= a[f[b[f[c, {1, 1}], f[d, {1, 2}], f[e, {1, 3}]], {1}], f[l[f[g[f[h, {2, 1, 1}], f[j, {2, 1, 2}]], {2, 1}], f[k, {2, 2}]], {2}]]\nOut[2]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], Infinity]\n</code></pre> <pre><code>In[3]:= a[f[b[f[c, {1, 1}], f[d, {1, 2}], f[e, {1, 3}]], {1}], l[f[g[f[h, {2, 1, 1}], f[j, {2, 1, 2}]], {2, 1}], f[k, {2, 2}]]]\nOut[3]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], {-2, Infinity}]\n</code></pre> <pre><code>In[4]:= a[b[c, d, e], l[f[g[h, j], {2, 1}], k]]\nOut[4]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], {2, -2}]\n</code></pre> <pre><code>In[5]:= a[f[b[f[c, {1, 1}], f[d, {1, 2}], f[e, {1, 3}]], {1}], f[l[f[g[h, j], {2, 1}], f[k, {2, 2}]], {2}]]\nOut[5]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], 2]\n</code></pre> <pre><code>In[6]:= a[f[b[c, d, e], {1}], f[l[f[g[h, j], {2, 1}], k], {2}]]\nOut[6]= MapIndexed[f, a[b[c, d, e], l[g[h, j], k]], -2]\n</code></pre></p>"},{"location":"builtin/functional/nest/","title":"Nest","text":"<p><code>Nest[f, expr, n]</code> returns <code>f</code> wrapped around <code>expr</code> <code>n</code> times.</p> <p><code>Attributes[Nest] := {Protected}</code></p>"},{"location":"builtin/functional/nest/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Nest[f, x, 3]\nOut[1]= f[f[f[x]]]\n</code></pre> <pre><code>In[2]:= Nest[Function[Slot[1]^2], {1, 2, 3}, 3]\nOut[2]= {1, 256, 6561}\n</code></pre></p>"},{"location":"builtin/functional/nestlist/","title":"NestList","text":"<p><code>NestList[f, expr, n]</code> returns <code>f</code> wrapped around <code>expr</code> first once, then twice, and so on up to <code>n</code> times.</p> <p><code>Attributes[NestList] := {Protected}</code></p>"},{"location":"builtin/functional/nestlist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= NestList[f, x, 3]\nOut[1]= {x, f[x], f[f[x]], f[f[f[x]]]}\n</code></pre> <pre><code>In[2]:= NestList[Function[Slot[1]^2], {1, 2, 3}, 3]\nOut[2]= {{1, 2, 3}, {1, 4, 9}, {1, 16, 81}, {1, 256, 6561}}\n</code></pre></p>"},{"location":"builtin/functional/nestwhile/","title":"NestWhile","text":"<p><code>NestWhile[f, expr, test, m, max, n]</code> applies <code>f</code> to <code>expr</code> until <code>test</code> does not return <code>True</code>. <code>test</code> is a function that takes as its argument the last <code>m</code> results. <code>max</code> denotes the maximum number of applications of <code>f</code> and <code>n</code> denotes that <code>f</code> should be applied another <code>n</code> times after <code>test</code> has terminated the recursion.</p> <p><code>Attributes[NestWhile] := {Protected}</code></p>"},{"location":"builtin/functional/nestwhile/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= NestWhile[Function[Slot[1]^2], 2, Function[(Slot[1]) &lt; (256)]]\nOut[1]= 256\n</code></pre> <pre><code>In[2]:= NestWhile[Function[Slot[1] + 1], 1, Function[((Slot[1] + Slot[4])) &lt; (10)], 4]\nOut[2]= 7\n</code></pre> <pre><code>In[3]:= NestWhile[Function[Slot[1] + 1], 1, Function[True], 1, 4]\nOut[3]= 5\n</code></pre> <pre><code>In[4]:= NestWhile[Function[Slot[1] + 1], 1, Function[True], 1, 4, 5]\nOut[4]= 10\n</code></pre></p>"},{"location":"builtin/functional/nestwhilelist/","title":"NestWhileList","text":"<p><code>NestWhileList[f, expr, test, m, max, n]</code> applies <code>f</code> to <code>expr</code> until <code>test</code> does not return <code>True</code>. It returns a list of all intermediate results. <code>test</code> is a function that takes as its argument the last <code>m</code> results. <code>max</code> denotes the maximum number of applications of <code>f</code> and <code>n</code> denotes that <code>f</code> should be applied another <code>n</code> times after <code>test</code> has terminated the recursion.</p> <p><code>Attributes[NestWhileList] := {Protected}</code></p>"},{"location":"builtin/functional/nestwhilelist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Length[NestWhileList[Function[(Slot[1] + (3)/(Slot[1]))/(2)], 1., Function[Slot[1] =!= Slot[2]], 2]]\nOut[1]= 7\n</code></pre> <pre><code>In[2]:= NestWhileList[Function[Slot[1]^2], 2, Function[(Slot[1]) &lt; (256)]]\nOut[2]= {2, 4, 16, 256}\n</code></pre> <pre><code>In[3]:= NestWhileList[Function[Slot[1] + 1], 1, Function[((Slot[1] + Slot[4])) &lt; (10)], 4]\nOut[3]= {1, 2, 3, 4, 5, 6, 7}\n</code></pre> <pre><code>In[4]:= NestWhileList[Function[Slot[1] + 1], 1, Function[True], 1, 4]\nOut[4]= {1, 2, 3, 4, 5}\n</code></pre> <pre><code>In[5]:= NestWhileList[Function[Slot[1] + 1], 1, Function[True], 1, 4, 5]\nOut[5]= {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n</code></pre></p>"},{"location":"builtin/functional/slot/","title":"Slot","text":"<p><code>#</code> serves as a pure function's first parameter.</p> <p><code>#n</code> serves as a pure function's <code>n</code>'th parameter.</p> <p><code>Attributes[Slot] := {NHoldAll, Protected}</code></p>"},{"location":"builtin/functional/slot/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Function[1 + Slot[1]][x]\nOut[1]= 1 + x\n</code></pre> <pre><code>In[2]:= Function[1 + Slot[1] + 2*Slot[2]][x, y]\nOut[2]= 1 + x + 2*y\n</code></pre> <pre><code>In[3]:= Slot[1] === Slot[1]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= Slot[2] === Slot[2]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= Function[4*Slot[1] + Function[2*Slot[1]][a]][b]\nOut[5]= 2*a + 4*b\n</code></pre></p>"},{"location":"builtin/list/","title":"list documentation","text":"<p>List</p> <p>Total</p> <p>Mean</p> <p>Table</p> <p>ParallelTable</p> <p>MemberQ</p> <p>Cases</p> <p>DeleteCases</p> <p>Union</p> <p>Complement</p> <p>Intersection</p> <p>PadRight</p> <p>PadLeft</p> <p>Range</p> <p>Part</p> <p>Take</p> <p>Span</p> <p>All</p> <p>Thread</p> <p>Append</p> <p>AppendTo</p> <p>Prepend</p> <p>PrependTo</p> <p>DeleteDuplicates</p> <p>Select</p> <p>Scan</p> <p>Join</p> <p>ListQ</p> <p>Last</p> <p>First</p> <p>Rest</p> <p>Count</p> <p>Tally</p> <p>ConstantArray</p> <p>Reverse</p>"},{"location":"builtin/list/all/","title":"All","text":"<p><code>All</code> allows selection along a dimension in <code>Part</code>.</p> <p><code>Attributes[All] := {Protected}</code></p>"},{"location":"builtin/list/all/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= mat = Table[Table[a*b^2, {b, 5}], {a, 5}]\nOut[1]= {{1, 4, 9, 16, 25}, {2, 8, 18, 32, 50}, {3, 12, 27, 48, 75}, {4, 16, 36, 64, 100}, {5, 20, 45, 80, 125}}\n</code></pre> Use <code>All</code> to select along the entire dimension: <pre><code>In[2]:= mat[[5,All]]\nOut[2]= {5, 20, 45, 80, 125}\n</code></pre></p>"},{"location":"builtin/list/append/","title":"Append","text":"<p><code>Append[list, e]</code> returns <code>list</code> with <code>e</code> appended.</p> <p><code>Attributes[Append] := {Protected}</code></p>"},{"location":"builtin/list/append/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Append[{a, b}, c]\nOut[1]= {a, b, c}\n</code></pre> <pre><code>In[2]:= Append[foo[a, b], c]\nOut[2]= foo[a, b, c]\n</code></pre></p>"},{"location":"builtin/list/appendto/","title":"AppendTo","text":"<p><code>AppendTo[list, e]</code> appends <code>e</code> to <code>list</code> and returns the modified <code>list</code>.</p> <p><code>Attributes[AppendTo] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/list/appendto/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= CompoundExpression[l = {a, b}, AppendTo[l, c], l]\nOut[1]= {a, b, c}\n</code></pre>"},{"location":"builtin/list/cases/","title":"Cases","text":"<p><code>Cases[expr, pat]</code> returns a new <code>List</code> of all elements in <code>expr</code> that match <code>pat</code>.</p> <p><code>Attributes[Cases] := {Protected}</code></p>"},{"location":"builtin/list/cases/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Cases[{5, 2, 3.5, x, y, 4}, _]\nOut[1]= {5, 2, 3.5, x, y, 4}\n</code></pre> <pre><code>In[2]:= Cases[{5, 2, 3.5, x, y, 4}, _Integer]\nOut[2]= {5, 2, 4}\n</code></pre> <pre><code>In[3]:= Cases[{5, 2, 3.5, x, y, 4}, _Real]\nOut[3]= {3.5}\n</code></pre> <pre><code>In[4]:= Cases[{b^2, 1, a^c}, _^e_ -&gt; e]\nOut[4]= {2, c}\n</code></pre></p>"},{"location":"builtin/list/cases/#further-examples","title":"Further examples","text":"<p><code>expr</code> need not be a list: <pre><code>In[1]:= Cases[bar[a, b, c], a]\nOut[1]= {a}\n</code></pre></p>"},{"location":"builtin/list/complement/","title":"Complement","text":"<p><code>Complement[expr1, expr2, ...]</code> returns a sorted union of the items in the expressions.</p> <p><code>Attributes[Complement] := {Protected}</code></p>"},{"location":"builtin/list/complement/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Intersection[{a, b}, {a}]\nOut[1]= {a}\n</code></pre> <pre><code>In[2]:= Intersection[{a, b, c}, {a}, {b}]\nOut[2]= {}\n</code></pre></p>"},{"location":"builtin/list/constantarray/","title":"ConstantArray","text":"<p><code>ConstantArray[c, n]</code> creates a list of <code>n</code> copies of <code>c</code>.</p> <p><code>Attributes[ConstantArray] := {Protected}</code></p>"},{"location":"builtin/list/constantarray/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= ConstantArray[a, 3]\nOut[1]= {a, a, a}\n</code></pre>"},{"location":"builtin/list/count/","title":"Count","text":"<p><code>Count[l, pattern]</code> returns the number of expressions in <code>l</code> matching <code>pattern</code>.</p> <p><code>Attributes[Count] := {Protected}</code></p>"},{"location":"builtin/list/count/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Count[a + b + c^2, _]\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= Count[a + b + c^2, _, -1]\nOut[2]= 5\n</code></pre> <pre><code>In[3]:= Count[a + b + c^2, _, Infinity]\nOut[3]= 5\n</code></pre> <pre><code>In[4]:= Count[a, _, Infinity]\nOut[4]= 0\n</code></pre> <pre><code>In[5]:= Count[a, _, -1]\nOut[5]= 0\n</code></pre> <pre><code>In[6]:= Count[a + 2 + c^2, _Integer, Infinity]\nOut[6]= 2\n</code></pre></p>"},{"location":"builtin/list/deletecases/","title":"DeleteCases","text":"<p><code>DeleteCases[expr, pat]</code> returns a new expression of all elements in <code>expr</code> that do not match <code>pat</code>.</p> <p><code>Attributes[DeleteCases] := {Protected}</code></p>"},{"location":"builtin/list/deletecases/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= DeleteCases[{5, 2, 3.5, x, y, 4}, _Integer]\nOut[1]= {3.5, x, y}\n</code></pre> <pre><code>In[2]:= DeleteCases[{5, 2, 3.5, x, y, 4}, _Real]\nOut[2]= {5, 2, x, y, 4}\n</code></pre> <pre><code>In[3]:= DeleteCases[3.5 + x + y, _Real]\nOut[3]= x + y\n</code></pre></p>"},{"location":"builtin/list/deleteduplicates/","title":"DeleteDuplicates","text":"<p><code>DeleteDuplicates[list]</code> returns <code>list</code> with the duplicates removed.</p> <p><code>Attributes[DeleteDuplicates] := {Protected}</code></p>"},{"location":"builtin/list/deleteduplicates/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= DeleteDuplicates[{b, a, b}]\nOut[1]= {b, a}\n</code></pre> <pre><code>In[2]:= DeleteDuplicates[foo[b, a, b]]\nOut[2]= foo[b, a]\n</code></pre> <pre><code>In[3]:= DeleteDuplicates[{}]\nOut[3]= {}\n</code></pre> <pre><code>In[4]:= Length[DeleteDuplicates[Range[10000]]]\nOut[4]= 10000\n</code></pre></p>"},{"location":"builtin/list/first/","title":"First","text":"<p><code>First[expr]</code> returns the first part of <code>expr</code>.</p> <p><code>Attributes[First] := {Protected}</code></p>"},{"location":"builtin/list/first/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= First[{1, 5, 6}]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= First[a + b]\nOut[2]= a\n</code></pre></p>"},{"location":"builtin/list/intersection/","title":"Intersection","text":"<p><code>Intersection[expr1, expr2, ...]</code> returns a sorted intersection of the items in the expressions.</p> <p><code>Attributes[Intersection] := {Flat, OneIdentity, Protected, ReadProtected}</code></p>"},{"location":"builtin/list/join/","title":"Join","text":"<p><code>Join[l1, l2, ...]</code> joins the lists into a single list.</p> <p><code>Attributes[Join] := {Flat, OneIdentity, Protected}</code></p>"},{"location":"builtin/list/join/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Join[{a}, {b, c}]\nOut[1]= {a, b, c}\n</code></pre> <pre><code>In[2]:= Join[]\nOut[2]= {}\n</code></pre> <pre><code>In[3]:= Join[foo[a], foo[b, c]]\nOut[3]= foo[a, b, c]\n</code></pre></p>"},{"location":"builtin/list/last/","title":"Last","text":"<p><code>Last[expr]</code> returns the last part of <code>expr</code>.</p> <p><code>Attributes[Last] := {Protected}</code></p>"},{"location":"builtin/list/last/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Last[{1, 5, 6}]\nOut[1]= 6\n</code></pre> <pre><code>In[2]:= Last[a + b]\nOut[2]= b\n</code></pre></p>"},{"location":"builtin/list/list/","title":"List","text":"<p><code>{e1, e2, ...}</code> groups expressions together.</p> <p><code>Attributes[List] := {Locked, Protected}</code></p>"},{"location":"builtin/list/list/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= {1, 2, a}\nOut[1]= {1, 2, a}\n</code></pre>"},{"location":"builtin/list/listq/","title":"ListQ","text":"<p><code>ListQ[expr]</code> checks if <code>expr</code> has a head of <code>List</code>.</p> <p><code>Attributes[ListQ] := {Protected}</code></p>"},{"location":"builtin/list/listq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ListQ[{a}]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= ListQ[a]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= ListQ[{}]\nOut[3]= True\n</code></pre></p>"},{"location":"builtin/list/mean/","title":"Mean","text":"<p><code>Mean[list]</code> calculates the statistical mean of <code>list</code>.</p> <p><code>Attributes[Mean] := {Protected}</code></p>"},{"location":"builtin/list/mean/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Mean[{5, 6}]\nOut[1]= (11)/(2)\n</code></pre>"},{"location":"builtin/list/memberq/","title":"MemberQ","text":"<p><code>MemberQ[expr, pat]</code> returns True if any of the elements in <code>expr</code> match <code>pat</code>, otherwise returns False.</p> <p><code>Attributes[MemberQ] := {Protected}</code></p>"},{"location":"builtin/list/memberq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MemberQ[{1, 2, 3}, 0]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= MemberQ[{1, 2, 3}, 1]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= MemberQ[{1, 2, 3}, {1}]\nOut[3]= False\n</code></pre> <code>MemberQ</code> works with patterns: <pre><code>In[4]:= MemberQ[{1, 2, 3}, _Integer]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= MemberQ[{1, 2, 3}, _]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= MemberQ[{1, 2, 3}, _Real]\nOut[6]= False\n</code></pre> <pre><code>In[7]:= MemberQ[{1, 2, 3}, testmatch_Integer]\nOut[7]= True\n</code></pre> <pre><code>In[8]:= testmatch\nOut[8]= testmatch\n</code></pre> <pre><code>In[9]:= MemberQ[a, a]\nOut[9]= False\n</code></pre> <pre><code>In[10]:= MemberQ[a, _]\nOut[10]= False\n</code></pre> <pre><code>In[11]:= MemberQ[{a, b}, c]\nOut[11]= False\n</code></pre> <pre><code>In[12]:= MemberQ[{a, b}, a]\nOut[12]= True\n</code></pre></p>"},{"location":"builtin/list/memberq/#further-examples","title":"Further examples","text":"<p><code>MemberQ</code> works with BlankSequences: <pre><code>In[1]:= MemberQ[{a, b}, ___]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MemberQ[{a, b}, __]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= MemberQ[{a, b}, __Integer]\nOut[3]= False\n</code></pre> <pre><code>In[4]:= MemberQ[{a, b}, ___Integer]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= MemberQ[{a, b}, ___Symbol]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= MemberQ[{a, b}, __Symbol]\nOut[6]= True\n</code></pre> <pre><code>In[7]:= MemberQ[{a, b, 1}, __Symbol]\nOut[7]= True\n</code></pre> <pre><code>In[8]:= MemberQ[{a, b, 1}, __Integer]\nOut[8]= True\n</code></pre> <code>expr</code> need not be a List: <pre><code>In[9]:= MemberQ[bar[a, b, c], a]\nOut[9]= True\n</code></pre> <pre><code>In[10]:= MemberQ[bar[a, b, c], bar]\nOut[10]= False\n</code></pre></p>"},{"location":"builtin/list/padleft/","title":"PadLeft","text":"<p><code>Attributes[PadLeft] := {Protected}</code></p>"},{"location":"builtin/list/padright/","title":"PadRight","text":"<p><code>Attributes[PadRight] := {Protected}</code></p>"},{"location":"builtin/list/paralleltable/","title":"ParallelTable","text":"<p><code>ParallelTable[expr, n]</code> returns a list with <code>n</code> copies of <code>expr</code>, evaluated in parallel.</p> <p><code>ParallelTable[expr, {sym, n}]</code> returns a list with <code>expr</code> evaluated with <code>sym</code> = 1 to <code>n</code>, evaluated in parallel.</p> <p><code>ParallelTable[expr, {sym, m, n}]</code> returns a list with <code>expr</code> evaluated with <code>sym</code> = <code>m</code> to <code>n</code>, evaluated in parallel.</p> <p><code>Attributes[ParallelTable] := {HoldAll, Protected}</code></p>"},{"location":"builtin/list/paralleltable/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= ParallelTable[i, {i, 5, 10}]\nOut[1]= {5, 6, 7, 8, 9, 10}\n</code></pre>"},{"location":"builtin/list/part/","title":"Part","text":"<p><code>expr[[i]]</code> or <code>Part[expr, i]</code> returns the <code>i</code>th element of <code>expr</code>.</p> <p><code>Attributes[Part] := {NHoldRest, Protected, ReadProtected}</code></p>"},{"location":"builtin/list/part/#simple-examples","title":"Simple examples","text":"<p>Return the second item in a list: <pre><code>In[1]:= {a, b, c, d}[[2]]\nOut[1]= b\n</code></pre> Multi-dimensional indices are supported: <pre><code>In[2]:= mat = Table[Table[a*b^2, {b, 5}], {a, 5}]\nOut[2]= {{1, 4, 9, 16, 25}, {2, 8, 18, 32, 50}, {3, 12, 27, 48, 75}, {4, 16, 36, 64, 100}, {5, 20, 45, 80, 125}}\n</code></pre> <pre><code>In[3]:= mat[[5,2]]\nOut[3]= 20\n</code></pre> Use <code>All</code> to select along the entire dimension: <pre><code>In[4]:= mat[[5,All]]\nOut[4]= {5, 20, 45, 80, 125}\n</code></pre></p>"},{"location":"builtin/list/part/#further-examples","title":"Further examples","text":"<p>Out of bounds issues will prevent the expression from evaluating: <pre><code>In[1]:= {a}[[2]]\nOut[1]= {a}[[2]]\n</code></pre> The input need not be a <code>List</code>: <pre><code>In[2]:= foo[a][[0]]\nOut[2]= foo\n</code></pre> Omitting an index will return the original expression: <pre><code>In[3]:= i[[]]\nOut[3]= i\n</code></pre> <pre><code>In[4]:= {{1, 2}, {3, 4}, {5, 6}}[[All,2]]\nOut[4]= {2, 4, 6}\n</code></pre></p>"},{"location":"builtin/list/prepend/","title":"Prepend","text":"<p><code>Prepend[list, e]</code> returns <code>list</code> with <code>e</code> prepended.</p> <p><code>Attributes[Prepend] := {Protected}</code></p>"},{"location":"builtin/list/prepend/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Prepend[{a, b}, c]\nOut[1]= {c, a, b}\n</code></pre> <pre><code>In[2]:= Prepend[foo[a, b], c]\nOut[2]= foo[c, a, b]\n</code></pre></p>"},{"location":"builtin/list/prependto/","title":"PrependTo","text":"<p><code>PrependTo[list, e]</code> prepends <code>e</code> to <code>list</code> and returns the modified <code>list</code>.</p> <p><code>Attributes[PrependTo] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/list/prependto/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= CompoundExpression[l = {a, b}, PrependTo[l, c], l]\nOut[1]= {c, a, b}\n</code></pre>"},{"location":"builtin/list/range/","title":"Range","text":"<p><code>Range[n]</code> returns a <code>List</code> of integers from 1 to <code>n</code>.</p> <p><code>Range[m, n]</code> returns a <code>List</code> of integers from <code>m</code> to <code>n</code>.</p> <p><code>Attributes[Range] := {Listable, Protected}</code></p>"},{"location":"builtin/list/range/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Range[3]\nOut[1]= {1, 2, 3}\n</code></pre> <pre><code>In[2]:= Range[2, 5]\nOut[2]= {2, 3, 4, 5}\n</code></pre> <pre><code>In[3]:= Range[2, -5]\nOut[3]= {}\n</code></pre></p>"},{"location":"builtin/list/rest/","title":"Rest","text":"<p><code>Rest[expr]</code> returns all but the first part of <code>expr</code>.</p> <p><code>Attributes[Rest] := {Protected}</code></p>"},{"location":"builtin/list/rest/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Rest[{1, 5, 6}]\nOut[1]= {5, 6}\n</code></pre> <pre><code>In[2]:= Rest[a + b + c]\nOut[2]= b + c\n</code></pre></p>"},{"location":"builtin/list/reverse/","title":"Reverse","text":"<p><code>Reverse[list]</code> evaluates to a reversed copy of <code>list</code>.</p> <p><code>Attributes[Reverse] := {Protected}</code></p>"},{"location":"builtin/list/reverse/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Reverse[Range[5]]\nOut[1]= {5, 4, 3, 2, 1}\n</code></pre>"},{"location":"builtin/list/scan/","title":"Scan","text":"<p><code>Scan[fn, list]</code> evaluates <code>fn[elem]</code> for each element in <code>list</code>.</p> <p><code>Attributes[Scan] := {Protected}</code></p>"},{"location":"builtin/list/scan/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Scan[Function[If[(Slot[1]) &gt; (5), Return[Slot[1]]]], {1, 6, 9}]\nOut[1]= 6\n</code></pre> <pre><code>In[2]:= Catch[CompoundExpression[Scan[Function[If[IntegerQ[Slot[1]], Null, Throw[False]]], {a}], True]]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= Catch[CompoundExpression[Scan[Function[If[IntegerQ[Slot[1]], Null, Throw[False]]], {1, 2}], True]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= Catch[CompoundExpression[Scan[Function[If[IntegerQ[Slot[1]], Null, Throw[False]]], {1, a}], True]]\nOut[4]= False\n</code></pre></p>"},{"location":"builtin/list/select/","title":"Select","text":"<p><code>Select[expr, cond]</code> selects only parts of <code>expr</code> that satisfy <code>cond</code>.</p> <p><code>Attributes[Select] := {Protected}</code></p>"},{"location":"builtin/list/select/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Select[Range[20], OddQ]\nOut[1]= {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}\n</code></pre> <pre><code>In[2]:= Select[{1, 2, 3, 4}, Function[True]]\nOut[2]= {1, 2, 3, 4}\n</code></pre> <pre><code>In[3]:= Select[{1, 2, 3, 4}, Function[True], 2]\nOut[3]= {1, 2}\n</code></pre></p>"},{"location":"builtin/list/span/","title":"Span","text":"<p><code>start ;; end</code> represents an index span to select using Part.</p> <p><code>Attributes[Span] := {Protected}</code></p>"},{"location":"builtin/list/span/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= {a, b, c, d}[[Span[2, 3]]]\nOut[1]= {b, c}\n</code></pre> <pre><code>In[2]:= {a, b, c, d}[[Span[2, All]]]\nOut[2]= {b, c, d}\n</code></pre></p>"},{"location":"builtin/list/table/","title":"Table","text":"<p><code>Table[expr, n]</code> returns a list with <code>n</code> copies of <code>expr</code>.</p> <p><code>Table[expr, {sym, n}]</code> returns a list with <code>expr</code> evaluated with <code>sym</code> = 1 to <code>n</code>.</p> <p><code>Table[expr, {sym, m, n}]</code> returns a list with <code>expr</code> evaluated with <code>sym</code> = <code>m</code> to <code>n</code>.</p> <p><code>Attributes[Table] := {HoldAll, Protected}</code></p>"},{"location":"builtin/list/table/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Table[a, 5]\nOut[1]= {a, a, a, a, a}\n</code></pre> <pre><code>In[2]:= Table[i, {i, 5, 10}]\nOut[2]= {5, 6, 7, 8, 9, 10}\n</code></pre> Create a list of the first 10 squares: <pre><code>In[3]:= Table[n^2, {n, 1, 10}]\nOut[3]= {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}\n</code></pre> Iteration definitions do not have side effects: <pre><code>In[4]:= i\nOut[4]= i\n</code></pre> <pre><code>In[5]:= listTableTestState`i = 22\nOut[5]= 22\n</code></pre> <pre><code>In[6]:= Table[i, {i, 5, 10}]\nOut[6]= {5, 6, 7, 8, 9, 10}\n</code></pre> <pre><code>In[7]:= i\nOut[7]= 22\n</code></pre></p>"},{"location":"builtin/list/table/#further-examples","title":"Further examples","text":"<pre><code>In[1]:= Table[x[99], {x[_], 0, 2}]\nOut[1]= {0, 1, 2}\n</code></pre>"},{"location":"builtin/list/take/","title":"Take","text":"<p><code>Take[list, m]</code> returns the first <code>m</code> items of <code>list</code>.</p> <p><code>Attributes[Take] := {NHoldRest, Protected}</code></p>"},{"location":"builtin/list/take/#simple-examples","title":"Simple examples","text":"<p>Return the first two items in a list: <pre><code>In[1]:= Take[{1, 2, 3, 4}, 2]\nOut[1]= {1, 2}\n</code></pre> Return a range from the middle of a list: <pre><code>In[2]:= Take[{1, 2, 3, 4, 5}, {2, 4}]\nOut[2]= {2, 3, 4}\n</code></pre></p>"},{"location":"builtin/list/tally/","title":"Tally","text":"<p><code>Tally[list]</code> creates tallies of the elements in <code>list</code>.</p> <p><code>Attributes[Tally] := {Protected}</code></p>"},{"location":"builtin/list/tally/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Tally[{a, a, b, b}]\nOut[1]= {{a, 2}, {b, 2}}\n</code></pre> <pre><code>In[2]:= Tally[{b, b, a, a}]\nOut[2]= {{b, 2}, {a, 2}}\n</code></pre> <pre><code>In[3]:= Tally[{b, b, a}]\nOut[3]= {{b, 2}, {a, 1}}\n</code></pre></p>"},{"location":"builtin/list/thread/","title":"Thread","text":"<p><code>Thread[f[a1, a2, ...}]]</code> applies f over the arguments, expanding out any lists.</p> <p><code>Attributes[Thread] := {Protected}</code></p>"},{"location":"builtin/list/total/","title":"Total","text":"<p><code>Total[list]</code> sums all the values in <code>list</code>.</p> <p><code>Attributes[Total] := {Protected}</code></p>"},{"location":"builtin/list/total/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Total[{1, 2, 3, 4}]\nOut[1]= 10\n</code></pre>"},{"location":"builtin/list/total/#further-examples","title":"Further examples","text":"<p>The total of an empty list is zero: <pre><code>In[1]:= Total[{}]\nOut[1]= 0\n</code></pre></p>"},{"location":"builtin/list/union/","title":"Union","text":"<p><code>Union[expr1, expr2, ...]</code> returns a sorted union of the items in the expressions.</p> <p><code>Attributes[Union] := {Protected}</code></p>"},{"location":"builtin/list/union/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Union[{b, a, a, b, a}]\nOut[1]= {a, b}\n</code></pre> <pre><code>In[2]:= Union[{b, a, a, b, a}, {y, z}]\nOut[2]= {a, b, y, z}\n</code></pre> <pre><code>In[3]:= Union[foo[b, a, a, b, a], foo[y, z]]\nOut[3]= foo[a, b, y, z]\n</code></pre></p>"},{"location":"builtin/manip/","title":"manip documentation","text":"<p>Together</p> <p>Numerator</p> <p>Denominator</p> <p>Distribute</p>"},{"location":"builtin/manip/denominator/","title":"Denominator","text":"<p><code>Denominator[e]</code> returns the denominator of <code>e</code>.</p> <p><code>Attributes[Denominator] := {Listable, Protected}</code></p>"},{"location":"builtin/manip/denominator/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Denominator[(a)/(b*c)]\nOut[1]= b*c\n</code></pre> <pre><code>In[2]:= Denominator[a^2*b]\nOut[2]= 1\n</code></pre> <pre><code>In[3]:= Denominator[a^2*b^-2*c^-3]\nOut[3]= b^2*c^3\n</code></pre> <pre><code>In[4]:= Denominator[a^2*b^(a*-1)*c^(d*-1)]\nOut[4]= b^a*c^d\n</code></pre> <pre><code>In[5]:= Denominator[(2)/(3)]\nOut[5]= 3\n</code></pre></p>"},{"location":"builtin/manip/distribute/","title":"Distribute","text":"<p><code>Distribute[e]</code> distributes the function over the <code>Plus</code> expressions.</p> <p><code>Attributes[Distribute] := {Protected}</code></p>"},{"location":"builtin/manip/distribute/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Distribute[(a + b)*(c + d)]\nOut[1]= a*c + b*c + a*d + b*d\n</code></pre> <pre><code>In[2]:= Distribute[(a + b)*c]\nOut[2]= a*c + b*c\n</code></pre> <pre><code>In[3]:= Distribute[foo[a + b, c]]\nOut[3]= foo[a, c] + foo[b, c]\n</code></pre> <pre><code>In[4]:= Distribute[foo[a, b]]\nOut[4]= foo[a, b]\n</code></pre> <pre><code>In[5]:= Distribute[foo[a, b] + foo[c]]\nOut[5]= foo[c] + foo[a, b]\n</code></pre> <pre><code>In[6]:= Distribute[(a + b)*c + a]\nOut[6]= a + (a + b)*c\n</code></pre> <pre><code>In[7]:= Distribute[((a + b)*c + d)*(e + f)]\nOut[7]= (a + b)*c*e + d*e + (a + b)*c*f + d*f\n</code></pre> <pre><code>In[8]:= Distribute[foo[a, b], test]\nOut[8]= test[foo[a, b]]\n</code></pre> <pre><code>In[9]:= Distribute[foo[a, test[b, c]], test]\nOut[9]= test[foo[a, b], foo[a, c]]\n</code></pre> <pre><code>In[10]:= Distribute[foo[a, test[b, c], test[d, e]], test]\nOut[10]= test[foo[a, b, d], foo[a, b, e], foo[a, c, d], foo[a, c, e]]\n</code></pre> <pre><code>In[11]:= Distribute[foo[a, test[b, c], test[d, e], bar[a]], test]\nOut[11]= test[foo[a, b, d, bar[a]], foo[a, b, e, bar[a]], foo[a, c, d, bar[a]], foo[a, c, e, bar[a]]]\n</code></pre> <pre><code>In[12]:= Distribute[a, test]\nOut[12]= a\n</code></pre> <pre><code>In[13]:= Distribute[a + b, 1]\nOut[13]= 1[a + b]\n</code></pre> <pre><code>In[14]:= Distribute[bar[a, test[b, c], test[d, e]], test]\nOut[14]= test[bar[a, b, d], bar[a, b, e], bar[a, c, d], bar[a, c, e]]\n</code></pre> <pre><code>In[15]:= Distribute[test[f, g][a, test[b, c], test[d, e]], test]\nOut[15]= test[test[f, g][a, b, d], test[f, g][a, b, e], test[f, g][a, c, d], test[f, g][a, c, e]]\n</code></pre> <pre><code>In[16]:= Distribute[foo[], test]\nOut[16]= test[foo[]]\n</code></pre> <pre><code>In[17]:= Distribute[foo[], test[]]\nOut[17]= test[][foo[]]\n</code></pre> <pre><code>In[18]:= Distribute[foo, test]\nOut[18]= foo\n</code></pre></p>"},{"location":"builtin/manip/numerator/","title":"Numerator","text":"<p><code>Numerator[e]</code> returns the numerator of <code>e</code>.</p> <p><code>Attributes[Numerator] := {Listable, Protected}</code></p>"},{"location":"builtin/manip/numerator/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Numerator[(a)/(b)]\nOut[1]= a\n</code></pre> <pre><code>In[2]:= Numerator[a^2*b]\nOut[2]= a^2*b\n</code></pre> <pre><code>In[3]:= Numerator[a^2*b^-2]\nOut[3]= a^2\n</code></pre> <pre><code>In[4]:= Numerator[a^2*b^(a*-1)*c]\nOut[4]= a^2*c\n</code></pre> <pre><code>In[5]:= Numerator[(2)/(3)]\nOut[5]= 2\n</code></pre></p>"},{"location":"builtin/manip/together/","title":"Together","text":"<p><code>Together[e]</code> attempts to put the terms in <code>e</code> under the same denominator.</p> <p><code>Attributes[Together] := {Listable, Protected}</code></p>"},{"location":"builtin/manip/together/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Together[(1)/(2) + (3)/(a)]\nOut[1]= (6 + a)/(2*a)\n</code></pre> <pre><code>In[2]:= Together[((1)/(2) + (3)/(a))^c]\nOut[2]= ((1)/(2) + (3)/(a))^c\n</code></pre> <pre><code>In[3]:= Together[((1)/(2) + (3)/(a))^2]\nOut[3]= ((6 + a)^2)/(4*a^2)\n</code></pre></p>"},{"location":"builtin/matrix/","title":"matrix documentation","text":"<p>Inverse</p> <p>Dimensions</p> <p>VectorQ</p> <p>MatrixQ</p> <p>Dot</p> <p>Transpose</p>"},{"location":"builtin/matrix/dimensions/","title":"Dimensions","text":"<p><code>Dimensions[expr]</code> finds the dimensions of <code>expr</code>.</p> <p><code>Attributes[Dimensions] := {Protected}</code></p>"},{"location":"builtin/matrix/dimensions/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Dimensions[{{1, 3}, {1, 2}}]\nOut[1]= {2, 2}\n</code></pre> <pre><code>In[2]:= Dimensions[{{{1, 2}, {3, 2}}, {{1, 2}}}]\nOut[2]= {2}\n</code></pre></p>"},{"location":"builtin/matrix/dimensions/#further-examples","title":"Further examples","text":"<p><pre><code>In[1]:= Dimensions[foo]\nOut[1]= {}\n</code></pre> <code>Dimensions</code> works with any head, not just <code>List</code>: <pre><code>In[2]:= Dimensions[foo[]]\nOut[2]= {0}\n</code></pre></p>"},{"location":"builtin/matrix/dot/","title":"Dot","text":"<p><code>a.b</code> computes the product of <code>a</code> and <code>b</code> for vectors and matrices.</p> <p><code>Attributes[Dot] := {Flat, OneIdentity, Protected}</code></p>"},{"location":"builtin/matrix/dot/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Dot[{a, b}, {c, d}]\nOut[1]= a*c + b*d\n</code></pre> <pre><code>In[2]:= Dot[{a, b}, {c, d, e}]\nOut[2]= Dot[{a, b}, {c, d, e}]\n</code></pre> <pre><code>In[3]:= Dot[1, {c, d, e}]\nOut[3]= Dot[1, {c, d, e}]\n</code></pre> <pre><code>In[4]:= Dot[{}, {}]\nOut[4]= 0\n</code></pre> <pre><code>In[5]:= Dot[{{a, b}, {c, d}}, {e, f, g}]\nOut[5]= Dot[{{a, b}, {c, d}}, {e, f, g}]\n</code></pre> <pre><code>In[6]:= Dot[{a, b}]\nOut[6]= {a, b}\n</code></pre> <pre><code>In[7]:= Dot[a]\nOut[7]= a\n</code></pre> <pre><code>In[8]:= Dot[1]\nOut[8]= 1\n</code></pre> <pre><code>In[9]:= Dot[{{a, b}, {c, d}}, {{e, f}, {g, h}}]\nOut[9]= {{a*e + b*g, a*f + b*h}, {c*e + d*g, c*f + d*h}}\n</code></pre> <pre><code>In[10]:= Dot[{{a, b}, {c, d}}, {{e}, {f}}]\nOut[10]= {{a*e + b*f}, {c*e + d*f}}\n</code></pre> <pre><code>In[11]:= Dot[{{a, b}, {c, d}}, {{e, f}}]\nOut[11]= Dot[{{a, b}, {c, d}}, {{e, f}}]\n</code></pre></p>"},{"location":"builtin/matrix/inverse/","title":"Inverse","text":"<p><code>Inverse[mat]</code> finds the inverse of the square matrix <code>mat</code>.</p> <p><code>Attributes[Inverse] := {Protected}</code></p>"},{"location":"builtin/matrix/inverse/#details","title":"Details","text":"<p>The row-reduce method has not been added yet, but the shortcuts to finding the inverses of matrices up to 3x3 have been added.</p>"},{"location":"builtin/matrix/inverse/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Inverse[{{1, 2}, {3, 4}}]\nOut[1]= {{-2, 1}, {(3)/(2), (1)/(2)*-1}}\n</code></pre> <pre><code>In[2]:= Inverse[{{3, 2, 1}, {1, 4, 2}, {2, 5, 7}}]\nOut[2]= {{(2)/(5), (1)/(5)*-1, 0}, {(1)/(15)*-1, (19)/(45), (1)/(9)*-1}, {(1)/(15)*-1, (11)/(45)*-1, (2)/(9)}}\n</code></pre></p>"},{"location":"builtin/matrix/inverse/#further-examples","title":"Further examples","text":"<p>Symbolic elements are handled correctly: <pre><code>In[1]:= {{(1)/(b)}}\nOut[1]= Inverse[{{b}}]\n</code></pre></p>"},{"location":"builtin/matrix/matrixq/","title":"MatrixQ","text":"<p><code>MatrixQ[expr]</code> returns True if <code>expr</code> is a 2D matrix, False otherwise.</p> <p><code>Attributes[MatrixQ] := {Protected}</code></p>"},{"location":"builtin/matrix/matrixq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatrixQ[{}]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= MatrixQ[{{}}]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= MatrixQ[{{a}}]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatrixQ[{{{}}}]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= MatrixQ[{{{a}}}]\nOut[5]= False\n</code></pre> <pre><code>In[6]:= MatrixQ[{{a}, {b}}]\nOut[6]= True\n</code></pre> <pre><code>In[7]:= MatrixQ[{{a, b}, {c, d}}]\nOut[7]= True\n</code></pre> <pre><code>In[8]:= MatrixQ[{{a, b, e}, {c, d}}]\nOut[8]= False\n</code></pre> <pre><code>In[9]:= MatrixQ[{{a, b, e}, {c, d, f}}]\nOut[9]= True\n</code></pre> <pre><code>In[10]:= MatrixQ[{{{a}, {b}}, {{c}, {d}}}]\nOut[10]= False\n</code></pre> <pre><code>In[11]:= MatrixQ[{{a, b, e}}]\nOut[11]= True\n</code></pre></p>"},{"location":"builtin/matrix/transpose/","title":"Transpose","text":"<p><code>Transpose[mat]</code> transposes the first two levels of <code>mat</code></p> <p><code>Attributes[Transpose] := {Protected}</code></p>"},{"location":"builtin/matrix/transpose/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Transpose[{a, b}]\nOut[1]= Transpose[{a, b}]\n</code></pre> <pre><code>In[2]:= Transpose[{{a}, {b}}]\nOut[2]= {{a, b}}\n</code></pre> <pre><code>In[3]:= Transpose[{{a, b}}]\nOut[3]= {{a}, {b}}\n</code></pre> <pre><code>In[4]:= Transpose[{{{a}, {b}}}]\nOut[4]= {{{a}}, {{b}}}\n</code></pre> <pre><code>In[5]:= Transpose[a]\nOut[5]= Transpose[a]\n</code></pre></p>"},{"location":"builtin/matrix/vectorq/","title":"VectorQ","text":"<p><code>VectorQ[expr]</code> returns True if <code>expr</code> is a vector, False otherwise.</p> <p><code>Attributes[VectorQ] := {Protected}</code></p>"},{"location":"builtin/matrix/vectorq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= VectorQ[{1, 2, c}]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= VectorQ[{1, 2, foo[a]}]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= VectorQ[foo[1, 2, 3]]\nOut[3]= False\n</code></pre> <pre><code>In[4]:= VectorQ[{1, 2, 3, {}}]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= VectorQ[{f[a], f[b]}]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= VectorQ[{a, c}]\nOut[6]= True\n</code></pre> <pre><code>In[7]:= VectorQ[{}]\nOut[7]= True\n</code></pre></p>"},{"location":"builtin/numbertheory/","title":"numbertheory documentation","text":"<p>PrimeQ</p> <p>GCD</p> <p>LCM</p> <p>Mod</p> <p>PrimePi</p> <p>Prime</p> <p>EvenQ</p> <p>OddQ</p> <p>FactorInteger</p> <p>FractionalPart</p> <p>IntegerPart</p> <p>PowerMod</p> <p>EulerPhi</p> <p>Fibonacci</p> <p>IntegerDigits</p> <p>FromDigits</p> <p>Sign</p>"},{"location":"builtin/numbertheory/eulerphi/","title":"EulerPhi","text":"<p><code>EulerPhi[n]</code> computes Euler's totient function for <code>n</code></p> <p><code>Attributes[EulerPhi] := {Listable, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/eulerphi/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= EulerPhi[98]\nOut[1]= 42\n</code></pre> <pre><code>In[2]:= EulerPhi[0]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= EulerPhi[-98]\nOut[3]= 42\n</code></pre></p>"},{"location":"builtin/numbertheory/evenq/","title":"EvenQ","text":"<p><code>EvenQ[n]</code> returns True if <code>n</code> is an even integer.</p> <p><code>Attributes[EvenQ] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/evenq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= EvenQ[6]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= EvenQ[-2]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= EvenQ[1]\nOut[3]= False\n</code></pre> <pre><code>In[4]:= EvenQ[2.]\nOut[4]= EvenQ[2.]\n</code></pre> <pre><code>In[5]:= EvenQ[a]\nOut[5]= EvenQ[a]\n</code></pre></p>"},{"location":"builtin/numbertheory/factorinteger/","title":"FactorInteger","text":"<p><code>FactorInteger[n]</code> factors the integer <code>n</code>.</p> <p><code>Attributes[FactorInteger] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/factorinteger/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FactorInteger[8]\nOut[1]= {{2, 3}}\n</code></pre> <pre><code>In[2]:= FactorInteger[Rational[-15, 2]]\nOut[2]= {{-1, 1}, {2, -1}, {3, 1}, {5, 1}}\n</code></pre></p>"},{"location":"builtin/numbertheory/fibonacci/","title":"Fibonacci","text":"<p><code>Fibonacci[n]</code> computes the Fibonacci number for <code>n</code></p> <p><code>Attributes[Fibonacci] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/fibonacci/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Fibonacci[20]\nOut[1]= 6765\n</code></pre>"},{"location":"builtin/numbertheory/fractionalpart/","title":"FractionalPart","text":"<p><code>FractionalPart[n]</code> gives the fractional part of <code>n</code></p> <p><code>Attributes[FractionalPart] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/fractionalpart/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FractionalPart[-1]\nOut[1]= 0\n</code></pre> <pre><code>In[2]:= FractionalPart[(3)/(4)*-1]\nOut[2]= (3)/(4)*-1\n</code></pre> <pre><code>In[3]:= FractionalPart[(1)/(2)*-1]\nOut[3]= (1)/(2)*-1\n</code></pre> <pre><code>In[4]:= FractionalPart[(1)/(4)*-1]\nOut[4]= (1)/(4)*-1\n</code></pre> <pre><code>In[5]:= FractionalPart[0]\nOut[5]= 0\n</code></pre> <pre><code>In[6]:= FractionalPart[(1)/(4)]\nOut[6]= (1)/(4)\n</code></pre> <pre><code>In[7]:= FractionalPart[(1)/(2)]\nOut[7]= (1)/(2)\n</code></pre> <pre><code>In[8]:= FractionalPart[(3)/(4)]\nOut[8]= (3)/(4)\n</code></pre> <pre><code>In[9]:= FractionalPart[1]\nOut[9]= 0\n</code></pre></p>"},{"location":"builtin/numbertheory/fromdigits/","title":"FromDigits","text":"<p><code>FromDigits[list, base]</code> returns that number that the <code>list</code> of digits represents in base <code>base</code>.</p> <p><code>Attributes[FromDigits] := {Protected}</code></p>"},{"location":"builtin/numbertheory/fromdigits/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FromDigits[{3, 2, 1}]\nOut[1]= 321\n</code></pre> <pre><code>In[2]:= FromDigits[{1, 1, 0, 1}, 2]\nOut[2]= 13\n</code></pre></p>"},{"location":"builtin/numbertheory/gcd/","title":"GCD","text":"<p><code>GCD[n1, n2, ...]</code> finds the greatest common denominator of the integer inputs.</p> <p><code>Attributes[GCD] := {Flat, Listable, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/numbertheory/gcd/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= GCD[9, 6]\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= GCD[100, 30, 15]\nOut[2]= 5\n</code></pre></p>"},{"location":"builtin/numbertheory/integerdigits/","title":"IntegerDigits","text":"<p><code>IntegerDigits[n, base]</code> returns a list of integer digits for <code>n</code> under <code>base</code>.</p> <p><code>Attributes[IntegerDigits] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/integerdigits/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= IntegerDigits[123]\nOut[1]= {1, 2, 3}\n</code></pre> <pre><code>In[2]:= IntegerDigits[123, 2]\nOut[2]= {1, 1, 1, 1, 0, 1, 1}\n</code></pre> <pre><code>In[3]:= IntegerDigits[-123, 2]\nOut[3]= {1, 1, 1, 1, 0, 1, 1}\n</code></pre></p>"},{"location":"builtin/numbertheory/integerpart/","title":"IntegerPart","text":"<p><code>IntegerPart[n]</code> gives the integer part of <code>n</code></p> <p><code>Attributes[IntegerPart] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/integerpart/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= IntegerPart[-1]\nOut[1]= -1\n</code></pre> <pre><code>In[2]:= IntegerPart[(3)/(4)*-1]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= IntegerPart[(1)/(2)*-1]\nOut[3]= 0\n</code></pre> <pre><code>In[4]:= IntegerPart[(1)/(4)*-1]\nOut[4]= 0\n</code></pre> <pre><code>In[5]:= IntegerPart[0]\nOut[5]= 0\n</code></pre> <pre><code>In[6]:= IntegerPart[(1)/(4)]\nOut[6]= 0\n</code></pre> <pre><code>In[7]:= IntegerPart[(1)/(2)]\nOut[7]= 0\n</code></pre> <pre><code>In[8]:= IntegerPart[(3)/(4)]\nOut[8]= 0\n</code></pre> <pre><code>In[9]:= IntegerPart[1]\nOut[9]= 1\n</code></pre></p>"},{"location":"builtin/numbertheory/lcm/","title":"LCM","text":"<p><code>LCM[n1, n2, ...]</code> finds the least common multiple of the inputs.</p> <p><code>Attributes[LCM] := {Flat, Listable, OneIdentity, Orderless, Protected}</code></p>"},{"location":"builtin/numbertheory/lcm/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= LCM[5, 14]\nOut[1]= 70\n</code></pre> <pre><code>In[2]:= LCM[5, 14, 68]\nOut[2]= 2380\n</code></pre> <pre><code>In[3]:= LCM[(2)/(3), (1)/(3)]\nOut[3]= (2)/(3)\n</code></pre> <pre><code>In[4]:= LCM[(2)/(3), (1)/(3), (5)/(6)]\nOut[4]= (10)/(3)\n</code></pre> <pre><code>In[5]:= LCM[(2)/(3), (1)/(3), (5)/(6), 3]\nOut[5]= 30\n</code></pre> <pre><code>In[6]:= LCM[(2)/(3), {(1)/(3), (5)/(6), 3}]\nOut[6]= {(2)/(3), (10)/(3), 6}\n</code></pre></p>"},{"location":"builtin/numbertheory/mod/","title":"Mod","text":"<p><code>Mod[x, y]</code> finds the remainder when <code>x</code> is divided by <code>y</code>.</p> <p><code>Attributes[Mod] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/mod/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Mod[5, 3]\nOut[1]= 2\n</code></pre> <pre><code>In[2]:= Mod[0, 3]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= Mod[2, 0]\nOut[3]= Indeterminate\n</code></pre> <pre><code>In[4]:= Mod[-2*Pi, 3*Pi]\nOut[4]= Pi\n</code></pre></p>"},{"location":"builtin/numbertheory/oddq/","title":"OddQ","text":"<p><code>OddQ[n]</code> returns True if <code>n</code> is an odd integer.</p> <p><code>Attributes[OddQ] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/oddq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= OddQ[6]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= OddQ[-2]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= OddQ[1]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= OddQ[2.]\nOut[4]= OddQ[2.]\n</code></pre> <pre><code>In[5]:= OddQ[a]\nOut[5]= OddQ[a]\n</code></pre></p>"},{"location":"builtin/numbertheory/powermod/","title":"PowerMod","text":"<p><code>PowerMod[x, y, m]</code> computes <code>Mod[x^y, m]</code></p> <p><code>Attributes[PowerMod] := {Listable, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/powermod/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= PowerMod[5, 9999, 7]\nOut[1]= 6\n</code></pre>"},{"location":"builtin/numbertheory/prime/","title":"Prime","text":"<p><code>Prime[n]</code> returns the <code>n</code>th prime number.</p> <p><code>Attributes[Prime] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/prime/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Prime[3]\nOut[1]= 5\n</code></pre> <pre><code>In[2]:= Prime[3000]\nOut[2]= 27449\n</code></pre></p>"},{"location":"builtin/numbertheory/primepi/","title":"PrimePi","text":"<p><code>PrimePi[n]</code> returns the number of primes less than or equal to <code>n</code>.</p> <p><code>Attributes[PrimePi] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/primepi/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PrimePi[7]\nOut[1]= 4\n</code></pre> <pre><code>In[2]:= PrimePi[10^6]\nOut[2]= 78498\n</code></pre> <pre><code>In[3]:= PrimePi[-5]\nOut[3]= 0\n</code></pre></p>"},{"location":"builtin/numbertheory/primeq/","title":"PrimeQ","text":"<p><code>PrimeQ[n]</code> returns True if <code>n</code> is prime, False otherwise.</p> <p><code>Attributes[PrimeQ] := {Listable, Protected}</code></p>"},{"location":"builtin/numbertheory/primeq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PrimeQ[5]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= PrimeQ[100]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= PrimeQ[982451653]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= PrimeQ[-2]\nOut[4]= True\n</code></pre></p>"},{"location":"builtin/numbertheory/primeq/#further-examples","title":"Further examples","text":"<p><code>PrimeQ</code> only works for Integers: <pre><code>In[1]:= PrimeQ[5.]\nOut[1]= False\n</code></pre></p>"},{"location":"builtin/numbertheory/sign/","title":"Sign","text":"<p><code>Sign[x]</code> returns the sign of <code>x</code>.</p> <p><code>Attributes[Sign] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/numbertheory/sign/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Sign[5]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Sign[0]\nOut[2]= 0\n</code></pre> <pre><code>In[3]:= Sign[-5]\nOut[3]= -1\n</code></pre> <pre><code>In[4]:= Sign[5.]\nOut[4]= 1\n</code></pre> <pre><code>In[5]:= Sign[0.]\nOut[5]= 0\n</code></pre> <pre><code>In[6]:= Sign[-5.]\nOut[6]= -1\n</code></pre> <pre><code>In[7]:= Sign[(1)/(2)]\nOut[7]= 1\n</code></pre></p>"},{"location":"builtin/pattern/","title":"pattern documentation","text":"<p>MatchQ</p> <p>Pattern</p> <p>Blank</p> <p>BlankSequence</p> <p>BlankNullSequence</p> <p>Except</p> <p>PatternTest</p> <p>Condition</p> <p>Alternatives</p> <p>FreeQ</p> <p>ReplaceList</p> <p>Repeated</p> <p>Optional</p> <p>HoldPattern</p>"},{"location":"builtin/pattern/alternatives/","title":"Alternatives","text":"<p><code>alt1 | alt2 | ...</code> matches an expression if it matches any pattern in the list of alternatives.</p> <p><code>Attributes[Alternatives] := {Protected}</code></p>"},{"location":"builtin/pattern/alternatives/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Alternatives[c, d]\nOut[1]= Alternatives[c, d]\n</code></pre> <pre><code>In[2]:= MatchQ[b, Alternatives[c, d]]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= MatchQ[c, Alternatives[c, d]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatchQ[d, Alternatives[c, d]]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= Cases[{a, b, c, 1, 2}, Alternatives[c, _Integer]]\nOut[5]= {c, 1, 2}\n</code></pre> <pre><code>In[6]:= ({a, b, c, 1., 2}) /. ((Alternatives[amatch_Symbol, amatch_Integer] -&gt; amatch + 1))\nOut[6]= 1 + List[1 + a, 1 + b, 1 + c, 1., 3]\n</code></pre> <pre><code>In[7]:= Cases[{a, b, c, d, e, f}, Alternatives[b, c, d, e]]\nOut[7]= {b, c, d, e}\n</code></pre> <pre><code>In[8]:= MatchQ[{a, b}, {a_, Alternatives[k, a_]}]\nOut[8]= False\n</code></pre></p>"},{"location":"builtin/pattern/blank/","title":"Blank","text":"<p><code>_</code> matches any expression.</p> <p><code>_head</code> matches any expression with a <code>Head</code> of <code>head</code>.</p> <p><code>Attributes[Blank] := {Protected}</code></p>"},{"location":"builtin/pattern/blank/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[a + b, _]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[1, _Integer]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= MatchQ[s, _Integer]\nOut[3]= False\n</code></pre> <code>Blank</code> works with nonatomic <code>head</code>s: <pre><code>In[4]:= ((a*b*c*d)) /. ((_Times -&gt; 2))\nOut[4]= 2\n</code></pre></p>"},{"location":"builtin/pattern/blank/#further-examples","title":"Further examples","text":"<p>For <code>Orderless</code> functions, the match engine will attempt to find a match in any order: <pre><code>In[1]:= MatchQ[x + 3., c1match_Real + matcha_]\nOut[1]= True\n</code></pre></p>"},{"location":"builtin/pattern/blanknullsequence/","title":"BlankNullSequence","text":"<p><code>___</code> matches any sequence of zero or more expressions.</p> <p><code>___head</code> matches any sequence of zero or more expressions, each with a <code>Head</code> of <code>head</code>.</p> <p><code>Attributes[BlankNullSequence] := {Protected}</code></p>"},{"location":"builtin/pattern/blanknullsequence/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[a*b, ___]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[a + b, a + b + ___]\nOut[2]= True\n</code></pre></p>"},{"location":"builtin/pattern/blanknullsequence/#further-examples","title":"Further examples","text":"<p>With head assertions: <pre><code>In[1]:= MatchQ[a + b + c, a + x___Symbol]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[a + b + c, a + x___Plus]\nOut[2]= False\n</code></pre></p>"},{"location":"builtin/pattern/blanksequence/","title":"BlankSequence","text":"<p><code>__</code> matches any sequence of one or more expressions.</p> <p><code>__head</code> matches any sequence of one or more expressions, each with a <code>Head</code> of <code>head</code>.</p> <p><code>Attributes[BlankSequence] := {Protected}</code></p>"},{"location":"builtin/pattern/blanksequence/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[a + b + c, a + b + __]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[a + b + c, a + b + c + __]\nOut[2]= False\n</code></pre></p>"},{"location":"builtin/pattern/blanksequence/#further-examples","title":"Further examples","text":"<p>With head assertions: <pre><code>In[1]:= MatchQ[a*b, __Symbol]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= MatchQ[a*b, x__Symbol]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= MatchQ[a, __Symbol]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatchQ[a*b, x__Times]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= MatchQ[a*b, x__Plus]\nOut[5]= False\n</code></pre> <pre><code>In[6]:= MatchQ[a + b, x__Plus]\nOut[6]= True\n</code></pre></p>"},{"location":"builtin/pattern/condition/","title":"Condition","text":"<p><code>pat /; cond</code> matches an expression if the expression matches <code>pat</code>, and if <code>cond</code> evaluates to <code>True</code> with all the named patterns substituted in.</p> <p><code>Attributes[Condition] := {HoldAll, Protected}</code></p>"},{"location":"builtin/pattern/condition/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[5, Condition[_, True]]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[5, Condition[_, False]]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= MatchQ[5, Condition[y_, True]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatchQ[5, Condition[y_Real, True]]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= MatchQ[5, Condition[y_Integer, True]]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= MatchQ[5, Condition[y_, y == 0]]\nOut[6]= False\n</code></pre> <pre><code>In[7]:= MatchQ[5, Condition[y_, y == 5]]\nOut[7]= True\n</code></pre> <pre><code>In[8]:= ({3, 5, 2, 1}) //. ((Condition[{x___, y_, z_, k___}, Order[y, z] == -1] -&gt; {x, z, y, k}))\nOut[8]= {1, 2, 3, 5}\n</code></pre> <pre><code>In[9]:= Replace[1, a_Integer :&gt; Condition[myfn[a], (a) &gt; (0)]]\nOut[9]= myfn[1]\n</code></pre> <pre><code>In[10]:= Replace[-1, a_Integer :&gt; Condition[myfn[a], (a) &gt; (0)]]\nOut[10]= -1\n</code></pre> <pre><code>In[11]:= Replace[foo[2, 3], foo[x_, y_] :&gt; Condition[With[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[11]= 4\n</code></pre> <pre><code>In[12]:= Replace[foo[3, 3], foo[x_, y_] :&gt; Condition[With[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[12]= foo[3, 3]\n</code></pre> <pre><code>In[13]:= Replace[foo[2, 4], foo[x_, y_] :&gt; Condition[With[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[13]= foo[2, 4]\n</code></pre> <pre><code>In[14]:= Replace[bar[2], bar[x_] :&gt; With[{a = x}, Condition[x^2, a == 2]]]\nOut[14]= 4\n</code></pre> <pre><code>In[15]:= Replace[bar[3], bar[x_] :&gt; With[{a = x}, Condition[x^2, a == 2]]]\nOut[15]= bar[3]\n</code></pre> <pre><code>In[16]:= Replace[foo[2, 3], foo[x_, y_] :&gt; Condition[Module[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[16]= 4\n</code></pre> <pre><code>In[17]:= Replace[foo[3, 3], foo[x_, y_] :&gt; Condition[Module[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[17]= foo[3, 3]\n</code></pre> <pre><code>In[18]:= Replace[foo[2, 4], foo[x_, y_] :&gt; Condition[Module[{a = x}, Condition[x^2, a == 2]], y == 3]]\nOut[18]= foo[2, 4]\n</code></pre> <pre><code>In[19]:= Replace[bar[2], bar[x_] :&gt; Module[{a = x}, Condition[x^2, a == 2]]]\nOut[19]= 4\n</code></pre> <pre><code>In[20]:= Replace[bar[3], bar[x_] :&gt; Module[{a = x}, Condition[x^2, a == 2]]]\nOut[20]= bar[3]\n</code></pre> <pre><code>In[21]:= Replace[2, x_ :&gt; Condition[Condition[Condition[x^2, x == 2], x == 2], x == 2]]\nOut[21]= 4\n</code></pre> <pre><code>In[22]:= Replace[3, x_ :&gt; Condition[Condition[Condition[x^2, x == 2], x == 2], x == 2]]\nOut[22]= 3\n</code></pre></p>"},{"location":"builtin/pattern/except/","title":"Except","text":"<p><code>Except[pat]</code> matches all expressions except those that match <code>pat</code>.</p> <p><code>Except[pat1, pat2]</code> matches all expressions that match <code>pat2</code> but not <code>pat1</code>.</p> <p><code>Attributes[Except] := {Protected}</code></p>"},{"location":"builtin/pattern/except/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Cases[{5, 2, 3.5, x, y, 4}, Except[_Real]]\nOut[1]= {5, 2, x, y, 4}\n</code></pre> <pre><code>In[2]:= Cases[{5, 2, a^b, x, y, 4}, Except[_Symbol^_Symbol]]\nOut[2]= {5, 2, x, y, 4}\n</code></pre> <pre><code>In[3]:= ({a, b, 0, 1, 2, x, y}) /. ((Except[0, a_Integer] -&gt; foo[a]))\nOut[3]= {a, b, 0, foo[1], foo[2], x, y}\n</code></pre></p>"},{"location":"builtin/pattern/freeq/","title":"FreeQ","text":"<p><code>FreeQ[e, var]</code> returns True if <code>e</code> is free from any occurences of <code>var</code>.</p> <p><code>Attributes[FreeQ] := {Protected}</code></p>"},{"location":"builtin/pattern/holdpattern/","title":"HoldPattern","text":"<p><code>HoldPattern[expr]</code> leaves <code>expr</code> unevaluated but is seen as just <code>expr</code> for the purposes of pattern matching.</p> <p><code>Attributes[HoldPattern] := {HoldAll, Protected}</code></p>"},{"location":"builtin/pattern/holdpattern/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[2*x + 2*y, 2*_ + 2*_]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= MatchQ[2*x + 2*y, HoldPattern[2*_ + 2*_]]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= MatchQ[2*x + 2*y, HoldPattern[2*_ + HoldPattern[2*_]]]\nOut[3]= True\n</code></pre></p>"},{"location":"builtin/pattern/matchq/","title":"MatchQ","text":"<p><code>MatchQ[expr, form]</code> returns True if <code>expr</code> matches <code>form</code>, False otherwise.</p> <p><code>Attributes[MatchQ] := {Protected}</code></p>"},{"location":"builtin/pattern/matchq/#simple-examples","title":"Simple examples","text":"<p>A <code>Blank[]</code> expression matches everything: <pre><code>In[1]:= MatchQ[2*x, _]\nOut[1]= True\n</code></pre> Although a more specific pattern would have matched as well: <pre><code>In[2]:= MatchQ[2*x, c1_Integer*a_Symbol]\nOut[2]= True\n</code></pre> Since <code>Times</code> is <code>Orderless</code>, this would work as well: <pre><code>In[3]:= MatchQ[x*2, c1_Integer*a_Symbol]\nOut[3]= True\n</code></pre> As would the <code>FullForm</code>: <pre><code>In[4]:= MatchQ[x*2, c1_Integer*a_Symbol]\nOut[4]= True\n</code></pre> Named patterns must match the same expression, or the match will fail: <pre><code>In[5]:= MatchQ[a + b, x_Symbol + x_Symbol]\nOut[5]= False\n</code></pre></p>"},{"location":"builtin/pattern/matchq/#further-examples","title":"Further examples","text":"<p><pre><code>In[1]:= MatchQ[{2^a, a}, {2^x_Symbol, x_Symbol}]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[{2^a, b}, {2^x_Symbol, x_Symbol}]\nOut[2]= False\n</code></pre> <code>Blank</code> sequences allow for the matching of multiple objects. <code>BlankSequence</code> (__) matches one or more parts of the expression: <pre><code>In[3]:= MatchQ[{a, b}, {a, __}]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatchQ[{a}, {a, __}]\nOut[4]= False\n</code></pre> <code>BlankNullSequence</code> (___) allows for zero or more matches: <pre><code>In[5]:= MatchQ[{a}, {a, ___}]\nOut[5]= True\n</code></pre></p>"},{"location":"builtin/pattern/optional/","title":"Optional","text":"<p><code>Optional[pat, default]</code> attempts to match <code>pat</code> but uses <code>default</code> if not present.</p> <p><code>Attributes[Optional] := {Protected}</code></p>"},{"location":"builtin/pattern/pattern/","title":"Pattern","text":"<p><code>name{BLANKFORM}</code> is equivalent to <code>Pattern[name, {BLANKFORM}]</code> and can be used in pattern matching to refer to the matched expression as <code>name</code>, where <code>{BLANKFORM}</code> is one of <code>{_, __, ___}</code>.</p> <p><code>name{BLANKFORM}head</code> is equivalent to <code>Pattern[name, {BLANKFORM}head]</code> and can be used in pattern matching to refer to the matched expression as <code>name</code>, where <code>{BLANKFORM}</code> is one of <code>{_, __, ___}</code>.</p> <p><code>Attributes[Pattern] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/pattern/pattern/#simple-examples","title":"Simple examples","text":"<p>To demonstrate referencing <code>name</code> in the replacement RHS: <pre><code>In[1]:= (foo[2, 1]) /. ((foo[a_, b_] -&gt; a))\nOut[1]= 2\n</code></pre> If two matches share the same name, they must be equivalent: <pre><code>In[2]:= (foo[2, 1]) /. ((foo[a_, a_] -&gt; a))\nOut[2]= foo[2, 1]\n</code></pre> <pre><code>In[3]:= (foo[2, 2]) /. ((foo[a_, a_] -&gt; a))\nOut[3]= 2\n</code></pre> To demonstrate the head matching capability: <pre><code>In[4]:= MatchQ[2, a_Integer]\nOut[4]= True\n</code></pre> <pre><code>In[5]:= MatchQ[2, a_Real]\nOut[5]= False\n</code></pre></p>"},{"location":"builtin/pattern/pattern/#further-examples","title":"Further examples","text":"<p>To demonstrate patterns matching a sequence of expressions: <pre><code>In[1]:= (foo[2, 1]) /. ((foo[a___Integer] -&gt; bar[a]))\nOut[1]= bar[2, 1]\n</code></pre></p>"},{"location":"builtin/pattern/patterntest/","title":"PatternTest","text":"<p><code>pat?test</code> matches when the expression matches <code>pat</code> and <code>test[MATCH]</code> evaluates to <code>True</code>.</p> <p><code>Attributes[PatternTest] := {HoldRest, Protected}</code></p>"},{"location":"builtin/pattern/patterntest/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= MatchQ[1, PatternTest[_, NumberQ]]\nOut[1]= True\n</code></pre> <pre><code>In[2]:= MatchQ[a, PatternTest[_, NumberQ]]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= MatchQ[1, PatternTest[1, NumberQ]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= MatchQ[1, PatternTest[1.5, NumberQ]]\nOut[4]= False\n</code></pre> <pre><code>In[5]:= MatchQ[1.5, PatternTest[1.5, NumberQ]]\nOut[5]= True\n</code></pre> <pre><code>In[6]:= Cases[{5, 2, a^b, x, y, 4.5}, PatternTest[_, NumberQ]]\nOut[6]= {5, 2, 4.5}\n</code></pre></p>"},{"location":"builtin/pattern/repeated/","title":"Repeated","text":"<p><code>Repeated[p_]</code> matches a sequence of expressions that match the pattern <code>p</code>.</p> <p><code>Attributes[Repeated] := {Protected}</code></p>"},{"location":"builtin/pattern/replacelist/","title":"ReplaceList","text":"<p><code>ReplaceList[expr, rule]</code> returns all the possible replacements using <code>rule</code> on <code>expr</code>.</p> <p><code>Attributes[ReplaceList] := {Protected}</code></p>"},{"location":"builtin/pattern/replacelist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ReplaceList[a + b, x_ + y_ -&gt; {x, y}]\nOut[1]= {{a, b}, {b, a}}\n</code></pre> <pre><code>In[2]:= ReplaceList[foo[a + b, b], foo[j_ + k_, j_] -&gt; {j, k}]\nOut[2]= {{b, a}}\n</code></pre> <pre><code>In[3]:= ReplaceList[foo[a + b], foo[x_ + y_] -&gt; {x, y}]\nOut[3]= {{a, b}, {b, a}}\n</code></pre> <pre><code>In[4]:= ReplaceList[bar[foo[a + b] + c], bar[foo[x_ + y_] + z_] -&gt; {x, y, z}]\nOut[4]= {{a, b, c}, {b, a, c}}\n</code></pre> <pre><code>In[5]:= ReplaceList[bar[foo[a + b] + c + d], bar[w_ + x_ + foo[y_ + z_]] -&gt; {w, x, y, z}]\nOut[5]= {{c, d, a, b}, {c, d, b, a}, {d, c, a, b}, {d, c, b, a}}\n</code></pre> <pre><code>In[6]:= ReplaceList[foo[a + b, c], foo[j_ + k_, j_] -&gt; {j, k}]\nOut[6]= {}\n</code></pre></p>"},{"location":"builtin/plot/","title":"plot documentation","text":"<p>Plot</p>"},{"location":"builtin/plot/plot/","title":"Plot","text":"<p><code>Plot[fn, {var, min, max}]</code> plots <code>fn</code> over the range specified.</p> <p><code>Attributes[Plot] := {HoldAll, Protected, ReadProtected}</code></p>"},{"location":"builtin/power/","title":"power documentation","text":"<p>Power</p> <p>Expand</p> <p>ExpandAll</p> <p>Log</p> <p>Sqrt</p> <p>I</p> <p>PolynomialQ</p> <p>Exponent</p> <p>Coefficient</p> <p>CoefficientList</p> <p>PolynomialQuotientRemainder</p> <p>PolynomialQuotient</p> <p>PolynomialRemainder</p> <p>FactorTermsList</p> <p>FactorTerms</p> <p>ExpreduceFactorConstant</p> <p>Variables</p> <p>PolynomialGCD</p> <p>SquareFreeQ</p> <p>FactorSquareFree</p> <p>Arg</p> <p>ComplexExpand</p> <p>Exp</p> <p>Conjugate</p>"},{"location":"builtin/power/arg/","title":"Arg","text":"<p><code>Arg[x]</code> computes the argument of <code>x</code>.</p> <p><code>Attributes[Arg] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/power/arg/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Arg[(1*E^(I*(Pi)/(4)))/(2)]\nOut[1]= (Pi)/(4)\n</code></pre>"},{"location":"builtin/power/coefficient/","title":"Coefficient","text":"<p><code>Coefficient[p, form]</code> returns the coefficient of form <code>form</code> in polynomial <code>p</code>.</p> <p><code>Attributes[Coefficient] := {Listable, Protected}</code></p>"},{"location":"builtin/power/coefficient/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Coefficient[(a + b)^3, a*b^2]\nOut[1]= 3\n</code></pre>"},{"location":"builtin/power/coefficientlist/","title":"CoefficientList","text":"<p><code>CoefficientList[p, var]</code> returns the list of coefficients associated with variable <code>var</code>.</p> <p><code>Attributes[CoefficientList] := {Protected}</code></p>"},{"location":"builtin/power/coefficientlist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= CoefficientList[b + 3*x + 5*x^2, x]\nOut[1]= {b, 3, 5}\n</code></pre> <pre><code>In[2]:= CoefficientList[5*x^2, x]\nOut[2]= {0, 0, 5}\n</code></pre> <pre><code>In[3]:= CoefficientList[(a*-1 + x)/(b), x]\nOut[3]= {(a)/(b)*-1, (1)/(b)}\n</code></pre></p>"},{"location":"builtin/power/complexexpand/","title":"ComplexExpand","text":"<p><code>ComplexExpand[e]</code> returns a complex expansion of <code>e</code>.</p> <p><code>Attributes[ComplexExpand] := {Protected}</code></p>"},{"location":"builtin/power/complexexpand/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ComplexExpand[a]\nOut[1]= a\n</code></pre> <pre><code>In[2]:= ComplexExpand[1]\nOut[2]= 1\n</code></pre> <pre><code>In[3]:= ComplexExpand[a*(b + c)]\nOut[3]= a*b + a*c\n</code></pre> <pre><code>In[4]:= ComplexExpand[-1^(1)/(3)]\nOut[4]= (1)/(2) + (I*Sqrt[3])/(2)\n</code></pre> <pre><code>In[5]:= ComplexExpand[-1^(4)/(3)]\nOut[5]= (1)/(2)*-1 + ((I*Sqrt[3]))/(2)*-1\n</code></pre> <pre><code>In[6]:= ComplexExpand[2^(4)/(3)]\nOut[6]= 2*2^(1)/(3)\n</code></pre> <pre><code>In[7]:= ComplexExpand[-1^(1)/(3)*(1 + I*Sqrt[3])]\nOut[7]= -1 + I*Sqrt[3]\n</code></pre> <pre><code>In[8]:= ComplexExpand[d*E^((a + I*b)*c)]\nOut[8]= d*E^(a*c)*Cos[b*c] + d*I*E^(a*c)*Sin[b*c]\n</code></pre> <pre><code>In[9]:= ComplexExpand[(1*E^(I*(Pi)/(4)))/(2)]\nOut[9]= ((1)/(2) + (I)/(2))/(Sqrt[2])\n</code></pre></p>"},{"location":"builtin/power/conjugate/","title":"Conjugate","text":"<p><code>Conjugate[x]</code> computes the complex conjugate of <code>x</code>.</p> <p><code>Attributes[Conjugate] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/power/conjugate/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Conjugate[4 + 4*I]\nOut[1]= 4 + (4*I)*-1\n</code></pre> <pre><code>In[2]:= Conjugate[4*I]\nOut[2]= -4*I\n</code></pre> <pre><code>In[3]:= Conjugate[4]\nOut[3]= 4\n</code></pre></p>"},{"location":"builtin/power/exp/","title":"Exp","text":"<p><code>Exp[x]</code> returns the exponential of <code>x</code>.</p> <p><code>Attributes[Exp] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/power/exp/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= True\nOut[1]= Simplify[Exp[x]*Exp[y] == Exp[x + y]]\n</code></pre>"},{"location":"builtin/power/expand/","title":"Expand","text":"<p><code>Expand[expr]</code> attempts to expand <code>expr</code>.</p> <p><code>Attributes[Expand] := {Protected}</code></p>"},{"location":"builtin/power/expand/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Expand[(a + b + c)^3]\nOut[1]= a^3 + 3*a^2*b + 3*a*b^2 + b^3 + 3*a^2*c + 6*a*b*c + 3*b^2*c + 3*a*c^2 + 3*b*c^2 + c^3\n</code></pre> <pre><code>In[2]:= Expand[(a + b)*(c + d + e)]\nOut[2]= a*c + b*c + a*d + b*d + a*e + b*e\n</code></pre> <pre><code>In[3]:= Expand[(a + b + c)*(d + e)^2]\nOut[3]= a*d^2 + b*d^2 + c*d^2 + 2*a*d*e + 2*b*d*e + 2*c*d*e + a*e^2 + b*e^2 + c*e^2\n</code></pre> <pre><code>In[4]:= Expand[(a^b + c^d)^2]\nOut[4]= a^(2*b) + 2*a^b*c^d + c^(2*d)\n</code></pre> <pre><code>In[5]:= Expand[(a + b + c)/(d)]\nOut[5]= (a)/(d) + (b)/(d) + (c)/(d)\n</code></pre> <pre><code>In[6]:= Expand[((a + 1)^2 + b + c)/(d)]\nOut[6]= (1)/(d) + (2*a)/(d) + (a^2)/(d) + (b)/(d) + (c)/(d)\n</code></pre> <pre><code>In[7]:= Expand[2*(a + 1)]\nOut[7]= 2 + 2*a\n</code></pre></p>"},{"location":"builtin/power/expandall/","title":"ExpandAll","text":"<p><code>ExpandAll[expr]</code> attempts to expand <code>expr</code> at all levels.</p> <p><code>Attributes[ExpandAll] := {Protected}</code></p>"},{"location":"builtin/power/expandall/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= ExpandAll[Log[(x + 1)*(x + 1*-1)]]\nOut[1]= Log[-1 + x^2]\n</code></pre>"},{"location":"builtin/power/exponent/","title":"Exponent","text":"<p><code>Exponent[p, var]</code> returns the degree of <code>p</code> with respect to the variable <code>var</code>.</p> <p><code>Attributes[Exponent] := {Listable, Protected}</code></p>"},{"location":"builtin/power/exponent/#simple-examples","title":"Simple examples","text":"<p>Find the degree of a polynomial: <pre><code>In[1]:= Exponent[3 + x^3 + k*x^5, x]\nOut[1]= 5\n</code></pre></p>"},{"location":"builtin/power/exponent/#further-examples","title":"Further examples","text":"<p>Find the degree of a polynomial: <pre><code>In[1]:= Exponent[3 + x^3 + k*x^5, x, List]\nOut[1]= {0, 3, 5}\n</code></pre></p>"},{"location":"builtin/power/expreducefactorconstant/","title":"ExpreduceFactorConstant","text":"<p><code>Attributes[ExpreduceFactorConstant] := {Protected}</code></p>"},{"location":"builtin/power/factorsquarefree/","title":"FactorSquareFree","text":"<p><code>FactorSquareFree[poly]</code> computes the square free factorization of <code>poly</code>.</p> <p><code>Attributes[FactorSquareFree] := {Listable, Protected}</code></p>"},{"location":"builtin/power/factorsquarefree/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FactorSquareFree[1 + (2*x^2)*-1 + x^4]\nOut[1]= (-1 + x^2)^2\n</code></pre> <pre><code>In[2]:= FactorSquareFree[1 + x^2*-1 + x^3*-1 + x^5]\nOut[2]= (-1 + x)^2*(1 + 2*x + 2*x^2 + x^3)\n</code></pre> <pre><code>In[3]:= FactorSquareFree[18 + (39*x)*-1 + 29*x^2 + (9*x^3)*-1 + x^4]\nOut[3]= (-3 + x)^2*(2 + (3*x)*-1 + x^2)\n</code></pre> <pre><code>In[4]:= FactorSquareFree[-108 + (108*x)*-1 + 207*x^2 + 239*x^3 + (81*x^4)*-1 + (153*x^5)*-1 + (27*x^6)*-1 + 21*x^7 + 9*x^8 + x^9]\nOut[4]= (3 + x)^3*(-4 + x^2)*(-1 + x^2)^2\n</code></pre></p>"},{"location":"builtin/power/factorterms/","title":"FactorTerms","text":"<p><code>FactorTerms[expr]</code> factors out the constant term of <code>expr</code>, if any.</p> <p><code>Attributes[FactorTerms] := {Protected}</code></p>"},{"location":"builtin/power/factorterms/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FactorTerms[2*Sin[8*k]]\nOut[1]= 2*Sin[8*k]\n</code></pre> <pre><code>In[2]:= FactorTerms[(a)/(2) + (x)/(2)]\nOut[2]= (1)/(2)*(a + x)\n</code></pre> <pre><code>In[3]:= FactorTerms[a + x]\nOut[3]= a + x\n</code></pre></p>"},{"location":"builtin/power/factortermslist/","title":"FactorTermsList","text":"<p><code>FactorTermsList[expr]</code> factors out the constant term of <code>expr</code> and puts the factored result into a <code>List</code>.</p> <p><code>Attributes[FactorTermsList] := {Protected}</code></p>"},{"location":"builtin/power/factortermslist/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= FactorTermsList[2*Sin[8*k]]\nOut[1]= {2, Sin[8*k]}\n</code></pre> <pre><code>In[2]:= FactorTermsList[(a)/(2) + (x)/(2)]\nOut[2]= {(1)/(2), a + x}\n</code></pre> <pre><code>In[3]:= FactorTermsList[a + x]\nOut[3]= {1, a + x}\n</code></pre></p>"},{"location":"builtin/power/i/","title":"I","text":"<p><code>I</code> is the imaginary number representing <code>Sqrt[-1]</code>.</p> <p><code>Attributes[I] := {Locked, Protected, ReadProtected}</code></p>"},{"location":"builtin/power/i/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= I^2\nOut[1]= -1\n</code></pre> <pre><code>In[2]:= I^4\nOut[2]= 1\n</code></pre></p>"},{"location":"builtin/power/log/","title":"Log","text":"<p><code>Log[e]</code> finds the natural logarithm of <code>e</code>.</p> <p><code>Attributes[Log] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/power/log/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Log[E]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Log[E^-2]\nOut[2]= -2\n</code></pre> <pre><code>In[3]:= Log[2]\nOut[3]= Log[2]\n</code></pre></p>"},{"location":"builtin/power/polynomialgcd/","title":"PolynomialGCD","text":"<p><code>PolynomialGCD[a, b]</code> calculates the polynomial GCD of <code>a</code> and <code>b</code>.</p> <p><code>Attributes[PolynomialGCD] := {Listable, Protected}</code></p>"},{"location":"builtin/power/polynomialgcd/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PolynomialGCD[15 + 13*a + 2*a^2, 10 + 7*a + a^2]\nOut[1]= 5 + a\n</code></pre> <pre><code>In[2]:= PolynomialGCD[15 + 13*a + 5*a^2 + 2*a^3, 10 + 7*a + 3*a^2 + a^3]\nOut[2]= 5 + a + a^2\n</code></pre> <pre><code>In[3]:= PolynomialGCD[15 + 13*a + a^2*-1 + (2*a^3)*-1, 5 + a + a^2*-1]\nOut[3]= -5 + a*-1 + a^2\n</code></pre></p>"},{"location":"builtin/power/polynomialq/","title":"PolynomialQ","text":"<p><code>PolynomialQ[e, var]</code> returns True if <code>e</code> is a polynomial in <code>var</code>.</p> <p><code>Attributes[PolynomialQ] := {Protected}</code></p>"},{"location":"builtin/power/polynomialquotient/","title":"PolynomialQuotient","text":"<p><code>PolynomialQuotient[poly_, div_, var_]</code> returns the quotient of <code>poly</code> divided by <code>div</code> treating <code>var</code> as the polynomial variable.</p> <p><code>Attributes[PolynomialQuotient] := {Protected}</code></p>"},{"location":"builtin/power/polynomialquotient/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PolynomialQuotient[2 + x^2 + x^3, 2 + 2*x, x]\nOut[1]= (x^2)/(2)\n</code></pre> <pre><code>In[2]:= PolynomialQuotient[x^3, x + y, x]\nOut[2]= x^2 + (x*y)*-1 + y^2\n</code></pre> <pre><code>In[3]:= PolynomialQuotient[1 + x^3, 1 + a*x^2, x]\nOut[3]= (x)/(a)\n</code></pre></p>"},{"location":"builtin/power/polynomialquotientremainder/","title":"PolynomialQuotientRemainder","text":"<p><code>PolynomialQuotientRemainder[poly_, div_, var_]</code> returns the quotient and remainder of <code>poly</code> divided by <code>div</code> treating <code>var</code> as the polynomial variable.</p> <p><code>Attributes[PolynomialQuotientRemainder] := {Protected}</code></p>"},{"location":"builtin/power/polynomialquotientremainder/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PolynomialQuotientRemainder[2 + x^2 + x^3, 2 + 2*x, x]\nOut[1]= {(x^2)/(2), 2}\n</code></pre> <pre><code>In[2]:= PolynomialQuotientRemainder[x^3, x + y, x]\nOut[2]= {x^2 + (x*y)*-1 + y^2, y^3*-1}\n</code></pre> <pre><code>In[3]:= PolynomialQuotientRemainder[1 + x^3, 1 + a*x^2, x]\nOut[3]= {(x)/(a), 1 + (x)/(a)*-1}\n</code></pre></p>"},{"location":"builtin/power/polynomialremainder/","title":"PolynomialRemainder","text":"<p><code>PolynomialRemainder[poly_, div_, var_]</code> returns the remainder of <code>poly</code> divided by <code>div</code> treating <code>var</code> as the polynomial variable.</p> <p><code>Attributes[PolynomialRemainder] := {Protected}</code></p>"},{"location":"builtin/power/polynomialremainder/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PolynomialRemainder[2 + x^2 + x^3, 2 + 2*x, x]\nOut[1]= 2\n</code></pre> <pre><code>In[2]:= PolynomialRemainder[x^3, x + y, x]\nOut[2]= y^3*-1\n</code></pre> <pre><code>In[3]:= PolynomialRemainder[1 + x^3, 1 + a*x^2, x]\nOut[3]= 1 + (x)/(a)*-1\n</code></pre></p>"},{"location":"builtin/power/power/","title":"Power","text":"<p><code>base^exp</code> finds <code>base</code> raised to the power of <code>exp</code>.</p> <p><code>Attributes[Power] := {Listable, NumericFunction, OneIdentity, Protected}</code></p>"},{"location":"builtin/power/power/#simple-examples","title":"Simple examples","text":"<p>Exponents of integers are computed exactly: <pre><code>In[1]:= -5^-3\nOut[1]= (-1)/(125)\n</code></pre> Floating point exponents are handled with floating point precision: <pre><code>In[2]:= .5^-10000.\nOut[2]= 1.99506e+3010\n</code></pre> Automatically apply some basic simplification rules: <pre><code>In[3]:= (m^2.)^2\nOut[3]= m^4.\n</code></pre></p>"},{"location":"builtin/power/power/#further-examples","title":"Further examples","text":"<p>Expreduce handles problematic exponents accordingly: <pre><code>In[1]:= 0^0\nOut[1]= Indeterminate\n</code></pre> <pre><code>In[2]:= (1/(0))\nOut[2]= ComplexInfinity\n</code></pre></p>"},{"location":"builtin/power/sqrt/","title":"Sqrt","text":"<p><code>Sqrt[e]</code> finds the square root of <code>e</code>.</p> <p><code>Attributes[Sqrt] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/power/sqrt/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Sqrt[3]\nOut[1]= Sqrt[3]\n</code></pre> <pre><code>In[2]:= Sqrt[-1]\nOut[2]= I\n</code></pre> <pre><code>In[3]:= Sqrt[-3]\nOut[3]= I*Sqrt[3]\n</code></pre> <pre><code>In[4]:= Sqrt[1]\nOut[4]= 1\n</code></pre> <pre><code>In[5]:= Sqrt[0]\nOut[5]= 0\n</code></pre></p>"},{"location":"builtin/power/squarefreeq/","title":"SquareFreeQ","text":"<p><code>SquareFreeQ[expr]</code> returns True if <code>expr</code> is a square-free polynomial.</p> <p><code>Attributes[SquareFreeQ] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/power/squarefreeq/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= SquareFreeQ[Expand[(x + 1)*(x + 2)^2]]\nOut[1]= False\n</code></pre> <pre><code>In[2]:= SquareFreeQ[(x + 1)*(x + 2)]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= SquareFreeQ[Expand[(2*x + 3)*(x + 2)]]\nOut[3]= True\n</code></pre> <pre><code>In[4]:= SquareFreeQ[(2*x + 3)^2]\nOut[4]= False\n</code></pre></p>"},{"location":"builtin/power/variables/","title":"Variables","text":"<p><code>Variables[expr]</code> returns the variables in <code>expr</code>.</p> <p><code>Attributes[Variables] := {Protected}</code></p>"},{"location":"builtin/power/variables/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Variables[x + y + y^2]\nOut[1]= {x, y}\n</code></pre> <pre><code>In[2]:= Variables[w^w + x^y + z]\nOut[2]= {w^w, x^y, z}\n</code></pre> <pre><code>In[3]:= Variables[a^2*b^(2*c + 2*d)]\nOut[3]= {a, b^c, b^d}\n</code></pre></p>"},{"location":"builtin/random/","title":"random documentation","text":"<p>RandomReal</p> <p>SeedRandom</p>"},{"location":"builtin/random/randomreal/","title":"RandomReal","text":"<p><code>RandomReal[]</code> generates a random floating point from 0 to 1.</p> <p><code>RandomReal[max]</code> generates a random floating point from 0 to <code>max</code>.</p> <p><code>RandomReal[min, max]</code> generates a random floating point from <code>min</code> to `max.</p> <p><code>Attributes[RandomReal] := {Protected}</code></p>"},{"location":"builtin/random/randomreal/#details","title":"Details","text":"<p><code>SeedRandom[UnixTime[]]</code> is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.</p>"},{"location":"builtin/random/randomreal/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= RandomReal[]\nOut[1]= 0.0750914\n</code></pre>"},{"location":"builtin/random/randomreal/#further-examples","title":"Further examples","text":"<p>Use <code>SeedRandom</code> to seed the RNG: <pre><code>In[1]:= SeedRandom[3]\nOut[1]= Null\n</code></pre> <pre><code>In[2]:= RandomReal[]\nOut[2]= 0.719983\n</code></pre> <pre><code>In[3]:= RandomReal[]\nOut[3]= 0.652631\n</code></pre> <pre><code>In[4]:= SeedRandom[3]\nOut[4]= Null\n</code></pre> <pre><code>In[5]:= RandomReal[]\nOut[5]= 0.719983\n</code></pre></p>"},{"location":"builtin/random/seedrandom/","title":"SeedRandom","text":"<p><code>SeedRandom[seed]</code> seeds the internal random number generator with a given integer <code>seed</code>.</p> <p><code>Attributes[SeedRandom] := {Protected}</code></p>"},{"location":"builtin/random/seedrandom/#details","title":"Details","text":"<p><code>SeedRandom[UnixTime[]]</code> is called automatically upon initialization of Expreduce, so random number sequences will not repeat over subsequent sessions.</p>"},{"location":"builtin/random/seedrandom/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= RandomReal[]\nOut[1]= 0.0750914\n</code></pre> <pre><code>In[2]:= SeedRandom[3]\nOut[2]= Null\n</code></pre> <pre><code>In[3]:= RandomReal[]\nOut[3]= 0.719983\n</code></pre> <pre><code>In[4]:= RandomReal[]\nOut[4]= 0.652631\n</code></pre> <pre><code>In[5]:= SeedRandom[3]\nOut[5]= Null\n</code></pre> <pre><code>In[6]:= RandomReal[]\nOut[6]= 0.719983\n</code></pre></p>"},{"location":"builtin/replacement/","title":"replacement documentation","text":"<p>ReplaceAll</p> <p>Replace</p> <p>ReplaceRepeated</p> <p>Rule</p> <p>RuleDelayed</p> <p>ReplacePart</p>"},{"location":"builtin/replacement/replace/","title":"Replace","text":"<p><code>Replace[expr, rules]</code> applies <code>rules</code> to <code>expr</code> if they match at the base level.</p> <p><code>Attributes[Replace] := {Protected}</code></p>"},{"location":"builtin/replacement/replace/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Replace[a + b, a + b -&gt; 2]\nOut[1]= 2\n</code></pre> <pre><code>In[2]:= Replace[a + b, a -&gt; 2]\nOut[2]= a + b\n</code></pre> <pre><code>In[3]:= Replace[a + b, _ -&gt; 2]\nOut[3]= 2\n</code></pre> <pre><code>In[4]:= Replace[a + b, {a + b -&gt; c + d, c + d -&gt; 3}]\nOut[4]= c + d\n</code></pre></p>"},{"location":"builtin/replacement/replaceall/","title":"ReplaceAll","text":"<p><code>expr /. rule</code> replaces all occurences of the LHS of <code>rule</code> with the RHS of <code>rule</code> in <code>expr</code>.</p> <p><code>expr /. {r1, r2, ...}</code> performes the same operation as <code>expr /. rule</code>, but evaluating each <code>r_n</code> in sequence.</p> <p><code>Attributes[ReplaceAll] := {Protected}</code></p>"},{"location":"builtin/replacement/replaceall/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ((2^(x^2 + 1) + x^2)) /. ((x^2 -&gt; y))\nOut[1]= 2^(y + 1) + y\n</code></pre> If no match is found, <code>ReplaceAll</code> evaluates to an unchanged <code>expr</code>: <pre><code>In[2]:= ((2^(x^2 + 1) + x^2)) /. ((z^2 -&gt; y))\nOut[2]= 2^(x^2 + 1) + x^2\n</code></pre> <code>ReplaceAll</code> works within Orderless expressions as well (such as <code>Plus</code>): <pre><code>In[3]:= ((a + b + c + c^2)) /. ((c^2 + a -&gt; d))\nOut[3]= b + c + d\n</code></pre> <code>ReplaceAll</code> can use named patterns: <pre><code>In[4]:= ((a + b + c + d)) /. ((x_Symbol + y_Symbol -&gt; x^y))\nOut[4]= a^b + c + d\n</code></pre> <pre><code>In[5]:= ((a + 2*b + 5*c)) /. ((c1_Integer*a_Symbol -&gt; 99*a))\nOut[5]= a + 99*b + 99*c\n</code></pre></p>"},{"location":"builtin/replacement/replaceall/#further-examples","title":"Further examples","text":"<p><code>ReplaceAll</code> can be used to replace sequences of expressions: <pre><code>In[1]:= ((a + b + c + d)) /. ((a + amatch___ -&gt; foo[amatch]))\nOut[1]= foo[b, c, d]\n</code></pre> The <code>Head</code> of functions can be replaced just as the subexpressions: <pre><code>In[2]:= ((x + 2)[5, 6]) /. ((2 + x -&gt; Plus))\nOut[2]= 11\n</code></pre> <pre><code>In[3]:= ((a*b*c*d)) /. ((_Symbol -&gt; 2))\nOut[3]= 2[2, 2, 2, 2]\n</code></pre></p>"},{"location":"builtin/replacement/replacepart/","title":"ReplacePart","text":"<p><code>ReplacePart[e, {loc1 -&gt; newval1, ...}]</code> replaces the value at the locations with their corresponding new values in <code>e</code>.</p> <p><code>Attributes[ReplacePart] := {Protected}</code></p>"},{"location":"builtin/replacement/replacepart/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ReplacePart[Range[4], foo, 2]\nOut[1]= {1, foo, 3, 4}\n</code></pre> <pre><code>In[2]:= ReplacePart[Range[4], 3 -&gt; foo]\nOut[2]= {1, 2, foo, 4}\n</code></pre> <pre><code>In[3]:= ReplacePart[Range[4], {3} -&gt; foo]\nOut[3]= {1, 2, foo, 4}\n</code></pre> <pre><code>In[4]:= ReplacePart[Range[4], {3, 1} -&gt; foo]\nOut[4]= {1, 2, 3, 4}\n</code></pre></p>"},{"location":"builtin/replacement/replacepart/#further-examples","title":"Further examples","text":"<p><pre><code>In[1]:= ReplacePart[Range[4], i_ -&gt; foo]\nOut[1]= {foo, foo, foo, foo}\n</code></pre> <pre><code>In[2]:= ReplacePart[Range[4], 7 -&gt; foo]\nOut[2]= {1, 2, 3, 4}\n</code></pre> <pre><code>In[3]:= ReplacePart[a + b^c, {2, 2} -&gt; foo]\nOut[3]= a + b^foo\n</code></pre> <pre><code>In[4]:= ReplacePart[a + b^c, {2, 2, 1} -&gt; foo]\nOut[4]= a + b^c\n</code></pre></p>"},{"location":"builtin/replacement/replacerepeated/","title":"ReplaceRepeated","text":"<p><code>expr //. rule</code> replaces all occurences of the LHS of <code>rule</code> with the RHS of <code>rule</code> in <code>expr</code> repeatedly until the expression stabilizes.</p> <p><code>expr //. {r1, r2, ...}</code> performes the same operation as <code>expr //. rule</code>, but evaluating each <code>r_n</code> in sequence.</p> <p><code>Attributes[ReplaceRepeated] := {Protected}</code></p>"},{"location":"builtin/replacement/replacerepeated/#simple-examples","title":"Simple examples","text":"<p><code>ReplaceRepeated</code> can be used to implement logarithm expansion: <pre><code>In[1]:= logRules := {Log[x_*y_] :&gt; (Log[x] + Log[y]), Log[x_^k_] :&gt; (k*Log[x])}\nOut[1]= Null\n</code></pre> <pre><code>In[2]:= (Log[a^b*b^(c^d)]) //. (logRules)\nOut[2]= b*Log[a] + c^d*Log[b]\n</code></pre></p>"},{"location":"builtin/replacement/rule/","title":"Rule","text":"<p><code>lhs -&gt; rhs</code> can be used in replacement functions to say that instances of <code>lhs</code> should be replaced with <code>rhs</code>.</p> <p><code>Attributes[Rule] := {Protected, SequenceHold}</code></p>"},{"location":"builtin/replacement/rule/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ((2^(x^2 + 1) + x^2)) /. ((x^2 -&gt; y))\nOut[1]= 2^(y + 1) + y\n</code></pre> To demonstrate the difference between <code>Rule</code> and <code>RuleDelayed</code>: <pre><code>In[2]:= Apply[Equal, ({1, 1}) /. ((1 -&gt; RandomReal[]))]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= Apply[Equal, ({1, 1}) /. ((1 :&gt; RandomReal[]))]\nOut[3]= False\n</code></pre></p>"},{"location":"builtin/replacement/ruledelayed/","title":"RuleDelayed","text":"<p><code>lhs :&gt; rhs</code> can be used in replacement functions to say that instances of <code>lhs</code> should be replaced with <code>rhs</code>, evaluating <code>rhs</code> only after replacement.</p> <p><code>Attributes[RuleDelayed] := {HoldRest, Protected, SequenceHold}</code></p>"},{"location":"builtin/replacement/ruledelayed/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ((2^(x^2 + 1) + x^2)) /. (((x^2) :&gt; y))\nOut[1]= 2^(y + 1) + y\n</code></pre> To demonstrate the difference between <code>Rule</code> and <code>RuleDelayed</code>: <pre><code>In[2]:= Apply[Equal, ({1, 1}) /. ((1 -&gt; RandomReal[]))]\nOut[2]= True\n</code></pre> <pre><code>In[3]:= Apply[Equal, ({1, 1}) /. ((1 :&gt; RandomReal[]))]\nOut[3]= False\n</code></pre></p>"},{"location":"builtin/rubi/","title":"rubi documentation","text":"<p>LoadRubi</p> <p>LoadRubiSnapshot</p> <p>LoadRubiBundledSnapshot</p> <p>SaveRubiSnapshot</p>"},{"location":"builtin/rubi/loadrubi/","title":"LoadRubi","text":"<p><code>LoadRubi[]</code> will load the Rubi integration package by Albert Rich.</p> <p><code>Attributes[LoadRubi] := {Protected}</code></p>"},{"location":"builtin/rubi/loadrubi/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= LoadRubiBundledSnapshot[]\nOut[1]= Null\n</code></pre> <pre><code>In[2]:= Rubi`Int[x^2 + 2, x]\nOut[2]= (x^3)/(3) + 2*x\n</code></pre> <pre><code>In[3]:= Rubi`Int[Csch[a + b*x]^5, x]\nOut[3]= (-3*ArcTanh[Cosh[a + b*x]])/(8*b) + (3*Coth[a + b*x]*Csch[a + b*x])/(8*b) + ((Coth[a + b*x]*Csch[a + b*x]^3))/((4*b))*-1\n</code></pre> <pre><code>In[4]:= Rubi`Int[(1)/(x), x]\nOut[4]= Log[x]\n</code></pre> <pre><code>In[5]:= Rubi`Int[(a + b*x)/(x^5), x]\nOut[5]= (a)/((4*x^4))*-1 + (b)/((3*x^3))*-1\n</code></pre></p>"},{"location":"builtin/rubi/loadrubibundledsnapshot/","title":"LoadRubiBundledSnapshot","text":"<p><code>Attributes[LoadRubiBundledSnapshot] := {Protected}</code></p>"},{"location":"builtin/rubi/loadrubisnapshot/","title":"LoadRubiSnapshot","text":"<p><code>Attributes[LoadRubiSnapshot] := {Protected}</code></p>"},{"location":"builtin/rubi/saverubisnapshot/","title":"SaveRubiSnapshot","text":"<p><code>Attributes[SaveRubiSnapshot] := {Protected}</code></p>"},{"location":"builtin/simplify/","title":"simplify documentation","text":"<p>Simplify</p> <p>FullSimplify</p>"},{"location":"builtin/simplify/fullsimplify/","title":"FullSimplify","text":"<p><code>FullSimplify[expr]</code> attempts to perform full simplification operations on <code>expr</code>.</p> <p><code>Attributes[FullSimplify] := {Protected}</code></p>"},{"location":"builtin/simplify/fullsimplify/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= FullSimplify[E^(x*-1) + E^x]\nOut[1]= 2*Cosh[x]\n</code></pre>"},{"location":"builtin/simplify/simplify/","title":"Simplify","text":"<p><code>Simplify[expr]</code> attempts to perform simplification operations on <code>expr</code>.</p> <p><code>Attributes[Simplify] := {Protected}</code></p>"},{"location":"builtin/simplify/simplify/#simple-examples","title":"Simple examples","text":"<p><code>Simplify</code> can simplify some boolean expressions. <pre><code>In[1]:= Simplify[b &amp;&amp; b]\nOut[1]= b\n</code></pre> <pre><code>In[2]:= Simplify[a &amp;&amp; b &amp;&amp; Not[b]]\nOut[2]= False\n</code></pre> <pre><code>In[3]:= Simplify[(a || b) &amp;&amp; (a || c)]\nOut[3]= a || (b &amp;&amp; c)\n</code></pre> <pre><code>In[4]:= Simplify[a || (Not[a] &amp;&amp; b)]\nOut[4]= a || b\n</code></pre> <pre><code>In[5]:= Simplify[a || b || Not[a] || Not[b]]\nOut[5]= True\n</code></pre></p>"},{"location":"builtin/solve/","title":"solve documentation","text":"<p>Solve</p> <p>ConditionalExpression</p>"},{"location":"builtin/solve/conditionalexpression/","title":"ConditionalExpression","text":"<p><code>ConditionalExpression[expr, conditions]</code> represents <code>expr</code> which is conditional on <code>conditions</code>.</p> <p><code>Attributes[ConditionalExpression] := {Protected}</code></p>"},{"location":"builtin/solve/solve/","title":"Solve","text":"<p><code>Solve[eqn, var]</code> solves <code>eqn</code> for <code>var</code>.</p> <p><code>Attributes[Solve] := {Protected}</code></p>"},{"location":"builtin/solve/solve/#details","title":"Details","text":"<p>!!! warning \"Under development\"     This function is under development, and as such will be incomplete and inaccurate. The function currently only knows how to solve a few example forms of equations.</p>"},{"location":"builtin/solve/solve/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Solve[(a + b)^x == y, x]\nOut[1]= {{x -&gt; (Log[y])/(Log[a + b])}}\n</code></pre> <pre><code>In[2]:= Solve[y == x^2 + 3, x]\nOut[2]= {{x -&gt; Sqrt[-3 + y]*-1}, {x -&gt; Sqrt[-3 + y]}}\n</code></pre> <pre><code>In[3]:= Solve[2 == x^2 + y^2 + (x + 2*-1)^2 + (y + 2*-1)^2, y]\nOut[3]= {{y -&gt; 1 + Sqrt[-2 + 2*x + x^2*-1]*-1}, {y -&gt; 1 + Sqrt[-2 + 2*x + x^2*-1]}}\n</code></pre></p>"},{"location":"builtin/sort/","title":"sort documentation","text":"<p>Sort</p> <p>Order</p>"},{"location":"builtin/sort/order/","title":"Order","text":"<p><code>Order[e1, e2]</code> returns 1 if <code>e1</code> should come before <code>e2</code> in canonical ordering, -1 if it should come after, and 0 if the two expressions are equal.</p> <p><code>Attributes[Order] := {Protected}</code></p>"},{"location":"builtin/sort/order/#simple-examples","title":"Simple examples","text":"<p>Find the relative order of symbols: <pre><code>In[1]:= Order[a, b]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Order[b, a]\nOut[2]= -1\n</code></pre> <pre><code>In[3]:= Order[a, aa]\nOut[3]= 1\n</code></pre> Find the relative order of numbers: <pre><code>In[4]:= Order[2, 1.]\nOut[4]= -1\n</code></pre> <pre><code>In[5]:= Order[1, 2]\nOut[5]= 1\n</code></pre> <pre><code>In[6]:= Order[1, 1]\nOut[6]= 0\n</code></pre> Find the relative order of strings: <pre><code>In[7]:= Order[\"a\", \"b\"]\nOut[7]= 1\n</code></pre> <pre><code>In[8]:= Order[\"b\", \"a\"]\nOut[8]= -1\n</code></pre> Find the relative order of heterogenous types: <pre><code>In[9]:= Order[ab, 1]\nOut[9]= -1\n</code></pre> <pre><code>In[10]:= Order[1, ab]\nOut[10]= 1\n</code></pre> <pre><code>In[11]:= Order[y[a], x]\nOut[11]= -1\n</code></pre> Find the relative order of rationals: <pre><code>In[12]:= Order[Rational[-5, 3], Rational[-4, 6]]\nOut[12]= 1\n</code></pre> <pre><code>In[13]:= Order[Rational[4, 6], 0.6]\nOut[13]= -1\n</code></pre> <pre><code>In[14]:= Order[0.6, Rational[4, 6]]\nOut[14]= 1\n</code></pre> <pre><code>In[15]:= Order[Rational[4, 6], 0.7]\nOut[15]= 1\n</code></pre> Find the relative order of expressions: <pre><code>In[16]:= Order[bar[x, y], bar[x, y]]\nOut[16]= 0\n</code></pre> <pre><code>In[17]:= Order[fizz[bar[x, y]], fizz[bar[x, y, a]]]\nOut[17]= 1\n</code></pre></p>"},{"location":"builtin/sort/sort/","title":"Sort","text":"<p><code>Sort[list]</code> sorts the elements in list according to <code>Order</code>.</p> <p><code>Attributes[Sort] := {Protected}</code></p>"},{"location":"builtin/sort/sort/#simple-examples","title":"Simple examples","text":"<p>Sort a list of numbers: <pre><code>In[1]:= Sort[{6, 2, 3.2, -5.1}]\nOut[1]= {-5.1, 2, 3.2, 6}\n</code></pre> Sort a list of strings: <pre><code>In[2]:= Sort[{\"hello\", \"a\", \"aa\", \"zzz\"}]\nOut[2]= {\"a\", \"aa\", \"hello\", \"zzz\"}\n</code></pre> Sort a list of symbols: <pre><code>In[3]:= Sort[{d, a, b, c}]\nOut[3]= {a, b, c, d}\n</code></pre> Sort a list of heterogenous expressions: <pre><code>In[4]:= Sort[{5, h, foo[y, 2], bar[a^x]}]\nOut[4]= {5, h, bar[a^x], foo[y, 2]}\n</code></pre></p>"},{"location":"builtin/sort/sort/#further-examples","title":"Further examples","text":"<p>The object to sort need not be a list: <pre><code>In[1]:= Sort[foo[d, a, b, c]]\nOut[1]= foo[a, b, c, d]\n</code></pre></p>"},{"location":"builtin/specialsyms/","title":"specialsyms documentation","text":"<p>Infinity</p> <p>ComplexInfinity</p> <p>Indeterminate</p> <p>Pi</p> <p>E</p> <p>Subscript</p>"},{"location":"builtin/specialsyms/complexinfinity/","title":"ComplexInfinity","text":"<p><code>ComplexInfinity</code> represents an an infinite quantity that extends in an unknown direction in the complex plane.</p> <p><code>Attributes[ComplexInfinity] := {Protected}</code></p>"},{"location":"builtin/specialsyms/complexinfinity/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (1/(0))\nOut[1]= ComplexInfinity\n</code></pre> <pre><code>In[2]:= (a)/(0)\nOut[2]= ComplexInfinity\n</code></pre> <pre><code>In[3]:= ComplexInfinity*foo[x]\nOut[3]= ComplexInfinity\n</code></pre> <pre><code>In[4]:= Factorial[-1]\nOut[4]= ComplexInfinity\n</code></pre></p>"},{"location":"builtin/specialsyms/e/","title":"E","text":"<p><code>E</code> is the constant for the base of the natural logarithm.</p> <p><code>Attributes[E] := {Constant, Protected, ReadProtected}</code></p>"},{"location":"builtin/specialsyms/indeterminate/","title":"Indeterminate","text":"<p><code>Indeterminate</code> represents an indeterminate form.</p> <p><code>Attributes[Indeterminate] := {Protected}</code></p>"},{"location":"builtin/specialsyms/indeterminate/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= (0)/(0)\nOut[1]= Indeterminate\n</code></pre> <pre><code>In[2]:= Infinity + Infinity*-1\nOut[2]= Indeterminate\n</code></pre> <pre><code>In[3]:= 0*Infinity\nOut[3]= Indeterminate\n</code></pre> <pre><code>In[4]:= 0*ComplexInfinity\nOut[4]= Indeterminate\n</code></pre> <pre><code>In[5]:= 0^0\nOut[5]= Indeterminate\n</code></pre></p>"},{"location":"builtin/specialsyms/infinity/","title":"Infinity","text":"<p><code>Infinity</code> represents the mathematical concept of infinity.</p> <p><code>Attributes[Infinity] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/specialsyms/infinity/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Infinity + 1*-1\nOut[1]= Infinity\n</code></pre> <pre><code>In[2]:= Infinity + 990999999*-1\nOut[2]= Infinity\n</code></pre> <pre><code>In[3]:= Infinity + 9.91e+08*-1\nOut[3]= Infinity\n</code></pre> <pre><code>In[4]:= Infinity + Infinity*-1\nOut[4]= Indeterminate\n</code></pre> <pre><code>In[5]:= Infinity*-1\nOut[5]= Infinity*-1\n</code></pre> <pre><code>In[6]:= Infinity*-1 + 1\nOut[6]= Infinity*-1\n</code></pre> <pre><code>In[7]:= Infinity*-1 + 999\nOut[7]= Infinity*-1\n</code></pre> <pre><code>In[8]:= Infinity*-1*-1\nOut[8]= Infinity\n</code></pre> <pre><code>In[9]:= (1)/(Infinity)\nOut[9]= 0\n</code></pre></p>"},{"location":"builtin/specialsyms/pi/","title":"Pi","text":"<p><code>Pi</code> is the constant of pi.</p> <p><code>Attributes[Pi] := {Constant, Protected, ReadProtected}</code></p>"},{"location":"builtin/specialsyms/subscript/","title":"Subscript","text":"<p><code>Attributes[Subscript] := {Protected}</code></p>"},{"location":"builtin/stats/","title":"stats documentation","text":"<p>NormalDistribution</p> <p>LogNormalDistribution</p> <p>PDF</p>"},{"location":"builtin/stats/lognormaldistribution/","title":"LogNormalDistribution","text":"<p><code>LogNormalDistribution[mu, sigma]</code> is a lognormal distribution with a mean <code>mu</code> and standard deviation of <code>sigma</code>.</p> <p><code>Attributes[LogNormalDistribution] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/stats/lognormaldistribution/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= PDF[LogNormalDistribution[\u03bc, \u03c3], x]\nOut[1]= Piecewise[{{(1)/(E^(((\u03bc*-1 + Log[x])^2))/((2*\u03c3^2))*Sqrt[2*Pi]*x*\u03c3), (x) &gt; (0)}}, 0]\n</code></pre>"},{"location":"builtin/stats/normaldistribution/","title":"NormalDistribution","text":"<p><code>NormalDistribution[mu, sigma]</code> is a normal distribution with a mean <code>mu</code> and standard deviation of <code>sigma</code>.</p> <p><code>Attributes[NormalDistribution] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/stats/normaldistribution/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= PDF[NormalDistribution[\u03bc, \u03c3], x]\nOut[1]= (E^(((x + \u03bc*-1)^2)/((2*\u03c3^2))*-1))/(Sqrt[2*Pi]*\u03c3)\n</code></pre>"},{"location":"builtin/stats/pdf/","title":"PDF","text":"<p><code>PDF[dist, var]</code> calculates the PDF of <code>dist</code>.</p> <p><code>Attributes[PDF] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/stats/pdf/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= PDF[NormalDistribution[\u03bc, \u03c3], x]\nOut[1]= (E^(((x + \u03bc*-1)^2)/((2*\u03c3^2))*-1))/(Sqrt[2*Pi]*\u03c3)\n</code></pre> <pre><code>In[2]:= PDF[LogNormalDistribution[\u03bc, \u03c3], x]\nOut[2]= Piecewise[{{(1)/(E^(((\u03bc*-1 + Log[x])^2))/((2*\u03c3^2))*Sqrt[2*Pi]*x*\u03c3), (x) &gt; (0)}}, 0]\n</code></pre></p>"},{"location":"builtin/string/","title":"string documentation","text":"<p>ToString</p> <p>StringJoin</p> <p>Infix</p> <p>StringLength</p> <p>StringTake</p> <p>StringReplace</p> <p>ExportString</p>"},{"location":"builtin/string/exportstring/","title":"ExportString","text":"<p><code>ExportString[str, \"format\"]</code> encodes <code>str</code> into \"format\".</p> <p><code>Attributes[ExportString] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/string/exportstring/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= ExportString[\"Hello World\", \"base64\"]\nOut[1]= \"SGVsbG8gV29ybGQ=\n\"\n</code></pre>"},{"location":"builtin/string/infix/","title":"Infix","text":"<p><code>Infix[expr, sep]</code> represents <code>expr</code> in infix form with separator <code>sep</code> when converted to a string.</p> <p><code>Attributes[Infix] := {Protected}</code></p>"},{"location":"builtin/string/infix/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= ToString[bar|fuzz|zip]\nOut[1]= \"bar|fuzz|zip\"\n</code></pre>"},{"location":"builtin/string/stringjoin/","title":"StringJoin","text":"<p><code>s1 &lt;&gt; s2 &lt;&gt; ...</code> can join a list of strings into a single string.</p> <p><code>Attributes[StringJoin] := {Flat, OneIdentity, Protected}</code></p>"},{"location":"builtin/string/stringjoin/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= \"Hello\" &lt;&gt; \" \" &lt;&gt; \"World\"\nOut[1]= \"Hello World\"\n</code></pre> <pre><code>In[2]:= \"If a=2, then \" &lt;&gt; ToString[a^2, InputForm] &lt;&gt; \"=\" &lt;&gt; ToString[((a^2)) /. ((a -&gt; 2)), InputForm]\nOut[2]= \"If a=2, then a^2=4\"\n</code></pre></p>"},{"location":"builtin/string/stringjoin/#further-examples","title":"Further examples","text":"<p>The <code>StringJoin</code> of nothing is the empty string: <pre><code>In[1]:= StringJoin[]\nOut[1]= \"\"\n</code></pre> If <code>StringJoin</code> receives any non-string arguments, the expression does not evaluate: <pre><code>In[2]:= \"Hello\" &lt;&gt; 5\nOut[2]= \"Hello\" &lt;&gt; 5\n</code></pre> This function takes <code>List</code> arguments as well: <pre><code>In[3]:= StringJoin[{\"a\", \"b\", \"c\"}]\nOut[3]= \"abc\"\n</code></pre></p>"},{"location":"builtin/string/stringlength/","title":"StringLength","text":"<p><code>StringLength[s]</code> returns the length of s.</p> <p><code>Attributes[StringLength] := {Listable, Protected}</code></p>"},{"location":"builtin/string/stringlength/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= StringLength[\"Hello\"]\nOut[1]= 5\n</code></pre>"},{"location":"builtin/string/stringreplace/","title":"StringReplace","text":"<p><code>StringReplace[str, before-&gt;after]</code> replaces any occurrence of <code>before</code> with <code>after</code> in <code>str</code>.</p> <p><code>Attributes[StringReplace] := {Protected}</code></p>"},{"location":"builtin/string/stringreplace/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= StringReplace[\"hello world\", \"world\" -&gt; \"foo\"]\nOut[1]= \"hello foo\"\n</code></pre>"},{"location":"builtin/string/stringtake/","title":"StringTake","text":"<p><code>StringTake[s, {start, end}]</code> takes a substring of s.</p> <p><code>Attributes[StringTake] := {Protected}</code></p>"},{"location":"builtin/string/stringtake/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= StringTake[\"hello\", {1, 1}]\nOut[1]= \"h\"\n</code></pre> <pre><code>In[2]:= StringTake[\"hello\", {0, 1}]\nOut[2]= StringTake[\"hello\", {0, 1}]\n</code></pre> <pre><code>In[3]:= StringTake[\"hello\", {1, StringLength[\"hello\"]}]\nOut[3]= \"hello\"\n</code></pre> <pre><code>In[4]:= StringTake[\"hello\", {2, 1}]\nOut[4]= \"\"\n</code></pre> <pre><code>In[5]:= StringTake[\"hello\", {2, 999}]\nOut[5]= StringTake[\"hello\", {2, 999}]\n</code></pre></p>"},{"location":"builtin/string/tostring/","title":"ToString","text":"<p><code>ToString[expr, form]</code> converts <code>expr</code> into a string using printing method <code>form</code>.</p> <p><code>Attributes[ToString] := {Protected}</code></p>"},{"location":"builtin/string/tostring/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= ToString[a^2, InputForm]\nOut[1]= \"a^2\"\n</code></pre> <pre><code>In[2]:= ToString[Sin[1], TeXForm]\nOut[2]= \"\\sin \\left(1\\right)\"\n</code></pre> <pre><code>In[3]:= ToString[\"Hello World\"]\nOut[3]= \"Hello World\"\n</code></pre></p>"},{"location":"builtin/system/","title":"system documentation","text":"<p>ExpreduceSetLogging</p> <p>ExpreduceDefinitionTimes</p> <p>Attributes</p> <p>Default</p> <p>Clear</p> <p>Definition</p> <p>DownValues</p> <p>Set</p> <p>SetDelayed</p> <p>Timing</p> <p>Print</p> <p>MessageName</p> <p>Trace</p> <p>N</p> <p>Listable</p> <p>Get</p> <p>Save</p> <p>Module</p> <p>Hash</p> <p>ReadList</p> <p>BeginPackage</p> <p>EndPackage</p> <p>Begin</p> <p>End</p> <p>PrintTemporary</p> <p>SetAttributes</p> <p>ClearAttributes</p> <p>Protect</p> <p>Unprotect</p> <p>ClearAll</p> <p>Throw</p> <p>Catch</p> <p>Unique</p> <p>Sow</p> <p>Reap</p> <p>Information</p> <p>OutputStream</p> <p>WriteString</p> <p>Streams</p> <p>Names</p>"},{"location":"builtin/system/attributes/","title":"Attributes","text":"<p><code>Attributes[sym]</code> returns a <code>List</code> of attributes for <code>sym</code>.</p> <p><code>Attributes[Attributes] := {HoldAll, Listable, Protected}</code></p>"},{"location":"builtin/system/attributes/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Attributes[Infinity]\nOut[1]= {Protected, ReadProtected}\n</code></pre> <pre><code>In[2]:= Attributes[Attributes]\nOut[2]= {HoldAll, Listable, Protected}\n</code></pre> <pre><code>In[3]:= Attributes[Plus]\nOut[3]= {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}\n</code></pre> The default set of attributes is the empty list: <pre><code>In[4]:= Attributes[undefinedSym]\nOut[4]= {}\n</code></pre></p>"},{"location":"builtin/system/attributes/#further-examples","title":"Further examples","text":"<p>Only symbols can have attributes: <pre><code>In[1]:= Attributes[2]\nOut[1]= Attributes[2]\n</code></pre> <pre><code>In[2]:= Attributes[a^2]\nOut[2]= Attributes[a^2]\n</code></pre></p>"},{"location":"builtin/system/begin/","title":"Begin","text":"<p><code>Begin[context]</code> updates the context.</p> <p><code>Attributes[Begin] := {Protected}</code></p>"},{"location":"builtin/system/beginpackage/","title":"BeginPackage","text":"<p><code>BeginPackage[context]</code> updates the context and sets the context path to only the current context and System.</p> <p><code>Attributes[BeginPackage] := {Protected}</code></p>"},{"location":"builtin/system/catch/","title":"Catch","text":"<p><code>Catch[e]</code> catches and returns any <code>Thrown</code> expressions, if any. Otherwise returns the result of <code>e</code>.</p> <p><code>Attributes[Catch] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/system/catch/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Catch[CompoundExpression[a, b, Throw[c], d, e]]\nOut[1]= c\n</code></pre> <pre><code>In[2]:= Catch[{a, b, Throw[c], d}]\nOut[2]= c\n</code></pre></p>"},{"location":"builtin/system/clear/","title":"Clear","text":"<p><code>Clear[sym1, sym2, ...]</code> clears the symbol definitions from the evaluation context.</p> <p><code>Attributes[Clear] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/clear/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= a\nOut[1]= a\n</code></pre> <pre><code>In[2]:= a = 5\nOut[2]= 5\n</code></pre> <pre><code>In[3]:= b = 6\nOut[3]= 6\n</code></pre> <pre><code>In[4]:= c = 7\nOut[4]= 7\n</code></pre> <pre><code>In[5]:= a\nOut[5]= 5\n</code></pre> <pre><code>In[6]:= Clear[a, 99, b]\nOut[6]= Null\n</code></pre> <pre><code>In[7]:= Head[a]\nOut[7]= Symbol\n</code></pre> <pre><code>In[8]:= Head[b]\nOut[8]= Symbol\n</code></pre> <pre><code>In[9]:= Head[c]\nOut[9]= Integer\n</code></pre> <pre><code>In[10]:= Clear[c]\nOut[10]= Null\n</code></pre> <pre><code>In[11]:= Head[c]\nOut[11]= Symbol\n</code></pre></p>"},{"location":"builtin/system/clearall/","title":"ClearAll","text":"<p><code>ClearAll[s1, s2, ...]</code> clears all definitions associated with the symbols.</p> <p><code>Attributes[ClearAll] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/clearall/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Attributes[mytestsym] = {HoldAll}\nOut[1]= {HoldAll}\n</code></pre> <pre><code>In[2]:= mytestsym[5] := 6\nOut[2]= Null\n</code></pre> <pre><code>In[3]:= mytestsym[7] := 8\nOut[3]= Null\n</code></pre> <pre><code>In[4]:= Length[Attributes[mytestsym]]\nOut[4]= 1\n</code></pre> <pre><code>In[5]:= Length[DownValues[mytestsym]]\nOut[5]= 2\n</code></pre> <pre><code>In[6]:= ClearAll[mytestsym]\nOut[6]= Null\n</code></pre> <pre><code>In[7]:= Length[Attributes[mytestsym]]\nOut[7]= 0\n</code></pre> <pre><code>In[8]:= Length[DownValues[mytestsym]]\nOut[8]= 0\n</code></pre></p>"},{"location":"builtin/system/clearattributes/","title":"ClearAttributes","text":"<p><code>ClearAttributes[sym, attributes]</code> clears the <code>attributes</code> from <code>sym</code>.</p> <p><code>Attributes[ClearAttributes] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/system/default/","title":"Default","text":"<p><code>Default[sym]</code> returns the default value of <code>sym</code> when used as an <code>Optional</code> pattern without a default specified.</p> <p><code>Attributes[Default] := {Protected}</code></p>"},{"location":"builtin/system/default/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Default[Times]\nOut[1]= 1\n</code></pre> <pre><code>In[2]:= Default[Plus]\nOut[2]= 0\n</code></pre></p>"},{"location":"builtin/system/definition/","title":"Definition","text":"<p><code>Definition[sym]</code> renders the attributes, downvalues, and default value of <code>sym</code>.</p> <p><code>Attributes[Definition] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/downvalues/","title":"DownValues","text":"<p><code>DownValues[sym]</code> returns a list of downvalues for <code>sym</code>.</p> <p><code>Attributes[DownValues] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/end/","title":"End","text":"<p><code>End[]</code> updates the context to rever the changes caused by <code>Begin</code>.</p> <p><code>Attributes[End] := {Protected}</code></p>"},{"location":"builtin/system/endpackage/","title":"EndPackage","text":"<p><code>EndPackage[]</code> resets the contexts to the original values, but with the package context prepended.</p> <p><code>Attributes[EndPackage] := {Protected}</code></p>"},{"location":"builtin/system/expreducedefinitiontimes/","title":"ExpreduceDefinitionTimes","text":"<p><code>ExpreduceDefinitionTimes[]</code> prints the time in seconds evaluating various definitions.</p> <p><code>Attributes[ExpreduceDefinitionTimes] := {Protected}</code></p>"},{"location":"builtin/system/expreducedefinitiontimes/#details","title":"Details","text":"<p>For timing information to record, debug mode must be enabled through <code>ExpreduceSetLogging</code>.</p>"},{"location":"builtin/system/expreducesetlogging/","title":"ExpreduceSetLogging","text":"<p><code>ExpreduceSetLogging[bool, level]</code> sets the logging state to <code>bool</code> and the level to <code>level</code>.</p> <p><code>Attributes[ExpreduceSetLogging] := {Protected}</code></p>"},{"location":"builtin/system/expreducesetlogging/#details","title":"Details","text":"<p>Logging output prints to the console. There can be a lot of logging output, especially for more complicated pattern matches. Valid levels are <code>Debug</code>, <code>Info</code>, <code>Notice</code>, <code>Warning</code>, <code>Error</code>, and <code>Critical</code>.</p>"},{"location":"builtin/system/get/","title":"Get","text":"<p><code>Get[file]</code> loads <code>file</code> and returns the last expression.</p> <p><code>Attributes[Get] := {Protected}</code></p>"},{"location":"builtin/system/hash/","title":"Hash","text":"<p><code>Hash[expr]</code> returns an integer hash of <code>expr</code>.</p> <p><code>Attributes[Hash] := {Protected}</code></p>"},{"location":"builtin/system/information/","title":"Information","text":"<p><code>Information[sym]</code> renders the usage, attributes, downvalues, and default value of <code>sym</code>.</p> <p><code>Attributes[Information] := {HoldAll, Protected, ReadProtected}</code></p>"},{"location":"builtin/system/listable/","title":"Listable","text":"<p><code>Listable</code> is an attribute that calls for functions to automatically map over lists.</p> <p><code>Attributes[Listable] := {Protected}</code></p>"},{"location":"builtin/system/listable/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Boole[{True, True, True, False}]\nOut[1]= {1, 1, 1, 0}\n</code></pre> <pre><code>In[2]:= Positive[{-1, 4, 5}]\nOut[2]= {False, True, True}\n</code></pre> <pre><code>In[3]:= Positive[{{-1, 4, 5}}]\nOut[3]= {{False, True, True}}\n</code></pre> <pre><code>In[4]:= Positive[{{-1, 4, 5}, {6, -1}}]\nOut[4]= {{False, True, True}, {True, False}}\n</code></pre></p>"},{"location":"builtin/system/messagename/","title":"MessageName","text":"<p><code>sym::msg</code> references a particular message for <code>sym</code>.</p> <p><code>Attributes[MessageName] := {HoldFirst, Protected, ReadProtected}</code></p>"},{"location":"builtin/system/messagename/#simple-examples","title":"Simple examples","text":"<p><code>MessageName</code> is used to store the usage messages of built-in symbols: <pre><code>In[1]:= MessageName[MessageName, \"usage\"]\nOut[1]= \"`sym::msg` references a particular message for `sym`.\"\n</code></pre></p>"},{"location":"builtin/system/module/","title":"Module","text":"<p><code>Module[{locals}, expr]</code> evaluates <code>expr</code> with the local variables <code>locals</code>.</p> <p><code>Attributes[Module] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/n/","title":"N","text":"<p><code>N[expr]</code> attempts to convert <code>expr</code> to a numeric value.</p> <p><code>Attributes[N] := {Protected}</code></p>"},{"location":"builtin/system/names/","title":"Names","text":"<p><code>Names[]</code> returns a list of all defined symbols.</p> <p><code>Names[\"pattern\"]</code> returns a list of all defined symbols matching the regex pattern.</p> <p><code>Attributes[Names] := {Protected}</code></p>"},{"location":"builtin/system/outputstream/","title":"OutputStream","text":"<p><code>Attributes[OutputStream] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/system/print/","title":"Print","text":"<p><code>Print[expr1, expr2, ...]</code> prints the string representation of the expressions to the console and returns <code>Null</code>.</p> <p><code>Attributes[Print] := {Protected}</code></p>"},{"location":"builtin/system/printtemporary/","title":"PrintTemporary","text":"<p><code>PrintTemporary[expr1, expr2, ...]</code> prints the string representation of the expressions to the console and returns <code>Null</code>.</p> <p><code>Attributes[PrintTemporary] := {Protected}</code></p>"},{"location":"builtin/system/protect/","title":"Protect","text":"<p><code>Protect[sym]</code> adds the <code>Protected</code> attribute to <code>sym</code>.</p> <p><code>Attributes[Protect] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/readlist/","title":"ReadList","text":"<p><code>ReadList[file]</code> reads expressions in <code>file</code> into a list.</p> <p><code>Attributes[ReadList] := {Protected}</code></p>"},{"location":"builtin/system/reap/","title":"Reap","text":"<p><code>Reap[expr]</code> returns the result of <code>expr</code> and a list of all the sown values during evaluation.</p> <p><code>Attributes[Reap] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/system/save/","title":"Save","text":"<p><code>Save[filename, {sym1, sym2, ...}]</code> saves a list of symbols into a file.</p> <p><code>Attributes[Save] := {HoldRest, Protected}</code></p>"},{"location":"builtin/system/set/","title":"Set","text":"<p><code>lhs = rhs</code> sets <code>lhs</code> to stand for <code>rhs</code>.</p> <p><code>Attributes[Set] := {HoldFirst, Protected, SequenceHold}</code></p>"},{"location":"builtin/system/set/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= x=1+2\nOut[1]= 3\n</code></pre> <pre><code>In[2]:= x\nOut[2]= 3\n</code></pre> <pre><code>In[3]:= x+1\nOut[3]= 4\n</code></pre> <pre><code>In[4]:= x+1\nOut[4]= 4\n</code></pre> <pre><code>In[5]:= x=1+2\nOut[5]= 3\n</code></pre> <pre><code>In[6]:= x*2\nOut[6]= 6\n</code></pre> <pre><code>In[7]:= x=x*2\nOut[7]= 6\n</code></pre> <pre><code>In[8]:= x=x*x\nOut[8]= 36\n</code></pre></p>"},{"location":"builtin/system/set/#further-examples","title":"Further examples","text":"<p><code>Set</code> has the <code>HoldFirst</code> attribute, meaning <code>rhs</code> is evaluated before assignment: <pre><code>In[1]:= Attributes[Set]\nOut[1]= {HoldFirst, Protected, SequenceHold}\n</code></pre> <code>SetDelayed</code> has the <code>HoldAll</code> attribute, meaning <code>rhs</code> is not evaluated during assignment: <pre><code>In[2]:= Attributes[SetDelayed]\nOut[2]= {HoldAll, Protected, SequenceHold}\n</code></pre></p>"},{"location":"builtin/system/setattributes/","title":"SetAttributes","text":"<p><code>SetAttributes[sym, attributes]</code> adds the <code>attributes</code> to <code>sym</code>.</p> <p><code>Attributes[SetAttributes] := {HoldFirst, Protected}</code></p>"},{"location":"builtin/system/setdelayed/","title":"SetDelayed","text":"<p><code>lhs := rhs</code> sets <code>lhs</code> to stand for <code>rhs</code>, with <code>rhs</code> not being evaluated until it is referenced by <code>lhs</code>.</p> <p><code>Attributes[SetDelayed] := {HoldAll, Protected, SequenceHold}</code></p>"},{"location":"builtin/system/setdelayed/#simple-examples","title":"Simple examples","text":"<p><code>SetDelayed</code> can be used to define functions: <pre><code>In[1]:= testa[x_] := x*2\nOut[1]= Null\n</code></pre> <pre><code>In[2]:= testa[x_Integer] := x*3\nOut[2]= Null\n</code></pre> <pre><code>In[3]:= testa[x_Real] := x*4\nOut[3]= Null\n</code></pre> The more \"specific\" definitions match first: <pre><code>In[4]:= testa[2.]\nOut[4]= 8.\n</code></pre> <pre><code>In[5]:= testa[2]\nOut[5]= 6\n</code></pre> There is no specific match for <code>testa[k]</code>, so the general case matches: <pre><code>In[6]:= testa[k]\nOut[6]= 2 * k\n</code></pre></p>"},{"location":"builtin/system/setdelayed/#further-examples","title":"Further examples","text":"<p><code>Set</code> has the <code>HoldFirst</code> attribute, meaning <code>rhs</code> is evaluated before assignment: <pre><code>In[1]:= Attributes[Set]\nOut[1]= {HoldFirst, Protected, SequenceHold}\n</code></pre> <code>SetDelayed</code> has the <code>HoldAll</code> attribute, meaning <code>rhs</code> is not evaluated during assignment: <pre><code>In[2]:= Attributes[SetDelayed]\nOut[2]= {HoldAll, Protected, SequenceHold}\n</code></pre></p>"},{"location":"builtin/system/sow/","title":"Sow","text":"<p><code>Sow[e]</code> sows a value <code>e</code> for <code>Reap[]</code>.</p> <p><code>Attributes[Sow] := {Protected}</code></p>"},{"location":"builtin/system/streams/","title":"Streams","text":"<p><code>Streams[]</code> gets a list of all open streams.</p> <p><code>Attributes[Streams] := {Protected}</code></p>"},{"location":"builtin/system/streams/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Streams[]\nOut[1]= {OutputStream[\"stdout\", 1], OutputStream[\"stderr\", 2]}\n</code></pre>"},{"location":"builtin/system/throw/","title":"Throw","text":"<p><code>Throw[e]</code> stops all execution, propagating the value down with the intention of it being caught. Only some of the flow control statements in the language actually support execution interruption right now.</p> <p><code>Attributes[Throw] := {Protected}</code></p>"},{"location":"builtin/system/timing/","title":"Timing","text":"<p><code>Timing[expr]</code> returns a <code>List</code> with the first element being the time in seconds for the evaluation of <code>expr</code>, and the second element being the result.</p> <p><code>Attributes[Timing] := {HoldAll, Protected, SequenceHold}</code></p>"},{"location":"builtin/system/timing/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Timing[Sum[a, {a, 100000000}]]\nOut[1]= {0.00167509, 5000000050000000}\n</code></pre>"},{"location":"builtin/system/trace/","title":"Trace","text":"<p><code>Trace[expr]</code> traces the evaluation of <code>expr</code>.</p> <p><code>Attributes[Trace] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/trace/#simple-examples","title":"Simple examples","text":"<p><pre><code>In[1]:= Trace[1 + 2]\nOut[1]= {1 + 2, 3}\n</code></pre> <pre><code>In[2]:= Trace[(1 + 3) + 2]\nOut[2]= {{1 + 3, 4}, 4 + 2, 6}\n</code></pre> <pre><code>In[3]:= Trace[2 + (1 + 3)]\nOut[3]= {{1 + 3, 4}, 2 + 4, 6}\n</code></pre></p>"},{"location":"builtin/system/unique/","title":"Unique","text":"<p><code>Unique[]</code> returns a unique symbol.</p> <p><code>Attributes[Unique] := {Protected}</code></p>"},{"location":"builtin/system/unprotect/","title":"Unprotect","text":"<p><code>Unprotect[sym]</code> clears the <code>Protected</code> attribute from <code>sym</code>.</p> <p><code>Attributes[Unprotect] := {HoldAll, Protected}</code></p>"},{"location":"builtin/system/writestring/","title":"WriteString","text":"<p><code>Attributes[WriteString] := {Protected}</code></p>"},{"location":"builtin/tests/","title":"tests documentation","text":""},{"location":"builtin/time/","title":"time documentation","text":"<p>UnixTime</p> <p>Pause</p>"},{"location":"builtin/time/pause/","title":"Pause","text":"<p><code>Pause[d]</code> sleeps for <code>d</code> seconds.</p> <p><code>Attributes[Pause] := {Protected}</code></p>"},{"location":"builtin/time/pause/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Pause[0.001]\nOut[1]= Null\n</code></pre>"},{"location":"builtin/time/unixtime/","title":"UnixTime","text":"<p><code>UnixTime[]</code> returns the integer seconds since the Unix epoch in UTC time.</p> <p><code>Attributes[UnixTime] := {Protected, ReadProtected}</code></p>"},{"location":"builtin/time/unixtime/#simple-examples","title":"Simple examples","text":"<p>Get the current Unix timestamp: <pre><code>In[1]:= UnixTime[]\nOut[1]= 1484805639\n</code></pre> <code>UnixTime</code> returns an Integer: <pre><code>In[2]:= Head[UnixTime[]]\nOut[2]= Integer\n</code></pre></p>"},{"location":"builtin/trig/","title":"trig documentation","text":"<p>Sin</p> <p>Cos</p> <p>Tan</p> <p>ArcTan</p> <p>Cot</p> <p>Degree</p> <p>RotationMatrix</p>"},{"location":"builtin/trig/arctan/","title":"ArcTan","text":"<p><code>Attributes[ArcTan] := {Listable, NumericFunction, Protected, ReadProtected}</code></p>"},{"location":"builtin/trig/cos/","title":"Cos","text":"<p><code>Cos[x]</code> is the cosine of <code>x</code>.</p> <p><code>Attributes[Cos] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/trig/cot/","title":"Cot","text":"<p><code>Cot[x]</code> is the cotangent of <code>x</code>.</p> <p><code>Attributes[Cot] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/trig/degree/","title":"Degree","text":"<p><code>Degree</code> stands for Pi/180.</p> <p><code>Attributes[Degree] := {Constant, Protected, ReadProtected}</code></p>"},{"location":"builtin/trig/degree/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= Sin[90*Degree]\nOut[1]= 1\n</code></pre>"},{"location":"builtin/trig/rotationmatrix/","title":"RotationMatrix","text":"<p><code>RotationMatrix[\u03b8]</code> yields a rotation matrix for the angle <code>\u03b8</code>.</p> <p><code>Attributes[RotationMatrix] := {Protected}</code></p>"},{"location":"builtin/trig/rotationmatrix/#simple-examples","title":"Simple examples","text":"<pre><code>In[1]:= RotationMatrix[90*Degree]\nOut[1]= {{0, -1}, {1, 0}}\n</code></pre>"},{"location":"builtin/trig/sin/","title":"Sin","text":"<p><code>Sin[x]</code> is the sine of <code>x</code>.</p> <p><code>Attributes[Sin] := {Listable, NumericFunction, Protected}</code></p>"},{"location":"builtin/trig/tan/","title":"Tan","text":"<p><code>Tan[x]</code> is the tangent of <code>x</code>.</p> <p><code>Attributes[Tan] := {Listable, NumericFunction, Protected}</code></p>"}]}